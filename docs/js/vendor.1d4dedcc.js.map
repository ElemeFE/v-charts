{"version":3,"sources":["webpack:///js/vendor.1d4dedcc.js","webpack:///./~/zrender/lib/core/util.js","webpack:///./~/echarts/lib/echarts.js","webpack:///./~/echarts/lib/util/graphic.js","webpack:///./~/echarts/lib/util/number.js","webpack:///./~/vue-loader/lib/component-normalizer.js","webpack:///./~/zrender/lib/core/vector.js","webpack:///./~/zrender/lib/graphic/Path.js","webpack:///./~/echarts/lib/util/format.js","webpack:///./~/echarts/lib/util/model.js","webpack:///./~/echarts/lib/model/Model.js","webpack:///./~/zrender/lib/core/env.js","webpack:///./~/zrender/lib/core/BoundingRect.js","webpack:///./~/echarts/lib/util/clazz.js","webpack:///./~/echarts/lib/model/Component.js","webpack:///./~/echarts/lib/util/layout.js","webpack:///./~/zrender/lib/contain/text.js","webpack:///./~/zrender/lib/core/curve.js","webpack:///./~/echarts/lib/data/List.js","webpack:///./~/echarts/lib/model/Series.js","webpack:///(webpack)/buildin/global.js","webpack:///./~/zrender/lib/core/matrix.js","webpack:///./~/zrender/lib/mixin/Eventful.js","webpack:///./~/zrender/lib/tool/color.js","webpack:///./~/echarts/lib/CoordinateSystem.js","webpack:///./~/echarts/lib/coord/axisHelper.js","webpack:///./~/echarts/lib/data/helper/completeDimensions.js","webpack:///./~/echarts/lib/model/mixin/makeStyleMapper.js","webpack:///./~/echarts/lib/scale/Interval.js","webpack:///./~/echarts/lib/scale/Scale.js","webpack:///./~/echarts/lib/util/symbol.js","webpack:///./~/echarts/lib/view/Chart.js","webpack:///./~/zrender/lib/config.js","webpack:///./~/zrender/lib/container/Group.js","webpack:///./~/zrender/lib/core/PathProxy.js","webpack:///./~/zrender/lib/core/event.js","webpack:///./~/echarts/lib/chart/bar.js","webpack:///./~/echarts/lib/chart/helper/createListFromArray.js","webpack:///./~/echarts/lib/component/grid.js","webpack:///./~/echarts/lib/processor/dataFilter.js","webpack:///./~/echarts/lib/util/component.js","webpack:///./~/echarts/lib/visual/dataColor.js","webpack:///./~/echarts/lib/visual/symbol.js","webpack:///./~/zrender/lib/core/timsort.js","webpack:///./~/zrender/lib/graphic/Displayable.js","webpack:///./~/zrender/lib/graphic/Gradient.js","webpack:///./~/vue/dist/vue.esm.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/echarts/lib/chart/helper/Symbol.js","webpack:///./~/echarts/lib/chart/helper/SymbolDraw.js","webpack:///./~/echarts/lib/chart/pie.js","webpack:///./~/echarts/lib/component/axis/AxisBuilder.js","webpack:///./~/echarts/lib/coord/Axis.js","webpack:///./~/echarts/lib/coord/axisDefault.js","webpack:///./~/echarts/lib/coord/axisModelCommonMixin.js","webpack:///./~/echarts/lib/coord/cartesian/AxisModel.js","webpack:///./~/echarts/lib/coord/cartesian/Grid.js","webpack:///./~/echarts/lib/layout/points.js","webpack:///./~/echarts/lib/model/mixin/colorPalette.js","webpack:///./~/style-loader/addStyles.js","webpack:///./~/zrender/lib/Element.js","webpack:///./~/zrender/lib/animation/Animator.js","webpack:///./~/zrender/lib/animation/requestAnimationFrame.js","webpack:///./~/zrender/lib/contain/util.js","webpack:///./~/zrender/lib/core/guid.js","webpack:///./~/zrender/lib/core/log.js","webpack:///./~/zrender/lib/graphic/Image.js","webpack:///./~/zrender/lib/graphic/Pattern.js","webpack:///./~/zrender/lib/graphic/Style.js","webpack:///./~/zrender/lib/graphic/helper/poly.js","webpack:///./~/prismjs/prism.js","webpack:///./~/base64-js/index.js","webpack:///./~/buffer/index.js","webpack:///./~/echarts/lib/ExtensionAPI.js","webpack:///./~/echarts/lib/action/createDataSelectAction.js","webpack:///./~/echarts/lib/chart/bar/BarSeries.js","webpack:///./~/echarts/lib/chart/bar/BarView.js","webpack:///./~/echarts/lib/chart/bar/BaseBarSeries.js","webpack:///./~/echarts/lib/chart/bar/barItemStyle.js","webpack:///./~/echarts/lib/chart/bar/helper.js","webpack:///./~/echarts/lib/chart/funnel.js","webpack:///./~/echarts/lib/chart/funnel/FunnelSeries.js","webpack:///./~/echarts/lib/chart/funnel/FunnelView.js","webpack:///./~/echarts/lib/chart/funnel/funnelLayout.js","webpack:///./~/echarts/lib/chart/helper/LargeSymbolDraw.js","webpack:///./~/echarts/lib/chart/line.js","webpack:///./~/echarts/lib/chart/line/LineSeries.js","webpack:///./~/echarts/lib/chart/line/LineView.js","webpack:///./~/echarts/lib/chart/line/lineAnimationDiff.js","webpack:///./~/echarts/lib/chart/line/poly.js","webpack:///./~/echarts/lib/chart/pie/PieSeries.js","webpack:///./~/echarts/lib/chart/pie/PieView.js","webpack:///./~/echarts/lib/chart/pie/labelLayout.js","webpack:///./~/echarts/lib/chart/pie/pieLayout.js","webpack:///./~/echarts/lib/chart/radar.js","webpack:///./~/echarts/lib/chart/radar/RadarSeries.js","webpack:///./~/echarts/lib/chart/radar/RadarView.js","webpack:///./~/echarts/lib/chart/radar/backwardCompat.js","webpack:///./~/echarts/lib/chart/radar/radarLayout.js","webpack:///./~/echarts/lib/chart/scatter.js","webpack:///./~/echarts/lib/chart/scatter/ScatterSeries.js","webpack:///./~/echarts/lib/chart/scatter/ScatterView.js","webpack:///./~/echarts/lib/component/axis.js","webpack:///./~/echarts/lib/component/axis/AxisView.js","webpack:///./~/echarts/lib/component/helper/listComponent.js","webpack:///./~/echarts/lib/component/helper/selectableMixin.js","webpack:///./~/echarts/lib/component/legend.js","webpack:///./~/echarts/lib/component/legend/LegendModel.js","webpack:///./~/echarts/lib/component/legend/LegendView.js","webpack:///./~/echarts/lib/component/legend/legendAction.js","webpack:///./~/echarts/lib/component/legend/legendFilter.js","webpack:///./~/echarts/lib/component/radar.js","webpack:///./~/echarts/lib/component/radar/RadarView.js","webpack:///./~/echarts/lib/component/title.js","webpack:///./~/echarts/lib/component/tooltip.js","webpack:///./~/echarts/lib/component/tooltip/TooltipContent.js","webpack:///./~/echarts/lib/component/tooltip/TooltipModel.js","webpack:///./~/echarts/lib/component/tooltip/TooltipView.js","webpack:///./~/echarts/lib/coord/axisModelCreator.js","webpack:///./~/echarts/lib/coord/cartesian/Axis2D.js","webpack:///./~/echarts/lib/coord/cartesian/Cartesian.js","webpack:///./~/echarts/lib/coord/cartesian/Cartesian2D.js","webpack:///./~/echarts/lib/coord/cartesian/GridModel.js","webpack:///./~/echarts/lib/coord/cartesian/axisLabelInterval.js","webpack:///./~/echarts/lib/coord/radar/IndicatorAxis.js","webpack:///./~/echarts/lib/coord/radar/Radar.js","webpack:///./~/echarts/lib/coord/radar/RadarModel.js","webpack:///./~/echarts/lib/data/DataDiffer.js","webpack:///./~/echarts/lib/layout/barGrid.js","webpack:///./~/echarts/lib/loading/default.js","webpack:///./~/echarts/lib/model/Global.js","webpack:///./~/echarts/lib/model/OptionManager.js","webpack:///./~/echarts/lib/model/globalDefault.js","webpack:///./~/echarts/lib/model/mixin/areaStyle.js","webpack:///./~/echarts/lib/model/mixin/boxLayout.js","webpack:///./~/echarts/lib/model/mixin/itemStyle.js","webpack:///./~/echarts/lib/model/mixin/lineStyle.js","webpack:///./~/echarts/lib/model/mixin/textStyle.js","webpack:///./~/echarts/lib/preprocessor/backwardCompat.js","webpack:///./~/echarts/lib/preprocessor/helper/compatStyle.js","webpack:///./~/echarts/lib/processor/dataSample.js","webpack:///./~/echarts/lib/scale/Log.js","webpack:///./~/echarts/lib/scale/Ordinal.js","webpack:///./~/echarts/lib/scale/Time.js","webpack:///./~/echarts/lib/util/throttle.js","webpack:///./~/echarts/lib/view/Component.js","webpack:///./~/echarts/lib/visual/seriesColor.js","webpack:///./~/ieee754/index.js","webpack:///./~/isarray/index.js","webpack:///./~/style-loader/fixUrls.js","webpack:///./~/vue-router/dist/vue-router.esm.js","webpack:///./~/zrender/lib/Handler.js","webpack:///./~/zrender/lib/Layer.js","webpack:///./~/zrender/lib/Painter.js","webpack:///./~/zrender/lib/Storage.js","webpack:///./~/zrender/lib/animation/Animation.js","webpack:///./~/zrender/lib/animation/Clip.js","webpack:///./~/zrender/lib/animation/easing.js","webpack:///./~/zrender/lib/contain/arc.js","webpack:///./~/zrender/lib/contain/cubic.js","webpack:///./~/zrender/lib/contain/line.js","webpack:///./~/zrender/lib/contain/path.js","webpack:///./~/zrender/lib/contain/quadratic.js","webpack:///./~/zrender/lib/contain/windingLine.js","webpack:///./~/zrender/lib/core/GestureMgr.js","webpack:///./~/zrender/lib/core/LRU.js","webpack:///./~/zrender/lib/core/bbox.js","webpack:///./~/zrender/lib/dom/HandlerProxy.js","webpack:///./~/zrender/lib/graphic/CompoundPath.js","webpack:///./~/zrender/lib/graphic/LinearGradient.js","webpack:///./~/zrender/lib/graphic/RadialGradient.js","webpack:///./~/zrender/lib/graphic/Text.js","webpack:///./~/zrender/lib/graphic/helper/roundRect.js","webpack:///./~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///./~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///./~/zrender/lib/graphic/mixin/RectText.js","webpack:///./~/zrender/lib/graphic/shape/Arc.js","webpack:///./~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///./~/zrender/lib/graphic/shape/Circle.js","webpack:///./~/zrender/lib/graphic/shape/Line.js","webpack:///./~/zrender/lib/graphic/shape/Polygon.js","webpack:///./~/zrender/lib/graphic/shape/Polyline.js","webpack:///./~/zrender/lib/graphic/shape/Rect.js","webpack:///./~/zrender/lib/graphic/shape/Ring.js","webpack:///./~/zrender/lib/graphic/shape/Sector.js","webpack:///./~/zrender/lib/mixin/Animatable.js","webpack:///./~/zrender/lib/mixin/Draggable.js","webpack:///./~/zrender/lib/mixin/Transformable.js","webpack:///./~/zrender/lib/tool/path.js","webpack:///./~/zrender/lib/tool/transformPath.js","webpack:///./~/zrender/lib/zrender.js"],"names":["webpackJsonp","module","exports","clone","source","result","typeStr","objToString","call","i","len","length","TYPED_ARRAY","constructor","from","BUILTIN_OBJECT","isDom","key","hasOwnProperty","merge","target","overwrite","isObject","targetProp","sourceProp","isArray","isBuildInObject","mergeAll","targetAndSources","extend","defaults","overlay","createCanvas","document","createElement","getContext","_ctx","util","indexOf","array","value","inherits","clazz","baseClazz","F","clazzPrototype","prototype","prop","superClass","mixin","isArrayLike","data","each","obj","cb","context","forEach","nativeForEach","map","nativeMap","push","reduce","memo","nativeReduce","filter","nativeFilter","find","bind","func","args","nativeSlice","arguments","apply","concat","curry","this","isFunction","isString","type","nodeType","ownerDocument","eqNaN","retrieve","values","slice","Function","assert","condition","message","Error","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","Array","noop","__webpack_require__","global","createRegisterEventWithLowercaseName","method","eventName","handler","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","a","b","prio","themeStorage","id","group","_dom","zr","_zr","zrender","init","renderer","devicePixelRatio","width","height","_throttledZrFlush","throttle","zrUtil","flush","_theme","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_api","ExtensionAPI","_coordSysMgr","CoordinateSystemManager","_messageCenter","_initEvents","resize","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","on","_onframe","doConvertPixel","methodName","finder","ecModel","_model","coordSysList","getCoordinateSystems","modelUtil","parseFinder","coordSys","__DEV__","console","warn","updateDirectly","ecIns","payload","mainType","subType","query","eachComponent","model","index","view","__viewId","__alive","doDispatchAction","silent","payloadType","actionWrap","actions","actionInfo","cptType","update","split","updateMethod","pop","parseClassType","IN_MAIN_PROCESS","payloads","batched","batch","item","eventObj","eventObjBatch","isHighDown","batchItem","action","event","main","sub","OPTION_UPDATED","updateMethods","prepareAndUpdate","trigger","flushPendingActions","pendingActions","shift","triggerUpdatedEvent","invokeUpdateMethod","api","component","componentModel","__model","updateZ","eachSeries","seriesModel","idx","chart","updateProgressiveAndBlend","updateHoverLayerStatus","prepareView","isComponent","viewList","viewMap","componentType","viewId","classType","Clazz","ComponentView","getClass","ChartView","add","__id","remove","dispose","splice","processData","process","stackSeriesData","stackedDataMap","series","stack","get","getData","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","excludesLayout","clearColorPalette","doRender","componentView","render","chartView","storage","elCount","traverse","el","isGroup","env","node","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","Math","floor","stopAnimation","blendMode","canvasSupported","setStyle","z","zlevel","enableConnect","updateConnectedChartsStatus","charts","status","STATUS_KEY","STATUS_PENDING","eventActionMap","actionType","eventType","connectedGroups","makeActionFromEvent","otherCharts","instances","otherChart","dispatchAction","window","GlobalModel","OptionManager","ComponentModel","SeriesModel","graphic","colorTool","PRIORITY_PROCESSOR_FILTER","PRIORITY_PROCESSOR_STATISTIC","PRIORITY_VISUAL_LAYOUT","PRIORITY_VISUAL_GLOBAL","PRIORITY_VISUAL_CHART","PRIORITY_VISUAL_COMPONENT","PRIORITY_VISUAL_BRUSH","HAS_GRADIENT_OR_PATTERN_BG","ACTION_REG","off","one","echartsProto","getDom","getZr","setOption","option","notMerge","lazyUpdate","optionManager","__lastOnlyGraphic","o","optionPreprocessorFuncs","setTheme","log","getModel","getOption","getWidth","getHeight","getRenderedCanvas","pixelRatio","backgroundColor","list","getDisplayList","painter","getDataURL","excludeComponents","excludesComponentViews","self","url","toDataURL","getConnectedDataURL","groupId","mathMin","min","mathMax","max","MAX_NUMBER","Infinity","left","top","right","bottom","canvasList","dpr","canvas","boundingRect","getBoundingClientRect","targetCanvas","img","Image","style","x","y","image","refreshImmediately","convertToPixel","convertFromPixel","containPixel","models","coordinateSystem","containPoint","getVisual","visualType","defaultMainType","dataIndexInside","indexOfRawIndex","dataIndex","getItemVisual","coordSysMgr","restoreData","create","isSingleCanvas","configLayer","clearColor","colorArr","parse","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","resetOption","_loadingFX","showLoading","name","cfg","hideLoading","loadingEffects","opt","browser","weChat","MOUSE_EVENT_NAMES","eveName","e","params","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","clear","idBase","Date","groupIdBase","DOM_ATTRIBUTE_KEY","echarts","version","dependencies","replace","nodeName","toUpperCase","clientWidth","clientHeight","setAttribute","connect","disConnect","getInstanceByDom","getAttribute","getInstanceById","registerTheme","registerPreprocessor","preprocessorFunc","registerProcessor","priority","processorFunc","isNaN","registerAction","test","registerCoordinateSystem","CoordinateSystem","register","registerLayout","layoutFunc","registerVisual","visualFunc","registerLoading","loadingFx","extendComponentModel","extendComponentView","extendSeriesModel","extendChartView","setCanvasCreator","creator","List","Model","number","format","matrix","vector","color","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","stroke","fill","hoverStyle","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","z2","doSingleLeaveHover","normalStl","removeHover","doEnterHover","child","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__hoverSilentOnTouch","zrByTouch","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","props","animatableModel","isAnimationEnabled","postfix","duration","getShallow","animationEasing","animationDelay","getAnimationDelayParams","animateTo","attr","pathTool","round","Path","Group","Text","Circle","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","extendShape","extendPath","pathData","extendFromString","makePath","rect","layout","path","createFromString","getBoundingRect","aspect","cx","cy","resizePath","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","shape","lineWidth","x1","x2","y1","y2","subPixelOptimizeRect","originX","originY","originWidth","originHeight","position","positiveOrNegative","doubledPosition","setHoverStyle","hoverSilentOnTouch","setText","textStyle","labelModel","labelPosition","labelOffset","labelColor","textStyleModel","textDistance","textFont","getFont","textPosition","textOffset","textFill","getTextColor","updateProps","initProps","getTransform","ancestor","mat","identity","mul","getLocalTransform","parent","vertex","transform","invert","transformDirection","direction","hBase","abs","vBase","groupTransition","g1","g2","getElMap","g","elMap","anid","getAnimatableProps","rotation","elMap1","oldEl","newProp","_trim","str","RADIAN_EPSILON","linearMap","val","domain","range","clamp","subDomain","subRange","parsePercent","percent","all","match","parseFloat","NaN","precision","toFixed","asc","arr","sort","getPrecision","count","getPrecisionSafe","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","isFinite","MAX_SAFE_INTEGER","remRadian","radian","pi2","PI","isRadianAroundZero","parseDate","ret","quantity","pow","nice","exp10","f","reformIntervals","littleThan","lg","interval","close","curr","currClose","isNumeric","v","rawScriptExports","compiledTemplate","scopeId","cssModules","esModule","scriptExports","default","options","staticRenderFns","_scopeId","computed","keys","ArrayCtor","Float32Array","out","copy","set","v1","v2","scaleAndAdd","sqrt","lenSquare","div","dot","scale","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Displayable","PathProxy","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","ctx","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","rebuildPath","restoreTransform","text","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirty","dirtyPath","refresh","__clipTarget","animateShape","loop","animate","attrKV","setShape","Sub","extendFrom","defaultShape","thisShape","numberUtil","textContain","formatUtil","addCommas","toCamelCase","upperCaseFirst","group1","charAt","normalizeCssArray","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","formatTpl","tpl","paramsList","encode","seriesLen","$vars","alias","k","s2d","formatTime","date","getFullYear","M","getMonth","getDate","h","getHours","getMinutes","getSeconds","capitalFirst","substr","truncateText","has","nubmerUtil","normalizeToArray","defaultEmphasis","subOpts","emphasisOpt","emphasis","normalOpt","normal","subOptName","LABEL_OPTIONS","getDataItemValue","dataItem","isDataItemOption","converDataValue","dimInfo","dimType","createDataFormatModel","dataFormatMixin","seriesName","rawValue","getRawValue","rawDataIndex","getRawIndex","getName","itemOpt","getRawDataItem","componentSubType","seriesType","getFormattedLabel","dimIndex","itemModel","getItemModel","formatter","formatTooltip","mappingToExists","exists","newCptOptions","exist","cptOption","isIdInner","makeIdAndName","mapResult","idMap","existCpt","keyInfo","idNum","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","seriesId","dataIndices","otherDataIndices","j","lenj","mapToArray","isData","mapA","mapB","queryDataIndex","indexOfName","parsedKey","queryType","queryParam","queryComponents","parentModel","doGet","pathArr","getParent","getParentMethod","clazzUtil","mergeOption","ignoreParent","parsePath","thisParentModel","isEmpty","Ctor","setReadOnly","properties","customizeGetParent","enableClassExtend","detect","ua","os","firefox","ie","edge","touchEventsSupported","pointerEventsSupported","navigator","userAgent","vec2","v2ApplyTransform","union","other","lt","rb","lb","rt","maxX","maxY","sx","sy","translate","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","checkClassType","superCall","superApply","TYPE_DELIMITER","IS_CONTAINER","MEMBER_PRIFIX","host","hasOwn","RootClass","mandatoryMethods","$constructor","proto","ExtendedClass","enableClassManagement","entity","makeContainer","container","registerClass","componentMainType","throwWhenNotFound","getClassesByMainType","hasClass","getAllClassMainTypes","types","hasSubTypes","registerWhenExtend","originalExtend","getDependencies","deps","arrayPush","componentUtil","componentIndex","defaultOption","dependentModels","uid","layoutMode","extraOpt","getUID","mergeDefaultAndTheme","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","optionUpdated","newCptOption","isInit","optList","Class","getReferringComponents","enableSubTypeDefaulter","enableTopologicalTravel","boxLayout","orient","gap","maxWidth","maxHeight","currentLineMaxSize","eachChild","nextX","nextY","nextChild","childAt","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","margin","containerWidth","containerHeight","getLayoutRect","verticalMargin","horizontalMargin","positionElement","hv","boundingMode","needLocalTransform","elPos","dx","dy","targetOption","newOption","names","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","ignoreSize","hasProp","hasValue","hNames","vNames","hResult","vResult","copyLayoutParams","getTextWidth","textWidthCache","textLines","l","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textAlign","textBaseline","textLineLen","lineHeight","adjustTextPositionOnRect","textRect","textHeight","halfHeight","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","join","charCode","charCodeAt","font","isAroundZero","EPSILON","isNotAroundZero","cubicAt","p0","p1","p2","p3","onet","cubicDerivativeAt","cubicRootAt","roots","c","A","B","C","n","t1","disc","K","t2","discSqrt","mathSqrt","Y1","Y2","mathPow","ONE_THIRD","T","theta","acos","ASqrt","tmp","cos","THREE_SQRT","sin","t3","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","x0","y0","x3","y3","prev","next","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","normalizeDimensions","dimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","getDimensionInfo","hostModel","transferProperties","_storage","originalStorage","dim","dimStore","UNDEFINED","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","indices","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","_extent","listProto","hasItemOption","getDimension","initData","nameList","dimValueGetter","size","dimensionInfoMap","idList","nameRepeatCount","DataCtor","dimName","stackedValue","getValues","getDataExtent","dimData","dimExtent","getSum","sum","rawIndex","mid","indexOfNearest","maxDistance","nearestIdx","minDist","Number","MAX_VALUE","diff","rawIdx","getId","dims","dimSize","filterSelf","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","prefix","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","clearItemLayouts","itemVisual","setItemVisual","setItemDataAndSeriesIndex","setItemGraphicEl","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","classUtil","colorPaletteMixin","legendDataProvider","visualColorAccessPath","getInitialData","label","fillDataTextStyle","newSeriesOption","getLinkedData","setData","getRawData","coordDimToDataDim","coordDim","dataDimToCoordDim","dataDim","getBaseAxis","multipleSeries","formatArrayValue","valStr","formattedValue","colorEl","animationEnabled","getColorFromPalette","scope","getAxisTooltipDataIndex","getTooltipPosition","eval","m1","m2","out0","out1","out2","out3","out4","out5","rotate","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","arrySlice","_$handlers","_h","isSilent","newList","argLen","triggerWithContext","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseInt","parseCssFloat","cssHueToRgb","p","colorStr","kCSSColorTable","op","ep","fname","alpha","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","vMin","vMax","delta","L","deltaR","deltaG","deltaB","level","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","_coordinateSystems","coordinateSystemCreators","coordinateSystems","creater","coordinateSystemCreator","OrdinalScale","IntervalScale","Scale","axisHelper","getScaleExtent","axis","axisDataLen","boundaryGap","span","scaleType","getMin","getMax","fixMin","fixMax","originalExtent","getExtent","setBlank","getNeedCrossZero","niceScaleExtent","extent","splitNumber","base","setExtent","niceExtent","minInterval","getInterval","intervalScale","origin","setInterval","createScaleByModel","axisType","getCategories","ifAxisCrossZero","getAxisLabelInterval","tickCoords","labels","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","step","tickCoord","getFormattedLabels","labelFormatter","getTicksLabels","ticks","getTicks","tick","getLabel","completeDimensions","defaultNames","extraPrefix","value0","retrieveValue","guessOrdinal","excludes","mathFloor","mathCeil","roundingErrorFix","_interval","start","end","thisExtent","unionExtent","niceTicks","_niceExtent","reverse","expandSize","scaleProto","unionExtentFromData","Triangle","moveTo","lineTo","closePath","Diamond","Pin","r","angle","asin","tanX","tanY","arc","cpLen","cpLen2","bezierCurveTo","Arrow","symbolCtors","line","roundRect","square","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","symbolType","beforeBrush","textVerticalAlign","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","symbolUtil","createSymbol","symbolPath","setColor","Chart","elSetState","state","childCount","toggleHighlight","dataIdx","highlight","downplay","removeAll","chartProto","config","debugMode","Element","_children","__storage","children","childOfName","_doAdd","addBefore","nextSibling","addToMap","addChildrenToStorage","delFromMap","delChildrenFromStorage","includeChildren","tmpRect","tmpMat","invisible","childRect","curve","bbox","CMD","Q","Z","min2","max2","mathCos","mathSin","mathAbs","hasTypedArray","_len","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","addData","exceedUnit","_needsDash","_dashedLineTo","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","startAngle","endAngle","anticlockwise","arcTo","radius","toStatic","lineDashSum","offset","appendPath","appendSize","appendPathData","cmd","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","xi","yi","fromLine","fromCubic","fromQuadratic","rx","ry","fromArc","ux","uy","dTheta","psi","fs","scaleX","scaleY","isEllipse","clientToLocal","calculate","defaultGetZrXY","layerX","offsetX","zrX","zrY","layerY","offsetY","clientX","clientY","normalizeEvent","touch","targetTouches","changedTouches","zrDelta","wheelDelta","detail","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","stop","preventDefault","stopPropagation","cancelBubble","returnValue","Dispatcher","barLayoutGrid","eachSeriesByType","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","createListFromArray","coordSysName","creators","registeredCoordSys","axesInfo","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","axesModels","xAxisModel","yAxisModel","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","singleAxis","singleAxisModel","singleAxisType","isCategory","single","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","gridModel","getRect","getItemStyle","xAxis","yAxis","grid","legendModels","findComponents","isSelected","random","subTypeDefaulters","registerSubTypeDefaulter","defaulter","determineSubType","componentTypeMain","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","topologicalTravel","targetNameList","callback","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","paletteScope","eachRawSeriesByType","dataAll","idxMap","isSeriesFiltered","filteredIdx","singleDataColor","defaultSymbolType","legendSymbol","symbolSize","symbol","itemSymbolType","itemSymbolSize","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","remaining","ts","minRun","force","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","afterBrush","rectContain","coord","animateStyle","useStyle","Gradient","addColorStop","__webpack_exports__","_toString","JSON","toNumber","expectsLowerCase","isPrimitive","cached","fn","cache","boundFn","_length","toArray","to","_from","isPlainObject","OBJECT_STRING","toObject","genStaticKeys","modules","staticKeys","looseEqual","isObjectA","isObjectB","looseIndexOf","once","called","isReserved","def","enumerable","defineProperty","writable","configurable","bailRE","segments","isNative","pushTarget","_target","Dep","targetStack","popTarget","protoAugment","src","__proto__","copyAugment","observe","asRootData","ob","__ob__","Observer","observerState","shouldConvert","isServerRendering","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","property","getOwnPropertyDescriptor","getter","setter","childOb","depend","dependArray","newVal","NODE_ENV","notify","del","mergeData","toVal","fromVal","mergeHook","parentVal","childVal","mergeAssets","checkComponents","components","lower","isBuiltInTag","isReservedTag","normalizeProps","camelize","normalizeDirectives","dirs","directives","mergeOptions","vm","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","Vue$3","resolveAsset","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","absent","isType","Boolean","hyphenate","undefined","getPropDefaultValue","prevShouldConvert","assertProp","$options","_props","getType","required","valid","expectedTypes","assertedType","assertType","expectedType","validator","handleError","err","info","errorHandler","inBrowser","error","createTextVNode","VNode","cloneVNode","vnode","cloned","tag","elm","componentOptions","ns","isStatic","isCloned","cloneVNodes","vnodes","createFnInvoker","fns","invoker","arguments$1","updateListeners","oldOn","remove$$1","cur","old","capture","mergeVNodeHook","hookKey","hook","wrappedHook","oldHook","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","nestedIndex","last","getFirstComponentChild","initEvents","_events","_hasHookEvent","listeners","_parentListeners","updateComponentListeners","once$$1","$once","$on","remove$1","$off","oldListeners","eventsMixin","Vue","hookRE","this$1","i$1","cbs","$emit","resolveSlots","slots","defaultSlot","functionalContext","slot","every","isWhitespace","isComment","resolveScopedSlots","initLifecycle","abstract","$parent","$children","$root","$refs","_watcher","_inactive","_directInactive","_isMounted","_isDestroyed","_isBeingDestroyed","lifecycleMixin","_update","hydrating","callHook","$el","prevVnode","_vnode","prevActiveInstance","activeInstance","__patch__","_parentElm","_refElm","__vue__","$vnode","$forceUpdate","$destroy","teardown","_watchers","_data","mountComponent","createEmptyVNode","template","updateComponent","performance","mark","_name","_uid","startTag","endTag","_render","measure","Watcher","updateChildComponent","parentVnode","renderChildren","hasChildren","_renderChildren","scopedSlots","$scopedSlots","emptyObject","_parentVnode","isSettingProps","propKeys","_propKeys","$slots","isInInactiveTree","activateChildComponent","direct","deactivateChildComponent","handlers","resetSchedulerState","queue","circular","waiting","flushing","flushSchedulerQueue","watcher","run","_maxUpdateCount","user","devtools","emit","queueWatcher","nextTick","seenObjects","_traverse","seen","isA","depId","proxy","sourceKey","sharedPropertyDefinition","initState","methods","initMethods","initComputed","watch","initWatch","propsOptions","isRoot","isReservedProp","watchers","_computedWatchers","userDef","computedWatcherOptions","defineComputed","createComputedGetter","evaluate","createWatcher","$watch","stateMixin","dataDef","propsDef","$set","$delete","expOrFn","immediate","createComponent","baseCtor","_base","cid","resolved","resolveAsyncComponent","resolveConstructorOptions","transformModel","extractProps","functional","createFunctionalComponent","nativeOn","mergeHooks","_context","createComponentInstanceForVnode","parentElm","refElm","vnodeComponentOptions","_isComponent","_componentTag","inlineTemplate","factory","requested","pendingCallbacks","sync","resolve","reject","reason","then","attrs","domProps","altKey","keyInLowerCase","formatComponentName","checkProp","hash","preserve","hooksToMerge","fromParent","ours","componentVNodeHooks","mergeHook$1","two","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","SIMPLE_NORMALIZE","getTagNamespace","parsePlatformTagName","applyNS","renderList","renderSlot","fallback","bindObject","scopedSlotFn","slotNodes","_rendered","resolveFilter","checkKeyCodes","eventKeyCode","builtInAlias","keyCodes","bindObjectProps","asProp","mustUseProp","renderStatic","isInFor","tree","_staticTrees","_renderProxy","markStatic","markOnce","isOnce","markStaticNode","initRender","renderContext","_c","$createElement","renderMixin","$nextTick","ref","renderError","_o","_n","_s","_l","_q","_i","_m","_f","_k","_b","_v","_e","_u","initProvide","provide","_provided","initInjections","inject","hasSymbol","Reflect","ownKeys","provideKey","initMixin","_init","initInternalComponent","initProxy","_self","$mount","super","superOptions","modifiedOptions","resolveModifiedOptions","extendOptions","modified","latest","sealed","sealedOptions","dedupe","initUse","use","plugin","installed","unshift","install","initMixin$1","initExtend","Super","SuperId","cachedCtors","_Ctor","initProps$1","initComputed$1","_assetTypes","Comp","initAssetRegisters","definition","getComponentName","matches","pattern","RegExp","pruneCache","cachedNode","pruneCacheEntry","componentInstance","initGlobalAPI","configDef","defineReactive","delete","builtInComponents","genClassForVnode","parentNode","childNode","mergeClassData","genClassFromData","staticClass","class","dynamicClass","stringifyClass","stringified","isSVG","isUnknownElement","unknownElementCache","HTMLUnknownElement","HTMLElement","selected","querySelector","createElement$1","tagName","multiple","createElementNS","namespace","namespaceMap","createTextNode","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","setTextContent","textContent","registerRef","isRemoval","refs","refInFor","isUndef","isDef","sameVnode","vnode1","vnode2","createKeyToOldIdx","beginIdx","endIdx","createPatchFunction","backend","emptyNodeAt","nodeOps","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","nested","isRootInsert","pre","inPre","ignoredElements","setScope","createChildren","invokeCreateHooks","insert","isReactivated","keepAlive","initComponent","reactivateComponent","pendingInsert","isPatchable","innerNode","transition","activate","emptyNode","addVnodes","startIdx","invokeDestroyHook","destroy","removeVnodes","ch","removeAndInvokeRemoveHook","rm","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","oldVnode","hasData","prepatch","postpatch","invokeInsertHook","initial","hydrate","assertNodeMatch","hasChildNodes","childrenMatch","firstChild","bailed","childNodes","isRenderedModule","hooks","isInitialPatch","isRealElement","hasAttribute","removeAttribute","oldElm","parentElm$1","_leaveCb","updateDirectives","oldDir","dir","isCreate","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","callHook$1","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","updateAttrs","oldAttrs","setAttr","isIE9","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","isBooleanAttr","isFalsyAttrValue","setAttributeNS","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","parseFilters","exp","pushFilter","filters","lastFilterIndex","trim","expression","inSingle","inDouble","inTemplateString","inRegex","curly","paren","validDivisionCharRE","wrapFilter","baseWarn","msg","pluckModuleFunction","_","addProp","addAttr","addDirective","arg","addHandler","important","events","native","nativeEvents","newHandler","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","attrsMap","attrsList","genComponentModel","baseValueExpression","valueExpression","assignment","genAssignmentCode","modelRs","parseModel","index$1","expressionPos","expressionEndPos","lastIndexOf","eof","chr","isStringStart","parseString","parseBracket","substring","inBracket","stringQuote","_warn","warn$1","dynamicType","genSelect","genCheckboxModel","genRadioModel","genDefaultModel","valueBinding","trueValueBinding","falseValueBinding","CHECKBOX_RADIO_TOKEN","selectedVal","code","lazy","needCompositionGuard","RANGE_TOKEN","normalizeEvents","isIE","isChrome","add$1","oldHandler","target$1","ev","remove$2","updateDOMListeners","updateDOMProps","oldProps","_value","strCur","shouldUpdateValue","checkVal","composing","isDirty","isInputChanged","activeElement","_vModifiers","normalizeStyleData","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","oldStyle","newStyle","setProp","addClass","classList","removeClass","tar","resolveTransition","def$$1","css","autoCssTransition","nextFrame","raf","addTransitionClass","removeTransitionClass","whenTransitionEnds","getTransitionInfo","timeout","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","onEnd","setTimeout","styles","getComputedStyle","transitionDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","enter","toggleDisplay","cancelled","_enterCb","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","transitionNode","isAppear","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","checkDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","explicitLeaveDuration","afterLeave","leaveCancelled","delayLeave","invokerFns","_enter","setSelected","binding","isMultiple","getValue","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","comp","key$1","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","applyTranslation","oldPos","pos","moved","WebkitTransform","transitionDuration","shouldDecode","content","encoded","innerHTML","decode","html","decoder","decodeAttr","shouldDecodeNewlines","re","encodedAttrWithNewLines","encodedAttr","decodingMap","parseHTML","advance","parseStartTag","startTagOpen","startTagClose","attribute","unarySlash","handleStartTag","expectHTML","lastTag","isNonPhrasingTag","parseEndTag","canBeLeftOpenTag","unary","isUnaryTag$$1","IS_REGEX_CAPTURING_BROKEN","lowerCasedTag","lowerCasedTagName","isUnaryTag","no","isPlainTextElement","stackedTag","reStackedTag","reCache","endTagLength","rest","chars","textEnd","comment","commentEnd","conditionalComment","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","rest$1","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokens","lastIndex","exec","warnOnce","warned","warn$2","endPre","element","inVPre","platformIsPreTag","platformGetTagNamespace","platformMustUseProp","isPreTag","preTransforms","transforms","postTransforms","root","currentParent","preserveWhitespace","checkRootConstraints","guardIESVGBug","makeAttrsMap","isForbiddenTag","forbidden","processPre","processRawAttrs","processFor","processIf","processOnce","processKey","processRef","processSlot","processComponent","processAttrs","if","elseif","else","addIfCondition","block","processIfConditions","slotScope","slotTarget","i$2","lastNode","decodeHTMLCached","checkInFor","inMatch","forAliasRE","for","iteratorMatch","forIteratorRE","iterator1","iterator2","findPrevElement","ifConditions","slotName","isProp","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","camel","onRE","argMatch","argRE","checkForAliasModel","ieNSBug","ieNSPrefix","_el","optimize","isStaticKey","genStaticKeysCached","isPlatformReservedTag","markStatic$1","markStaticRoots","genStaticKeys$1","static","staticInFor","staticRoot","walkThroughConditionsBlocks","conditionBlocks","isDirectChildOfTemplateFor","genHandlers","genHandler","isMethodPath","simplePathRE","isFunctionExpression","fnExpRE","genModifierCode","modifierCode","genKeyFilter","genFilterCode","keyVal","bind$1","wrapData","generate","ast","prevStaticRenderFns","currentStaticRenderFns","prevOnceCount","onceCount","currentOptions","warn$3","transforms$1","dataGenFns","platformDirectives$1","isPlatformReservedTag$1","genElement","staticProcessed","genStatic","onceProcessed","genOnce","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData","genChildren","genIfConditions","conditions","genTernaryExp","maybeComponent","genDirectives","genProps","genScopedSlots","genInlineTemplate","needRuntime","hasRuntime","gen","baseDirectives","inlineRenderFns","genScopedSlot","checkSkip","el$1","getNormalizationType","genNode","needsNormalization","some","genText","transformSpecialNewlines","bind$$1","componentName","detectErrors","errors","checkNode","checkFor","checkEvent","checkExpression","keywordMatch","stripStringRE","unaryOperatorsRE","checkIdentifier","ident","identRE","prohibitedKeywordRE","baseCompile","makeFunction","createCompiler","baseOptions","compile","finalOptions","tips","tip$$1","compiled","compileToFunctions","functionCompileCache","tip","fnGenErrors","transformNode","classBinding","genData$1","transformNode$1","styleBinding","genData$2","getOuterHTML","outerHTML","cloneNode","_isServer","_Set","camelizeRE","hyphenateRE","optionMergeStrategies","productionTip","_lifecycleHooks","freeze","hasProto","UA","isEdge","isAndroid","isIOS","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","nextTickHandler","pending","copies","callbacks","timerFunc","Promise","logError","catch","MutationObserver","counter","observer","textNode","characterData","_resolve","Set","hasConsole","classifyRE","classify","formatLocation","includeFile","file","__file","uid$1","subs","addSub","removeSub","addDep","arrayMethods","observeArray","arrayKeys","getOwnPropertyNames","walk","items","instanceData","defaultData","allowedGlobals","warnNonPresent","hasProxy","Proxy","isBuiltInModifier","hasHandler","isAllowed","getHandler","_withStripped","perf","clearMarks","clearMeasures","raw","prototypeAccessors","defineProperties","uid$2","deep","active","newDeps","depIds","newDepIds","cleanupDeps","mountedNode","patternTypes","KeepAlive","include","exclude","created","destroyed","testEl","acceptValue","svg","math","isHTMLTag","baseModules","klass","cssText","listDelimiter","propertyDelimiter","cssVarRE","importantRE","setProperty","prefixes","upper","prefixed","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","requestAnimationFrame","platformModules","patch","vmodel","model$1","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","beforeUpdate","updated","hasMove","body","offsetHeight","propertyName","_hasMove","platformComponents","singleAttrIdentifier","singleAttrAssign","singleAttrValues","ncname","qnameCapture","&lt;","&gt;","&quot;","&amp;","&#10;","regexEscapeRE","open","esc","tab","space","up","down","genGuard","prevent","ctrl","alt","meta","middle","cloak","klass$1","style$1","modules$1","directives$1","ref$1","idToTemplate","mount","documentElement","Buffer","cssWithMappingToString","useSourceMap","cssMapping","sourceMapping","toComment","sourceURLs","sources","sourceRoot","sourceMap","mediaQuery","alreadyImportedModules","getSymbolSize","getScale","seriesScope","updateData","driftSymbol","drift","symbolProto","_createSymbol","_symbolType","stopSymbolAnimation","toLastFrame","getSymbolPath","setZ","setDraggable","_updateCommon","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","hoverLabelModel","hoverAnimation","elStyle","opacity","valueDim","onEmphasis","ratio","onNormal","fadeOut","SymbolDraw","symbolCtor","_symbolCtor","symbolNeedsDraw","isIgnore","point","symbolDrawProto","SymbolCtor","newIdx","symbolEl","oldIdx","execute","enableAnimation","makeAxisEventDataBase","axisModel","innerTextLayout","textRotation","verticalAlign","rotationDiff","endTextLayout","textRotate","inverse","onLeft","tooltipOpt","AxisBuilder","nameDirection","tickDirection","labelDirection","dumbGroup","updateTransform","_transform","_dumbGroup","hasBuilder","builders","getGroup","axisLine","pt1","pt2","lineCap","getLineStyle","axisTick","isBlank","tickModel","lineStyleModel","tickLen","tickInterval","labelInterval","ticksCoords","getTicksCoords","ifIgnoreOnTick","axisLabel","isTwoLabelOverlapped","current","firstRect","nextRect","axisLabelShow","labelMargin","labelRotation","labelLayout","categoryData","textEls","triggerEvent","tickVal","itemTextStyleModel","textColor","dataToCoord","labelBeforeFormat","textEl","targetType","decomposeTransform","firstLabel","lastLabel","axisName","nameLocation","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","truncatedText","formatterParams","__fullText","__truncatedText","tooltip","rawTick","fixExtentWithBands","nTick","normalizedExtent","Axis","onBand","containData","coordToData","alignWithLabel","bands","getBands","coords","getLabelsCoords","getBandWidth","axisExtent","_isBlank","nameRotate","nameTruncate","nameTextStyle","nameGap","onZero","lineStyle","inside","fontSize","splitLine","splitArea","areaStyle","categoryAxis","valueAxis","timeAxis","logAxis","logBase","rangeStart","rangeEnd","getCoordSysModel","setRange","resetRange","getAxisType","axisDim","axisModelCreator","AxisModel","gridIndex","gridId","extraOption","isAxisUsedInTheGrid","getLabelUnionRect","labelCount","isLabelIgnored","singleRect","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","updateAxisTransfrom","coordBase","axisExtentSum","toGlobalCoord","toLocalCoord","findAxesModels","axesTypes","isCartesian2D","Cartesian2D","Axis2D","gridProto","ifAxisCanNotOnZero","otherAxisDim","axes","axesMap","_updateScale","adjustAxes","axesList","isHorizontal","gridRect","getBoxLayoutParams","labelUnionRect","getAxis","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","coordList","_findConvertTarget","cartesian","dataToPoint","pointToData","coordsList","createAxisCreator","axisPosition","axisPositionUsed","axesCount","addAxis","grids","colorIdx","colorNameMap","colorPalette","addStylesToDom","domStyle","stylesInDom","parts","addStyle","listToStyles","newStyles","media","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","createStyleElement","attachTagAttrs","createLinkElement","linkElement","rel","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","styleSheet","replaceText","cssNode","autoFixUrls","convertToAbsoluteUrls","fixUrls","unescape","encodeURIComponent","blob","oldSrc","memoize","isOldIE","getElementsByTagName","DEBUG","mayRemove","textStore","replacement","guid","Transformable","Animatable","clipPath","afterUpdate","hide","setClipPath","addSelfToZr","removeClipPath","removeSelfFromZr","animators","addAnimator","removeAnimator","defaultGetter","defaultSetter","interpolateNumber","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","arraySlice","isArraySame","catmullRomInterpolateArray","catmullRomInterpolate","v0","cloneValue","rgba2String","createTrackClip","animator","easing","oneTrackDone","keyframes","_getter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","lastValue","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","delay","_delay","ondestroy","Animator","_tracks","_clipCount","_doneList","_onframeList","_clipList","when","tracks","during","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","forwardToLast","clipList","removeClip","done","getClips","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","PI2","normalizeRadian","idStart","ZImage","LRU","globalImageCache","_image","cachedImgObj","onload","put","sWidth","sHeight","drawImage","repeat","_canvasPattern","createPattern","createLinearGradient","createRadialGradient","STYLE_COMMON_PROPS","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","canvasGradient","styleProto","smoothSpline","smoothBezier","points","smooth","controlPoints","smoothConstraint","cp1","cp2","WorkerGlobalScope","Prism","lang","uniqueId","Token","objId","languages","redef","before","grammar","newToken","token","DFS","visited","plugins","highlightAll","async","selector","elements","querySelectorAll","highlightElement","language","className","Worker","worker","filename","onmessage","evt","highlightedCode","postMessage","immediateClose","tokenize","strarr","tokenloop","patterns","lookbehind","greedy","lookbehindLength","flags","delNum","after","wrapped","matchedStr","classes","attributes","aliases","script","currentScript","readyState","markup","prolog","cdata","punctuation","attr-value","attr-name","xml","mathml","atrule","rule","string","function","style-attr","clike","class-name","keyword","boolean","operator","javascript","regex","template-string","interpolation","interpolation-punctuation","js","fileHighlight","Extensions","py","ps1","psm1","sh","bat","tex","extension","xhr","XMLHttpRequest","onreadystatechange","responseText","statusText","send","placeHoldersCount","b64","byteLength","toByteArray","placeHolders","Arr","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","output","fromByteArray","extraBytes","maxChunkLength","Uint8Array","typedArraySupport","foo","subarray","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","encodingOrOffset","allocUnsafe","TypeError","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","alloc","encoding","checked","isEncoding","actual","write","fromArrayLike","byteOffset","isBuffer","buffer","isnan","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","arrayIndexOf","read","buf","indexSize","readUInt16BE","arrLength","valLength","foundIndex","found","hexWrite","strLen","parsed","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","bytes","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","INVALID_BASE64_RE","units","leadSurrogate","byteArray","dst","INSPECT_MAX_BYTES","poolSize","_augment","species","allocUnsafeSlow","_isBuffer","swap16","swap32","swap64","equals","inspect","thisStart","thisEnd","thisCopy","targetCopy","includes","toJSON","_arr","newBuf","sliceLen","readUIntLE","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","chartInstance","echartsAPIList","actionInfos","brushSelector","createRect","animationModel","rectShape","animateProperty","animateTarget","removeRect","getRectItemLayout","fixedLineWidth","getLineWidth","signX","signY","itemStyleModel","getBarItemStyle","labelPositionOutside","helper","setLabel","rawLayout","BAR_BORDER_WIDTH_QUERY","BarView","_renderOnCartesian","baseAxis","newIndex","oldIndex","getMarkerPosition","pt","legendHoverLink","barMinHeight","getBorderLineDash","labelText","FunnelSeries","_defaultLabelLine","labelLine","labelLineNormalOpt","labelLineEmphasisOpt","minSize","maxSize","funnelAlign","borderColor","borderWidth","FunnelPiece","hoverIgnore","normalIgnore","polygon","getLabelStyle","isLabelInside","funnelPieceProto","opacityAccessPath","firstCreate","visualColor","lineJoin","_updateLabel","linePoints","labelHoverModel","labelLineModel","labelLineHoverModel","Funnel","funnelPiece","piePiece","getViewRect","getSortedIndices","valueArr","isAscending","textX","textY","labelLineLen","viewRect","sizeExtent","itemHeight","getLinePoints","offY","itemWidth","nextIdx","LargeSymbolDraw","_symbolEl","LargeSymbolPath","sizes","symbolProxy","symbolProxyShape","findDataIndex","largeSymbolProto","clipOverflow","smoothMonotone","showSymbol","showAllSymbol","connectNulls","sampling","hoverLayerThreshold","isPointsSame","points1","points2","getSmooth","getAxisExtentWithGap","getGlobalExtent","halfBandWidth","sign","getStackedOnPoints","getOtherAxis","valueStart","baseDataOffset","stackedOnSameSign","stackedData","createGridClipShape","hasAnimation","xExtent","yExtent","createPolarClipShape","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","angleExtent","RADIAN","r0","clockwise","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","stepPt","stepPt2","getVisualGradient","visualMetaList","visualMeta","stops","stopLen","outerColors","tinyExtent","minCoord","maxCoord","coordSpan","gradient","lineAnimationDiff","polyHelper","lineGroup","symbolDraw","_symbolDraw","_lineGroup","areaStyleModel","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","_polygon","isAreaChart","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","_stackedOnPoints","_points","_updateAnimation","_newPolyline","stackedOnSmooth","getAreaStyle","getAxesByScale","stackedOnCurrent","stackedOnNext","__points","updatedDataInfo","diffStatus","idx1","ptIdx","getStackedOnPoint","diffData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","diffItem","pointAdded","currentPt","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","isPointNull","drawSegment","segLen","allLen","smoothMin","smoothMax","prevIdx","v2Copy","cp0","nextP","ratioNextSeg","prevP","lenPrevSeg","lenNextSeg","vec2Min","vec2Max","getBoundingBox","ptMin","ptMax","stackedOnBBox","dataSelectableMixin","PieSeries","updateSelectedMap","center","minAngle","selectedOffset","avoidLabelOverlap","stillShowZeroSum","animationType","updateDataSelected","toggleItemSelected","midAngle","PiePiece","sector","piePieceProto","sectorShape","Pie","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","selectedMode","_createClipPath","itemLayout","adjustSingleSide","viewWidth","viewHeight","shiftDown","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","labelLineLen2","labelRotate","unitRadian","roseType","restAngle","valueSumLargerThanMinAngle","currentAngle","RadarSeries","indicatorAxes","getIndicatorAxes","radarIndex","normalizeSymbolSize","updateSymbols","oldPoints","newPoints","symbolGroup","__dimIdx","getInitialPoints","itemGroup","hoverPolygonIgnore","polygonIgnore","hoverAreaStyleModel","itemHoverStyle","defaultText","polarOptArr","polarNotRadar","polarOpt","indicator","radar","seriesOpt","polarIndex","pointsConverter","large","largeThreshold","_normalSymbolDraw","_largeSymbolDraw","largeSymbolDraw","normalSymbolDraw","layoutAxis","getZero","theAxis","rawAxisPosition","rectBound","axisOffset","posMap","dirMap","getLabelInterval","axisBuilderAttrs","selfBuilderAttrs","AxisView","oldAxisGroup","_axisGroup","axisBuilder","_splitLine","splitLineModel","lineColors","lineInterval","lineCount","colorIndex","_splitArea","splitAreaModel","areaColors","prevX","prevY","areaInterval","positionGroup","addBackground","padding","targetList","_selectTargetMap","targetMap","select","unSelect","toggleSelected","LegendModel","_updateData","legendData","hasSelected","availableNames","getSeries","_availableNames","align","itemGap","inactiveColor","dispatchSelectAction","dispatchHighlightAction","dataName","dispatchDownplayAction","symbolCreator","listComponentHelper","_symbolTypeStore","legendModel","selectMode","itemAlign","legendDrawedMap","getSeriesByName","legendSymbolType","_createItem","eachRawSeries","itemIcon","tooltipModel","legendGlobalTooltipModel","hitRect","legendIndex","legendSelectActionHandler","selectedMap","isToggleSelect","isItemSelected","filterSeries","radarModel","_buildAxes","_buildSplitLineAndArea","axisBuilders","indicatorAxis","getColorIndex","areaOrLine","areaOrLineColorList","showSplitLine","showSplitArea","splitLineColors","splitAreaColors","splitLines","splitAreas","ticksRadius","realSplitNumber","axesTicksPoints","coordToPoint","prevPoints","subtext","subtarget","fontWeight","subtextStyle","titleModel","subtextStyleModel","subText","subTextEl","link","sublink","groupRect","layoutOption","layoutRect","alignStyle","assembleTransition","transitionCurve","transitionText","vendors","vendorPrefix","assembleFont","assembleCssText","zrColor","borderName","camelCase","TooltipContent","_x","_y","_container","_show","_hideTimeout","onmouseenter","enterable","clearTimeout","_inContent","onmousemove","eventUtil","dispatch","onmouseleave","hideLater","_hideDelay","stl","currentStyle","defaultView","setContent","isShow","showContent","triggerOn","alwaysShowContent","confine","showDelay","hideDelay","borderRadius","extraCssText","axisPointer","animationDurationUpdate","animationEasingUpdate","crossStyle","shadowStyle","dataEqual","makeLineShape","makeRectShape","makeSectorShape","refixTooltipPosition","confineTooltipPosition","calcTooltipPosition","domWidth","domHeight","rectWidth","rectHeight","updatePosition","positionExpr","ifSeriesSupportAxisTrigger","_axisPointers","tooltipContent","_tooltipContent","_tooltipModel","_ecModel","_lastHover","_alwaysShowContent","_seriesGroupByAxis","_prepareAxisTriggerData","crossText","_crossText","_lastX","_lastY","_refreshUpdateTimeout","manuallyShowTip","_tryShow","_mousemove","_hide","_showTimeout","seriesHaveDataOnIndex","_series","isTriggerAxis","findHover","manuallyHideTip","seriesGroupByAxis","globalTrigger","_showAxisTooltip","_ticket","_hideAxisPointer","_resetLastHover","_showItemTooltipContent","subTooltipModel","defaultHtml","asyncTicket","_showTooltipContent","axisPointerModel","axisPointerType","_showAxisPointer","allNotShow","seriesCoordSysSameAxis","allCoordSys","contentNotChange","lastHover","valIndex","_showSinglePointer","_showPolarPointer","_showCartesianPointer","_dispatchAndShowSeriesTooltipContent","moveGridLine","otherExtent","targetShape","pointerEl","_getPointerElement","moveAnimation","moveGridShadow","bandWidth","_updateCrossText","otherAxis","moveSingleLine","movePolarLine","mouseCoord","pointToCoord","movePolarShadow","crossStyleModel","pointerModel","initShape","axisPointers","pointerType","styleModel","isShadow","elementType","seriesList","rootTooltipModel","baseDimIndex","sampleSeriesIndex","payloadBatch","firstDataIndex","firstLine","seriesTooltipModel","ticket","cbTicket","axisDefault","AXIS_TYPES","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","axisLabelInterval","coordExtent","_labelInterval","dimAxisMapper","_axes","Cartesian","_dimList","getAxes","_dataCoordConvert","input","dimList","axisX","axisY","dataToPoints","containLabel","IndicatorAxis","Radar","_indicatorAxes","getIndicatorModels","indicatorModel","indicatorIndex","closestAxis","atan2","minRadianDiff","closestAxisIdx","coodToData","viewSize","increaseInterval","radarSeries","getComponent","rawExtent","fixedMin","fixedMax","nicedSplitNumber","halfSplitNumber","radarList","defaultsShow","valueAxisDefault","axisModelCommonMixin","RadarModel","showName","nameFormatter","indicatorModels","indicatorOpt","indName","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_remove","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","getSeriesStackId","getAxisKey","calBarWidthAndOffset","barSeries","columnsMap","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","stacks","stackId","barWidth","barMaxWidth","barGap","barCategoryGap","barGapPercent","autoWidth","column","lastColumn","widthSum","barWidthAndOffset","getSeriesByType","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxisStart","lastCoord","lastCoordOrigin","maskColor","mask","labelRect","mergeTheme","themeItem","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","existComponent","createSeriesIndices","seriesModels","filterBySubType","cpt","assertSeriesInitialized","_optionManager","optionChanged","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","resultItem","ComponentModelClass","newCptTypes","componentOption","cpts","isIdArray","isNameArray","getQueryCond","q","indexAttr","idAttr","nameAttr","doFilter","queryCond","queryResult","oneSeries","rawSeriesIndex","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","platform","fontFamily","fontStyle","animationDuration","animationThreshold","progressiveThreshold","lineType","getLineDash","dotSize","dashSize","gTextStyleModel","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","clockWise","pointerColor","dataRange","visualMap","compatItemStyle","itemStyleOpt","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","samplers","average","nearest","indexSampler","sampler","fixRoundingError","originalVal","intervalScaleProto","mathLog","LogScale","_originalScale","originalScale","powVal","__fixMin","__fixMax","approxTickNum","rank","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_DAY","bisect","TimeScale","stepLvl","_stepLvl","approxInterval","scaleLevelsLen","scaleLevels","yearSpan","lib","ORIGIN_METHOD","RATE","THROTTLE_TYPE","debounce","lastExec","getTime","timer","currCall","lastCall","createOrUpdate","fnAttr","throttleType","originFn","lastThrottleType","Component","componentProto","encodeColor","colorAccessPath","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","LN2","location","baseUrl","protocol","currentDir","pathname","fullMatch","origUrl","unquotedOrigUrl","$1","newUrl","resolveProps","route","resolveQuery","extraQuery","parsedQuery","parseQuery","stringifyQuery","val2","createRoute","record","redirectedFrom","fullPath","getFullPath","formatMatch","isSameRoute","START","trailingSlashRE","isObjectEqual","aKeys","bKeys","isIncludedRoute","queryIncludes","guardEvent","metaKey","ctrlKey","shiftKey","defaultPrevented","button","findAnchor","_Vue","_router","_route","beforeCreate","router","history","View","Link","beforeRouteEnter","beforeRouteLeave","resolvePath","relative","append","segment","hashIndex","queryIndex","cleanPath","createRouteMap","routes","oldPathMap","oldNameMap","pathMap","nameMap","addRouteRecord","matchAs","normalizePath","redirect","aliasRoute","defaultDelimiter","delimiter","PATH_REGEXP","escaped","modifier","asterisk","partial","optional","escapeGroup","escapeString","tokensToFunction","encodeURIComponentPretty","encodeURI","encodeAsterisk","pretty","isarray","attachKeys","sensitive","regexpToRegexp","groups","arrayToRegexp","pathToRegexp","stringToRegexp","tokensToRegExp","strict","endsWithDelimiter","getRouteRegex","regexp","hit","regexpCache","fillParams","routeMsg","regexpCompileCache","normalizeLocation","_normalized","assign","rawPath","parsedPath","basePath","createMatcher","addRoutes","currentRoute","paramNames","_createRoute","matchRoute","originalRedirect","targetRecord","resolveRecordPath","aliasedPath","aliasedMatch","aliasedRecord","decodeURIComponent","setupScroll","saveScrollPosition","setStateKey","handleScroll","isPop","app","behavior","scrollBehavior","getScrollPosition","shouldScroll","getElementPosition","isValidPosition","normalizePosition","scrollTo","getStateKey","positionStore","pageXOffset","pageYOffset","docEl","docRect","elRect","isNumber","genKey","Time","now","_key","pushState","replaceState","runQueue","normalizeBase","baseEl","resolveQueue","activated","deactivated","extractGuards","records","guards","flatMapComponents","instance","guard","extractGuard","flatten","extractLeaveGuards","bindGuard","extractUpdateHooks","extractEnterGuards","isValid","bindEnterGuard","poll","resolveAsyncComponents","resolvedDef","getLocation","search","checkFallback","ensureSlash","getHash","replaceHash","pushHash","createHref","routerView","$route","_routerViewCache","depth","inactive","routerViewDepth","encodeReserveRE","encodeReserveReplacer","commaRE","toTypes","eventTypes","exact","$router","linkActiveClass","compareTarget","click","parse_1","compile_1","tokensToFunction_1","tokensToRegExp_1","supportsPushState","History","ready","readyCbs","listen","onReady","transitionTo","onComplete","onAbort","confirmTransition","updateRoute","ensureURL","abort","beforeHooks","iterator","postEnterCbs","afterHooks","HTML5History","History$$1","expectScroll","go","getCurrentLocation","HashHistory","setupListeners","AbstractHistory","targetIndex","VueRouter","apps","matcher","setupHashListener","beforeEach","afterEach","back","forward","getMatchedComponents","normalizedTo","makeEventPacket","eveType","gestureEvent","pinchX","pinchY","pinchScale","EmptyProxy","isHover","displayable","Draggable","handlerNames","Handler","painterRoot","_hovered","_lastTouchMoment","mousemove","hovered","lastHovered","setCursor","dispatchToElement","mouseout","innerDom","toElement","relatedTarget","eventArgs","setCursorStyle","cursorStyle","targetEl","eventHandler","eventPacket","eachOtherLayer","layer","_downel","_upel","returnFalse","createDom","newDom","newDomStyle","Layer","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","initContext","createBackBuffer","clearAll","haveMotionBLur","clearRect","clearColorGradientOrPattern","__canvasGradient","save","fillRect","restore","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","isClipPathChanged","clipPaths","prevClipPaths","doClip","createRoot","domRoot","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","_opts","_singleCanvas","rootStyle","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","_domRoot","_getSize","pathToImage","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","getViewportRoot","paintAll","_paintList","refreshHover","_startProgessive","__hoverMir","elMirror","__from","hoverElements","clearHover","hoverLayer","displayableSortFunc","getLayer","originalEl","invTransform","_doPaintEl","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","clearLayer","imageLayer","displayList","whIdx","wh","cwh","plt","prb","_pathToImage","pathTransform","ImageShape","imgShape","me","shapeCompareFunc","Storage","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","_updateAndAddDisplayable","userSetClipPath","currentClipPath","parentClipPath","addRoot","delRoot","elId","_renderList","Animation","stage","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","deferredEvents","deferredClips","_needsRemove","fire","_startLoop","pause","resume","_life","_initialized","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","restart","remainder","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","_a","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","windingQuadratic","y_","x_","windingArc","containPath","isStroke","windingLine","cubic","quadratic","pointPair","GestureMgr","_track","recognize","_doTrack","_recognize","touches","trackItem","recognizers","gestureInfo","pinch","track","pinchEnd","pinchPre","pinchCenter","LinkedList","tail","linkedListProto","entry","Entry","insertEntry","_list","_map","_maxSize","LRUProto","leastUsedEntry","extremity","fromPoints","xDim","yDim","tx","ty","eventNameFix","processGesture","gestureMgr","_gestureMgr","setTouchTimer","_touching","_touchTimer","isPointerFromTouch","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","eventTool","TOUCH_CLICK_DELAY","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","handlerDomProxyProto","paths","_updatePathDirty","globalCoord","fillText","strokeText","r1","r2","r3","r4","total","v2Min","v2Max","v2Scale","v2Distance","v2Add","isLoop","constraint","prevPoint","nextPoint","cps","d0","interpolate","segs","w2","w3","maxValue","baseline","shadowColor","textShadowColor","unitX","unitY","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","pointAt","tangentAt","roundRectHelper","shadowTemp","animatingShape","pathSplitted","_animateToShallow","objShallow","propertyCount","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","dropTarget","lastDropTarget","_dropTarget","mIdentity","transformableProto","parentHasTransform","tmpTransform","transformCoordToGlobal","processArc","fa","psiDeg","xp","yp","lambda","cxp","cyp","vAngle","u","vRatio","createPathProxyFromString","cs","cc","prevCmd","cpx","cpy","ctlPtx","ctlPty","createPathOptions","pathProxy","transformPath","vMag","pathEls","pathList","pathEl","pathBundle","nPoint","mathAtan2","delInstance","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","rendererType","vml","handerProxy","_needsRefresh","oldDelFromMap","oldAddToMap","zLevel","_needsRefreshHover","refreshHoverImmediately","clearAnimation"],"mappings":"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","file":"js/vendor.1d4dedcc.js","sourcesContent":["webpackJsonp([0,2],[\n/* 0 */\n/***/ (function(module, exports) {\n\n/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = __webpack_require__(11);\n\n    var GlobalModel = __webpack_require__(169);\n    var ExtensionAPI = __webpack_require__(112);\n    var CoordinateSystemManager = __webpack_require__(26);\n    var OptionManager = __webpack_require__(170);\n\n    var ComponentModel = __webpack_require__(16);\n    var SeriesModel = __webpack_require__(21);\n\n    var ComponentView = __webpack_require__(184);\n    var ChartView = __webpack_require__(33);\n    var graphic = __webpack_require__(2);\n    var modelUtil = __webpack_require__(9);\n    var throttle = __webpack_require__(183);\n\n    var zrender = __webpack_require__(261);\n    var zrUtil = __webpack_require__(0);\n    var colorTool = __webpack_require__(25);\n    var Eventful = __webpack_require__(24);\n    var timsort = __webpack_require__(45);\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts (dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        // FIXME\n        // ugly\n        this.__lastOnlyGraphic = !!(option && option.graphic);\n        zrUtil.each(option, function (o, mainType) {\n            mainType !== 'graphic' && (this.__lastOnlyGraphic = false);\n        }, this);\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.time && console.time('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            // console.time && console.timeEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            // FIXME\n            // ugly\n            if (this.__lastOnlyGraphic) {\n                each(this._componentsViews, function (componentView) {\n                    var componentModel = componentView.__model;\n                    if (componentModel && componentModel.mainType === 'graphic') {\n                        componentView.render(componentModel, ecModel, this._api, payload);\n                        updateZ(componentModel, componentView);\n                    }\n                }, this);\n                this.__lastOnlyGraphic = false;\n            }\n            else {\n                updateMethods.update.call(this, payload);\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            var view = ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId];\n            if (view && view.__alive) {\n                view[method](model, ecModel, ecIns._api, payload);\n            }\n        }, ecIns);\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.4.0',\n        dependencies: {\n            zrender: '3.3.0'\n        }\n    };\n\n    function enableConnect(chart) {\n\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        dom.setAttribute &&\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        }\n        else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(185));\n    echarts.registerPreprocessor(__webpack_require__(177));\n    echarts.registerLoading('default', __webpack_require__(168));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = __webpack_require__(20);\n    echarts.Model = __webpack_require__(10);\n\n    echarts.graphic = __webpack_require__(2);\n    echarts.number = __webpack_require__(3);\n    echarts.format = __webpack_require__(8);\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = __webpack_require__(23);\n    echarts.vector = __webpack_require__(6);\n    echarts.color = __webpack_require__(25);\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var pathTool = __webpack_require__(259);\n    var round = Math.round;\n    var Path = __webpack_require__(7);\n    var colorTool = __webpack_require__(25);\n    var matrix = __webpack_require__(23);\n    var vector = __webpack_require__(6);\n\n    var graphic = {};\n\n    graphic.Group = __webpack_require__(35);\n\n    graphic.Image = __webpack_require__(70);\n\n    graphic.Text = __webpack_require__(242);\n\n    graphic.Circle = __webpack_require__(249);\n\n    graphic.Sector = __webpack_require__(255);\n\n    graphic.Ring = __webpack_require__(254);\n\n    graphic.Polygon = __webpack_require__(251);\n\n    graphic.Polyline = __webpack_require__(252);\n\n    graphic.Rect = __webpack_require__(253);\n\n    graphic.Line = __webpack_require__(250);\n\n    graphic.BezierCurve = __webpack_require__(248);\n\n    graphic.Arc = __webpack_require__(247);\n\n    graphic.CompoundPath = __webpack_require__(239);\n\n    graphic.LinearGradient = __webpack_require__(240);\n\n    graphic.RadialGradient = __webpack_require__(241);\n\n    graphic.BoundingRect = __webpack_require__(13);\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.attr(props), cb && cb());\n        }\n        else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    module.exports = graphic;\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        return +(+x).toFixed(precision);\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10; // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        return nf * exp10;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n\n/***/ }),\n/* 4 */,\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = Object.create(options.computed || null)\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n    options.computed = computed\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = __webpack_require__(46);\n    var zrUtil = __webpack_require__(0);\n    var PathProxy = __webpack_require__(36);\n    var pathContain = __webpack_require__(232);\n\n    var Pattern = __webpack_require__(71);\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var numberUtil = __webpack_require__(3);\n    var textContain = __webpack_require__(18);\n\n    var formatUtil = {};\n    /**\n     * ,\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var formatUtil = __webpack_require__(8);\n    var nubmerUtil = __webpack_require__(3);\n    var Model = __webpack_require__(10);\n    var zrUtil = __webpack_require__(0);\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get(['label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = {};\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && (idMap[opt.id] = item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-';\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap[keyInfo.id]);\n            }\n\n            idMap[keyInfo.id] = item;\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, goeName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = parsedKey[2];\n\n            if (!mainType || !queryType) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            queryParam[queryType.toLowerCase()] = value;\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var clazzUtil = __webpack_require__(14);\n    var env = __webpack_require__(11);\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, __webpack_require__(175));\n    mixin(Model, __webpack_require__(172));\n    mixin(Model, __webpack_require__(176));\n    mixin(Model, __webpack_require__(174));\n\n    module.exports = Model;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n/***/ }),\n/* 12 */,\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = __webpack_require__(6);\n    var matrix = __webpack_require__(23);\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n/***/ }),\n/* 15 */,\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = __webpack_require__(10);\n    var zrUtil = __webpack_require__(0);\n    var arrayPush = Array.prototype.push;\n    var componentUtil = __webpack_require__(42);\n    var clazzUtil = __webpack_require__(14);\n    var layout = __webpack_require__(17);\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, __webpack_require__(173));\n\n    module.exports = ComponentModel;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Layout helpers for each component positioning\n\n\n    var zrUtil = __webpack_require__(0);\n    var BoundingRect = __webpack_require__(13);\n    var numberUtil = __webpack_require__(3);\n    var formatUtil = __webpack_require__(8);\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = ['width', 'left', 'right']; // Order by priority.\n        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = __webpack_require__(0);\n    var BoundingRect = __webpack_require__(13);\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(6);\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = __webpack_require__(10);\n    var DataDiffer = __webpack_require__(166);\n\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(9);\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var idList = [];\n        var nameRepeatCount = {};\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n\n            indices.push(idx);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (\n                    diff <= maxDistance\n                    && (dist < minDist\n                        // For the case of two data are same on xAxis, which has sequence data.\n                        // Show the nearest index\n                        // https://github.com/ecomfe/echarts/issues/2869\n                        || (dist === minDist && diff > 0)\n                    )\n                ) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var formatUtil = __webpack_require__(8);\n    var classUtil = __webpack_require__(14);\n    var modelUtil = __webpack_require__(9);\n    var ComponentModel = __webpack_require__(16);\n    var colorPaletteMixin = __webpack_require__(62);\n    var env = __webpack_require__(11);\n    var layout = __webpack_require__(17);\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', this.getInitialData(option, ecModel));\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return [coordDim];\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return dataDim;\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var result = [];\n\n                zrUtil.each(value, function (val, idx) {\n                    var dimInfo = data.getDimensionInfo(idx);\n                    var dimType = dimInfo && dimInfo.type;\n                    var valStr;\n\n                    if (dimType === 'ordinal') {\n                        valStr = val + '';\n                    }\n                    else if (dimType === 'time') {\n                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);\n                    }\n                    else {\n                        valStr = addCommas(val);\n                    }\n\n                    valStr && result.push(valStr);\n                });\n\n                return result.join(', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = encodeHTML(\n                zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value)\n            );\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + '\"></span>';\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            return !multipleSeries\n                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n                    + (name\n                        ? encodeHTML(name) + ' : ' + formattedValue\n                        : formattedValue\n                    )\n                  )\n                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Array.<number>} data indices.\n         */\n        getAxisTooltipDataIndex: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    /**\n     * Interface of Coordinate System Class\n     *\n     * create:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *     @return {Object} coordinate system instance\n     *\n     * update:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *\n     * convertToPixel:\n     * convertFromPixel:\n     *     These two methods is also responsible for determine whether this\n     *     coodinate system is applicable to the given `finder`.\n     *     Each coordinate system will be tried, util one returns none\n     *     null/undefined value.\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {Object} finder\n     *     @param {Array|number} value\n     *     @return {Array|number} convert result.\n     *\n     * containPoint:\n     *     @param {Array.<number>} point In pixel coordinate system.\n     *     @return {boolean}\n     */\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var OrdinalScale = __webpack_require__(181);\n    var IntervalScale = __webpack_require__(30);\n    __webpack_require__(182);\n    __webpack_require__(180);\n    var Scale = __webpack_require__(31);\n\n    var numberUtil = __webpack_require__(3);\n    var zrUtil = __webpack_require__(0);\n    var textContain = __webpack_require__(18);\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = originalExtent[1] - originalExtent[0];\n        }\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        axis.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            var origin = (extent[1] + extent[0]) / 2;\n            scale.setExtent(\n                intervalScale * (extent[0] - origin) + origin,\n                intervalScale * (extent[1] - origin) + origin\n            );\n            scale.niceExtent(splitNumber);\n        }\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    module.exports = axisHelper;\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = __webpack_require__(0);\n\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} [defaultNames]    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} [extraPrefix]             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n                dimensions[i] = guessOrdinal(data, i)\n                    ? {type: 'ordinal', name: name}\n                    : name;\n            }\n        }\n\n        return dimensions;\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (zrUtil.isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = __webpack_require__(0);\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = __webpack_require__(3);\n    var formatUtil = __webpack_require__(8);\n    var Scale = __webpack_require__(31);\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            var interval = this._interval;\n            var extent = this._extent;\n            var ticks = [];\n\n            // Consider this case: using dataZoom toolbox, zoom and zoom.\n            var safeLimit = 10000;\n\n            if (interval) {\n                var niceExtent = this._niceExtent;\n                var precision = getPrecisionSafe(interval) + 2;\n\n                if (extent[0] < niceExtent[0]) {\n                    ticks.push(extent[0]);\n                }\n                var tick = niceExtent[0];\n\n                while (tick <= niceExtent[1]) {\n                    ticks.push(tick);\n                    // Avoid rounding error\n                    tick = roundingErrorFix(tick + interval, precision);\n                    if (ticks.length > safeLimit) {\n                        return [];\n                    }\n                }\n                // Consider this case: the last item of ticks is smaller\n                // than niceExtent[1] and niceExtent[1] === extent[1].\n                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n                    ticks.push(extent[1]);\n                }\n            }\n\n            return ticks;\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} n\n         * @return {number}\n         */\n        getLabel: function (data) {\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         */\n        niceTicks: function (splitNumber) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n            // var niceSpan = numberUtil.nice(span, false);\n            var step = roundingErrorFix(\n                numberUtil.nice(span / splitNumber, true),\n                Math.max(\n                    getPrecisionSafe(extent[0]),\n                    getPrecisionSafe(extent[1])\n                // extent may be [0, 1], and step should have 1 more digits.\n                // To make it safe we add 2 more digits\n                ) + 2\n            );\n\n            var precision = getPrecisionSafe(step) + 2;\n            // Niced extent inside original extent\n            var niceExtent = [\n                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n            ];\n\n            this._interval = step;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [splitNumber = 5] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = __webpack_require__(14);\n\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Symbol factory\n\n\n    var graphic = __webpack_require__(2);\n    var BoundingRect = __webpack_require__(13);\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Group = __webpack_require__(35);\n    var componentUtil = __webpack_require__(42);\n    var clazzUtil = __webpack_require__(14);\n    var modelUtil = __webpack_require__(9);\n    var zrUtil = __webpack_require__(0);\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\n\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var Element = __webpack_require__(64);\n    var BoundingRect = __webpack_require__(13);\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = __webpack_require__(19);\n    var vec2 = __webpack_require__(6);\n    var bbox = __webpack_require__(237);\n    var BoundingRect = __webpack_require__(13);\n    var dpr = __webpack_require__(34).devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = __webpack_require__(24);\n    var env = __webpack_require__(11);\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    __webpack_require__(60);\n\n    __webpack_require__(114);\n    __webpack_require__(115);\n\n    var barLayoutGrid = __webpack_require__(167);\n    var echarts = __webpack_require__(1);\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    __webpack_require__(40);\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var List = __webpack_require__(20);\n    var completeDimensions = __webpack_require__(28);\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(9);\n    var CoordinateSystem = __webpack_require__(26);\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            completeDimensions(dimensions, data);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, ['lng', 'lat', 'value'])\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var graphic = __webpack_require__(2);\n    var zrUtil = __webpack_require__(0);\n    var echarts = __webpack_require__(1);\n\n    __webpack_require__(60);\n\n    __webpack_require__(141);\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports) {\n\n\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var clazz = __webpack_require__(14);\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        // FIXME Performance\n                        var itemModel = dataAll.getItemModel(rawIdx);\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports) {\n\n// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var Style = __webpack_require__(72);\n\n    var Element = __webpack_require__(64);\n    var RectText = __webpack_require__(246);\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports) {\n\n\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.2.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\".NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\".NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName;\n\nif (\"production\".NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'function' && vm.options\n      ? vm.options.name\n      : vm._isVue\n        ? vm.$options.name || vm.$options._componentTag\n        : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === \"<Anonymous>\") {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (\"production\".NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = target.__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\".NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = target.__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\".NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (\"production\".NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      \"production\".NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (\"production\".NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (\"production\".NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$3) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (\"production\".NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (\"production\".NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (\"production\".NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (\"production\".NODE_ENV !== 'production') {\n      warn((\"Error in \" + info + \":\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (\"production\".NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\nvar mark;\nvar measure;\n\nif (\"production\".NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!cur) {\n      \"production\".NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      if (!cur.fns) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (!oldHook) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (oldHook.fns && oldHook.merged) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns\n) {\n  var res = {};\n  for (var i = 0; i < fns.length; i++) {\n    res[fns[i][0]] = fns[i][1];\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (\"production\".NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (\"production\".NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (\"production\".NODE_ENV !== 'production') {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (\"production\".NODE_ENV !== 'production') {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive == null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar queue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has = {};\n  if (\"production\".NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id, vm;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (\"production\".NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // call updated hooks\n  index = queue.length;\n  while (index--) {\n    watcher = queue[index];\n    vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n\n  resetSchedulerState();\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = \"production\".NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"production\".NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (\"production\".NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\".NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      \"production\".NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (\"production\".NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (\"production\".NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    if (!vnode.componentInstance._isMounted) {\n      vnode.componentInstance._isMounted = true;\n      callHook(vnode.componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      activateChildComponent(vnode.componentInstance, true /* direct */);\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    if (!vnode.componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        vnode.componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(vnode.componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (\"production\".NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (data.model) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractProps(data, Ctor);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      \"production\".NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (\"production\".NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && attrs.hasOwnProperty(keyInLowerCase)\n        ) {\n          warn(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is not declared in component \" +\n            (formatComponentName(Ctor)) + \". Note that HTML attributes are \" +\n            \"case-insensitive and camelCased props need to use their kebab-case \" +\n            \"equivalents when using in-DOM templates. You should probably use \" +\n            \"\\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (on[event]) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    \"production\".NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && \"production\".NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"production\".NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (\"production\".NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (\"production\".NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = _toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var inject = vm.$options.inject;\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          vm[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n    }\n  }\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    /* istanbul ignore if */\n    if (\"production\".NODE_ENV !== 'production' && config.performance && mark) {\n      mark('vue-perf-init');\n    }\n\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (\"production\".NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (\"production\".NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark('vue-perf-init-end');\n      measure(((vm._name) + \" init\"), 'vue-perf-init', 'vue-perf-init-end');\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    for (var i = 0; i < latest.length; i++) {\n      if (sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (\"production\".NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (\"production\".NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (\"production\".NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (pattern instanceof RegExp) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cachedNode);\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    if (!vnode.componentInstance._inactive) {\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (\"production\".NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$3.version = '2.2.4';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.componentInstance) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"production\".NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (s) {\n  return s == null\n}\n\nfunction isDef (s) {\n  return s != null\n}\n\nfunction sameVnode (vnode1, vnode2) {\n  return (\n    vnode1.key === vnode2.key &&\n    vnode1.tag === vnode2.tag &&\n    vnode1.isComment === vnode2.isComment &&\n    !vnode1.data === !vnode2.data\n  )\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks[i]] !== undefined) { cbs[hooks[i]].push(modules[j][hooks[i]]); }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (parent) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (\"production\".NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (\"production\".NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (vnode.isComment) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isReactivated) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (vnode.data.pendingInsert) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (parent) {\n      if (ref) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (i.create) { i.create(emptyNode, vnode); }\n      if (i.insert) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (rm || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (!rm) {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } else {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (\"production\".NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (vnode.isStatic &&\n        oldVnode.isStatic &&\n        vnode.key === oldVnode.key &&\n        (vnode.isCloned || vnode.isOnce)) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    var hasData = isDef(data);\n    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (hasData && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (hasData) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (initial && vnode.parent) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (\"production\".NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (\"production\".NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (vnode.tag) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (!vnode) {\n      if (oldVnode) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (!oldVnode) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (hydrating) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (\"production\".NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (vnode.parent) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (parentElm$1 !== null) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important\n) {\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (\"production\".NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (\"production\".NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + value + \"=$$c}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (on[RANGE_TOKEN]) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (on[CHECKBOX_RADIO_TOKEN]) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once,\n  capture\n) {\n  if (once) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (\"production\".NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (\"production\".NODE_ENV !== 'production' && explicitLeaveDuration != null) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (!fn) { return false }\n  var invokerFns = fn.fns;\n  if (invokerFns) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\".NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (\"production\".NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (\"production\".NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (\"production\".NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (\"production\".NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (\"production\".NODE_ENV !== 'production' &&\n      config.productionTip !== false &&\n      inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (\"production\".NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (\"production\".NODE_ENV !== 'production' &&\n            (i > pos || !tagName) &&\n            options.warn) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"production\".NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (\"production\".NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (\"production\".NODE_ENV !== 'production') {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (\"production\".NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (\"production\".NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      \"production\".NODE_ENV !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (\"production\".NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (\"production\".NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (\"production\".NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (\"production\".NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (\"production\".NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\"production\".NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (events, native) {\n  var res = native ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"production\".NODE_ENV !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    \"production\".NODE_ENV !== 'production' &&\n    maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (\"production\".NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  return \"[\" + key + \",function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}]\"\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot') {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);\n  if (keywordMatch) {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (\"production\".NODE_ENV !== 'production') {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (\"production\".NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (\"production\".NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (\"production\".NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (\"production\".NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (\"production\".NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"production\".NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (\"production\".NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (\"production\".NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (\"production\".NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (\"production\".NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = Vue$3;\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(22)))\n\n/***/ }),\n/* 49 */,\n/* 50 */,\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(Buffer) {/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap) {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n  var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n  return '/*# ' + data + ' */';\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(109).Buffer))\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var symbolUtil = __webpack_require__(32);\n    var graphic = __webpack_require__(2);\n    var numberUtil = __webpack_require__(3);\n\n    function getSymbolSize(data, idx) {\n        var symbolSize = data.getItemVisual(idx, 'symbolSize');\n        return symbolSize instanceof Array\n            ? symbolSize.slice()\n            : [+symbolSize, +symbolSize];\n    }\n\n    function getScale(symbolSize) {\n        return [symbolSize[0] / 2, symbolSize[1] / 2];\n    }\n\n    /**\n     * @constructor\n     * @alias {module:echarts/chart/helper/Symbol}\n     * @param {module:echarts/data/List} data\n     * @param {number} idx\n     * @extends {module:zrender/graphic/Group}\n     */\n    function Symbol(data, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this.updateData(data, idx, seriesScope);\n    }\n\n    var symbolProto = Symbol.prototype;\n\n    function driftSymbol(dx, dy) {\n        this.parent.drift(dx, dy);\n    }\n\n    symbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n        // Remove paths created before\n        this.removeAll();\n\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // var symbolPath = symbolUtil.createSymbol(\n        //     symbolType, -0.5, -0.5, 1, 1, color\n        // );\n        // If width/height are set too small (e.g., set to 1) on ios10\n        // and macOS Sierra, a circle stroke become a rect, no matter what\n        // the scale is set. So we set width/height as 2. See #4150.\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -1, -1, 2, 2, color\n        );\n\n        symbolPath.attr({\n            z2: 100,\n            culling: true,\n            scale: [0, 0]\n        });\n        // Rewrite drift method\n        symbolPath.drift = driftSymbol;\n\n        graphic.initProps(symbolPath, {\n            scale: getScale(symbolSize)\n        }, seriesModel, idx);\n        this._symbolType = symbolType;\n\n        this.add(symbolPath);\n    };\n\n    /**\n     * Stop animation\n     * @param {boolean} toLastFrame\n     */\n    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n        this.childAt(0).stopAnimation(toLastFrame);\n    };\n\n    /**\n     * Get symbol path element\n     */\n    symbolProto.getSymbolPath = function () {\n        return this.childAt(0);\n    };\n\n    /**\n     * Get scale(aka, current symbol size).\n     * Including the change caused by animation\n     */\n    symbolProto.getScale = function () {\n        return this.childAt(0).scale;\n    };\n\n    /**\n     * Highlight symbol\n     */\n    symbolProto.highlight = function () {\n        this.childAt(0).trigger('emphasis');\n    };\n\n    /**\n     * Downplay symbol\n     */\n    symbolProto.downplay = function () {\n        this.childAt(0).trigger('normal');\n    };\n\n    /**\n     * @param {number} zlevel\n     * @param {number} z\n     */\n    symbolProto.setZ = function (zlevel, z) {\n        var symbolPath = this.childAt(0);\n        symbolPath.zlevel = zlevel;\n        symbolPath.z = z;\n    };\n\n    symbolProto.setDraggable = function (draggable) {\n        var symbolPath = this.childAt(0);\n        symbolPath.draggable = draggable;\n        symbolPath.cursor = draggable ? 'move' : 'pointer';\n    };\n\n    /**\n     * Update symbol properties\n     * @param  {module:echarts/data/List} data\n     * @param  {number} idx\n     */\n    symbolProto.updateData = function (data, idx, seriesScope) {\n        this.silent = false;\n\n        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n        var seriesModel = data.hostModel;\n        var symbolSize = getSymbolSize(data, idx);\n\n        if (symbolType !== this._symbolType) {\n            this._createSymbol(symbolType, data, idx, symbolSize);\n        }\n        else {\n            var symbolPath = this.childAt(0);\n            graphic.updateProps(symbolPath, {\n                scale: getScale(symbolSize)\n            }, seriesModel, idx);\n        }\n        this._updateCommon(data, idx, symbolSize, seriesScope);\n        this._seriesModel = seriesModel;\n    };\n\n    // Update common properties\n    var normalStyleAccessPath = ['itemStyle', 'normal'];\n    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n    var normalLabelAccessPath = ['label', 'normal'];\n    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\n    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // Reset style\n        if (symbolPath.type !== 'image') {\n            symbolPath.useStyle({\n                strokeNoScale: true\n            });\n        }\n\n        seriesScope = seriesScope || null;\n\n        var itemStyle = seriesScope && seriesScope.itemStyle;\n        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n\n        if (!seriesScope || data.hasItemOption) {\n            var itemModel = data.getItemModel(idx);\n\n            // Color must be excluded.\n            // Because symbol provide setColor individually to set fill and stroke\n            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\n            symbolRotate = itemModel.getShallow('symbolRotate');\n            symbolOffset = itemModel.getShallow('symbolOffset');\n\n            labelModel = itemModel.getModel(normalLabelAccessPath);\n            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n            hoverAnimation = itemModel.getShallow('hoverAnimation');\n        }\n        else {\n            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n        }\n\n        var elStyle = symbolPath.style;\n\n        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n        if (symbolOffset) {\n            symbolPath.attr('position', [\n                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n            ]);\n        }\n\n        // PENDING setColor before setStyle!!!\n        symbolPath.setColor(color);\n\n        symbolPath.setStyle(itemStyle);\n\n        var opacity = data.getItemVisual(idx, 'opacity');\n        if (opacity != null) {\n            elStyle.opacity = opacity;\n        }\n\n        // Get last value dim\n        var dimensions = data.dimensions.slice();\n        var valueDim;\n        var dataType;\n        while (dimensions.length && (\n            valueDim = dimensions.pop(),\n            dataType = data.getDimensionInfo(valueDim).type,\n            dataType === 'ordinal' || dataType === 'time'\n        )) {} // jshint ignore:line\n\n        if (valueDim != null && labelModel.getShallow('show')) {\n            graphic.setText(elStyle, labelModel, color);\n            elStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'normal'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            elStyle.text = '';\n        }\n\n        if (valueDim != null && hoverLabelModel.getShallow('show')) {\n            graphic.setText(hoverItemStyle, hoverLabelModel, color);\n            hoverItemStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'emphasis'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            hoverItemStyle.text = '';\n        }\n\n        symbolPath.off('mouseover')\n            .off('mouseout')\n            .off('emphasis')\n            .off('normal');\n\n        symbolPath.hoverStyle = hoverItemStyle;\n\n        graphic.setHoverStyle(symbolPath);\n\n        var scale = getScale(symbolSize);\n\n        if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n            var onEmphasis = function() {\n                var ratio = scale[1] / scale[0];\n                this.animateTo({\n                    scale: [\n                        Math.max(scale[0] * 1.1, scale[0] + 3),\n                        Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)\n                    ]\n                }, 400, 'elasticOut');\n            };\n            var onNormal = function() {\n                this.animateTo({\n                    scale: scale\n                }, 400, 'elasticOut');\n            };\n            symbolPath.on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n    };\n\n    symbolProto.fadeOut = function (cb) {\n        var symbolPath = this.childAt(0);\n        // Avoid mistaken hover when fading out\n        this.silent = true;\n        // Not show text when animating\n        symbolPath.style.text = '';\n        graphic.updateProps(symbolPath, {\n            scale: [0, 0]\n        }, this._seriesModel, this.dataIndex, cb);\n    };\n\n    zrUtil.inherits(Symbol, graphic.Group);\n\n    module.exports = Symbol;\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n\n    var graphic = __webpack_require__(2);\n    var Symbol = __webpack_require__(52);\n\n    /**\n     * @constructor\n     * @alias module:echarts/chart/helper/SymbolDraw\n     * @param {module:zrender/graphic/Group} [symbolCtor]\n     */\n    function SymbolDraw(symbolCtor) {\n        this.group = new graphic.Group();\n\n        this._symbolCtor = symbolCtor || Symbol;\n    }\n\n    var symbolDrawProto = SymbolDraw.prototype;\n\n    function symbolNeedsDraw(data, idx, isIgnore) {\n        var point = data.getItemLayout(idx);\n        // Is an object\n        // if (point && point.hasOwnProperty('point')) {\n        //     point = point.point;\n        // }\n        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n                    && data.getItemVisual(idx, 'symbol') !== 'none';\n    }\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     * @param {Array.<boolean>} [isIgnore]\n     */\n    symbolDrawProto.updateData = function (data, isIgnore) {\n        var group = this.group;\n        var seriesModel = data.hostModel;\n        var oldData = this._data;\n\n        var SymbolCtor = this._symbolCtor;\n\n        var seriesScope = {\n            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n            symbolRotate: seriesModel.get('symbolRotate'),\n            symbolOffset: seriesModel.get('symbolOffset'),\n            hoverAnimation: seriesModel.get('hoverAnimation'),\n\n            labelModel: seriesModel.getModel('label.normal'),\n            hoverLabelModel: seriesModel.getModel('label.emphasis')\n        };\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                var point = data.getItemLayout(newIdx);\n                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n                    symbolEl.attr('position', point);\n                    data.setItemGraphicEl(newIdx, symbolEl);\n                    group.add(symbolEl);\n                }\n            })\n            .update(function (newIdx, oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                var point = data.getItemLayout(newIdx);\n                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    group.remove(symbolEl);\n                    return;\n                }\n                if (!symbolEl) {\n                    symbolEl = new SymbolCtor(data, newIdx);\n                    symbolEl.attr('position', point);\n                }\n                else {\n                    symbolEl.updateData(data, newIdx, seriesScope);\n                    graphic.updateProps(symbolEl, {\n                        position: point\n                    }, seriesModel);\n                }\n\n                // Add back\n                group.add(symbolEl);\n\n                data.setItemGraphicEl(newIdx, symbolEl);\n            })\n            .remove(function (oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                el && el.fadeOut(function () {\n                    group.remove(el);\n                });\n            })\n            .execute();\n\n        this._data = data;\n    };\n\n    symbolDrawProto.updateLayout = function () {\n        var data = this._data;\n        if (data) {\n            // Not use animation\n            data.eachItemGraphicEl(function (el, idx) {\n                var point = data.getItemLayout(idx);\n                el.attr('position', point);\n            });\n        }\n    };\n\n    symbolDrawProto.remove = function (enableAnimation) {\n        var group = this.group;\n        var data = this._data;\n        if (data) {\n            if (enableAnimation) {\n                data.eachItemGraphicEl(function (el) {\n                    el.fadeOut(function () {\n                        group.remove(el);\n                    });\n                });\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    };\n\n    module.exports = SymbolDraw;\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var echarts = __webpack_require__(1);\n\n    __webpack_require__(129);\n    __webpack_require__(130);\n\n    __webpack_require__(113)('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(__webpack_require__(43), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        __webpack_require__(132), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(__webpack_require__(41), 'pie'));\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var formatUtil = __webpack_require__(8);\n    var graphic = __webpack_require__(2);\n    var Model = __webpack_require__(10);\n    var numberUtil = __webpack_require__(3);\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = __webpack_require__(6);\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n            // To radian.\n            labelRotation = labelRotation * PI / 180;\n\n            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelBeforeFormat = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelBeforeFormat;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            function isTwoLabelOverlapped(current, next) {\n                var firstRect = current && current.getBoundingRect().clone();\n                var nextRect = next && next.getBoundingRect().clone();\n                if (firstRect && nextRect) {\n                    firstRect.applyTransform(current.getLocalTransform());\n                    nextRect.applyTransform(next.getLocalTransform());\n                    return firstRect.intersect(nextRect);\n                }\n            }\n\n            // If min or max are user set, we need to check\n            // If the tick on min(max) are overlap on their neighbour tick\n            // If they are overlapped, we need to hide the min(max) tick label\n            if (axisModel.getMin() != null) {\n                var firstLabel = textEls[0];\n                var nextLabel = textEls[1];\n                if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                    firstLabel.ignore = true;\n                }\n            }\n            if (axisModel.getMax() != null) {\n                var lastLabel = textEls[textEls.length - 1];\n                var prevLabel = textEls[textEls.length - 2];\n                if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                    lastLabel.ignore = true;\n                }\n            }\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.verticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var numberUtil = __webpack_require__(3);\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = __webpack_require__(0);\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * When axis extent depends on data and no data exists,\n         * axis ticks should not be drawn, which is named 'blank'.\n         */\n        isBlank: function () {\n            return this._isBlank;\n        },\n\n        /**\n         * When axis extent depends on data and no data exists,\n         * axis ticks should not be drawn, which is named 'blank'.\n         */\n        setBlank: function (isBlank) {\n            this._isBlank = isBlank;\n        }\n\n    };\n\n    module.exports = Axis;\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // \n        z: 0,                       // \n        // \n        inverse: false,\n\n        // \n        name: '',\n        // 'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // degree\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // \n        nameTextStyle: {},\n        // \n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        // \n        axisLine: {\n            // show\n            show: true,\n            onZero: true,\n            // lineStyle\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // grid\n            inside: false,\n            // length\n            length: 5,\n            // lineStyle\n            lineStyle: {\n                width: 1\n            }\n        },\n        // axis.axisLabel\n        axisLabel: {\n            show: true,\n            // grid\n            inside: false,\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            // TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // lineStylelineStyle\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        splitArea: {\n            // show\n            show: false,\n            // areaStyleareaStyle\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // \n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // \n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            // Default with axisTick\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // \n        boundaryGap: [0, 0],\n        // ,  'dataMin' \n        // min: null,\n        //  'dataMax' \n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 0_min_max\n        // scale: false,\n        // 5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n    var logAxis = zrUtil.defaults({\n        logBase: 10\n    }, valueAxis);\n    logAxis.scale = true;\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var axisHelper = __webpack_require__(27);\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj;\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var ComponentModel = __webpack_require__(16);\n    var zrUtil = __webpack_require__(0);\n    var axisModelCreator = __webpack_require__(157);\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         * @return {module:echarts/model/Component}\n         */\n        getCoordSysModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.option.gridIndex,\n                id: this.option.gridId\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, __webpack_require__(58));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = __webpack_require__(17);\n    var axisHelper = __webpack_require__(27);\n\n    var zrUtil = __webpack_require__(0);\n    var Cartesian2D = __webpack_require__(160);\n    var Axis2D = __webpack_require__(158);\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    //  GridModel, AxisModel \n    __webpack_require__(161);\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.getCoordSysModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var textStyleModel = axisModel.getModel('axisLabel.textStyle');\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = textStyleModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this._model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this._model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n        else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex\n                    || coordList[i].getAxis('y').index === yAxisIndex\n                ) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtentFromData(data, dim);\n            });\n        }\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.getCoordSysModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\n    __webpack_require__(26).register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = function (seriesType, ecModel) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys) {\n                var dims = coordSys.dimensions;\n\n                if (coordSys.type === 'singleAxis') {\n                    data.each(dims[0], function (x, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n                    });\n                }\n                else {\n                    data.each(dims, function (x, y, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(\n                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n                        );\n                    }, true);\n                }\n            }\n        });\n    };\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var classUtil = __webpack_require__(14);\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [],\n\tfixUrls = __webpack_require__(193);\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\toptions.attrs.type = \"text/css\";\n\n\tattachTagAttrs(styleElement, options.attrs);\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\tattachTagAttrs(linkElement, options.attrs);\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction attachTagAttrs(element, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\telement.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement, options);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls){\n\t\tcss = fixUrls(css);\n\t}\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module zrender/Element\n */\n\n\n    var guid = __webpack_require__(68);\n    var Eventful = __webpack_require__(24);\n    var Transformable = __webpack_require__(258);\n    var Animatable = __webpack_require__(256);\n    var zrUtil = __webpack_require__(0);\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = __webpack_require__(227);\n    var color = __webpack_require__(25);\n    var util = __webpack_require__(0);\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports) {\n\n\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports) {\n\n/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n        var config = __webpack_require__(34);\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = __webpack_require__(46);\n    var BoundingRect = __webpack_require__(13);\n    var zrUtil = __webpack_require__(0);\n\n    var LRU = __webpack_require__(236);\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                // \n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports) {\n\n\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports) {\n\n/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var smoothSpline = __webpack_require__(245);\n    var smoothBezier = __webpack_require__(244);\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n/***/ }),\n/* 74 */,\n/* 75 */,\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t? self // if in worker\n\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = (function(){\n\n// Private helper vars\nvar lang = /\\blang(?:uage)?-(\\w+)\\b/i;\nvar uniqueId = 0;\n\nvar _ = _self.Prism = {\n\tutil: {\n\t\tencode: function (tokens) {\n\t\t\tif (tokens instanceof Token) {\n\t\t\t\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n\t\t\t} else if (_.util.type(tokens) === 'Array') {\n\t\t\t\treturn tokens.map(_.util.encode);\n\t\t\t} else {\n\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t}\n\t\t},\n\n\t\ttype: function (o) {\n\t\t\treturn Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n\t\t},\n\n\t\tobjId: function (obj) {\n\t\t\tif (!obj['__id']) {\n\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t}\n\t\t\treturn obj['__id'];\n\t\t},\n\n\t\t// Deep clone a language definition (e.g. to extend it)\n\t\tclone: function (o) {\n\t\t\tvar type = _.util.type(o);\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'Object':\n\t\t\t\t\tvar clone = {};\n\n\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tclone[key] = _.util.clone(o[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn clone;\n\n\t\t\t\tcase 'Array':\n\t\t\t\t\t// Check for existence for IE8\n\t\t\t\t\treturn o.map && o.map(function(v) { return _.util.clone(v); });\n\t\t\t}\n\n\t\t\treturn o;\n\t\t}\n\t},\n\n\tlanguages: {\n\t\textend: function (id, redef) {\n\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\tfor (var key in redef) {\n\t\t\t\tlang[key] = redef[key];\n\t\t\t}\n\n\t\t\treturn lang;\n\t\t},\n\n\t\t/**\n\t\t * Insert a token before another token in a language literal\n\t\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n\t\t * we cannot just provide an object, we need anobject and a key.\n\t\t * @param inside The key (or language id) of the parent\n\t\t * @param before The key to insert before. If not provided, the function appends instead.\n\t\t * @param insert Object with the key/value pairs to insert\n\t\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n\t\t */\n\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\troot = root || _.languages;\n\t\t\tvar grammar = root[inside];\n\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tinsert = arguments[1];\n\n\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\tgrammar[newToken] = insert[newToken];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn grammar;\n\t\t\t}\n\n\t\t\tvar ret = {};\n\n\t\t\tfor (var token in grammar) {\n\n\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\tif (token == before) {\n\n\t\t\t\t\t\tfor (var newToken in insert) {\n\n\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update references in other language definitions\n\t\t\t_.languages.DFS(_.languages, function(key, value) {\n\t\t\t\tif (value === root[inside] && key != inside) {\n\t\t\t\t\tthis[key] = ret;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn root[inside] = ret;\n\t\t},\n\n\t\t// Traverse a language definition with Depth First Search\n\t\tDFS: function(o, callback, type, visited) {\n\t\t\tvisited = visited || {};\n\t\t\tfor (var i in o) {\n\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\tif (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, null, visited);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, i, visited);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tplugins: {},\n\n\thighlightAll: function(async, callback) {\n\t\tvar env = {\n\t\t\tcallback: callback,\n\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t};\n\n\t\t_.hooks.run(\"before-highlightall\", env);\n\n\t\tvar elements = env.elements || document.querySelectorAll(env.selector);\n\n\t\tfor (var i=0, element; element = elements[i++];) {\n\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t}\n\t},\n\n\thighlightElement: function(element, async, callback) {\n\t\t// Find language\n\t\tvar language, grammar, parent = element;\n\n\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\tif (parent) {\n\t\t\tlanguage = (parent.className.match(lang) || [,''])[1].toLowerCase();\n\t\t\tgrammar = _.languages[language];\n\t\t}\n\n\t\t// Set language on the element, if not present\n\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\n\t\t// Set language on the parent, for styling\n\t\tparent = element.parentNode;\n\n\t\tif (/pre/i.test(parent.nodeName)) {\n\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\t}\n\n\t\tvar code = element.textContent;\n\n\t\tvar env = {\n\t\t\telement: element,\n\t\t\tlanguage: language,\n\t\t\tgrammar: grammar,\n\t\t\tcode: code\n\t\t};\n\n\t\t_.hooks.run('before-sanity-check', env);\n\n\t\tif (!env.code || !env.grammar) {\n\t\t\tif (env.code) {\n\t\t\t\tenv.element.textContent = env.code;\n\t\t\t}\n\t\t\t_.hooks.run('complete', env);\n\t\t\treturn;\n\t\t}\n\n\t\t_.hooks.run('before-highlight', env);\n\n\t\tif (async && _self.Worker) {\n\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\tworker.onmessage = function(evt) {\n\t\t\t\tenv.highlightedCode = evt.data;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t};\n\n\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\tlanguage: env.language,\n\t\t\t\tcode: env.code,\n\t\t\t\timmediateClose: true\n\t\t\t}));\n\t\t}\n\t\telse {\n\t\t\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\n\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\tcallback && callback.call(element);\n\n\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t_.hooks.run('complete', env);\n\t\t}\n\t},\n\n\thighlight: function (text, grammar, language) {\n\t\tvar tokens = _.tokenize(text, grammar);\n\t\treturn Token.stringify(_.util.encode(tokens), language);\n\t},\n\n\ttokenize: function(text, grammar, language) {\n\t\tvar Token = _.Token;\n\n\t\tvar strarr = [text];\n\n\t\tvar rest = grammar.rest;\n\n\t\tif (rest) {\n\t\t\tfor (var token in rest) {\n\t\t\t\tgrammar[token] = rest[token];\n\t\t\t}\n\n\t\t\tdelete grammar.rest;\n\t\t}\n\n\t\ttokenloop: for (var token in grammar) {\n\t\t\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tvar pattern = patterns[j],\n\t\t\t\t\tinside = pattern.inside,\n\t\t\t\t\tlookbehind = !!pattern.lookbehind,\n\t\t\t\t\tgreedy = !!pattern.greedy,\n\t\t\t\t\tlookbehindLength = 0,\n\t\t\t\t\talias = pattern.alias;\n\n\t\t\t\tif (greedy && !pattern.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = pattern.pattern.toString().match(/[imuy]*$/)[0];\n\t\t\t\t\tpattern.pattern = RegExp(pattern.pattern.source, flags + \"g\");\n\t\t\t\t}\n\n\t\t\t\tpattern = pattern.pattern || pattern;\n\n\t\t\t\t// Dont cache length as it changes during the loop\n\t\t\t\tfor (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {\n\n\t\t\t\t\tvar str = strarr[i];\n\n\t\t\t\t\tif (strarr.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\tbreak tokenloop;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpattern.lastIndex = 0;\n\n\t\t\t\t\tvar match = pattern.exec(str),\n\t\t\t\t\t    delNum = 1;\n\n\t\t\t\t\t// Greedy patterns can override/remove up to two previously matched tokens\n\t\t\t\t\tif (!match && greedy && i != strarr.length - 1) {\n\t\t\t\t\t\tpattern.lastIndex = pos;\n\t\t\t\t\t\tmatch = pattern.exec(text);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index + (lookbehind ? match[1].length : 0),\n\t\t\t\t\t\t    to = match.index + match[0].length,\n\t\t\t\t\t\t    k = i,\n\t\t\t\t\t\t    p = pos;\n\n\t\t\t\t\t\tfor (var len = strarr.length; k < len && p < to; ++k) {\n\t\t\t\t\t\t\tp += strarr[k].length;\n\t\t\t\t\t\t\t// Move the index i to the element in strarr that is closest to from\n\t\t\t\t\t\t\tif (from >= p) {\n\t\t\t\t\t\t\t\t++i;\n\t\t\t\t\t\t\t\tpos = p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If strarr[i] is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\t * If strarr[k - 1] is greedy we are in conflict with another greedy pattern\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (strarr[i] instanceof Token || strarr[k - 1].greedy) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Number of tokens to delete and replace with the new match\n\t\t\t\t\t\tdelNum = k - i;\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(lookbehind) {\n\t\t\t\t\t\tlookbehindLength = match[1].length;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar from = match.index + lookbehindLength,\n\t\t\t\t\t    match = match[0].slice(lookbehindLength),\n\t\t\t\t\t    to = from + match.length,\n\t\t\t\t\t    before = str.slice(0, from),\n\t\t\t\t\t    after = str.slice(to);\n\n\t\t\t\t\tvar args = [i, delNum];\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\targs.push(before);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);\n\n\t\t\t\t\targs.push(wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\targs.push(after);\n\t\t\t\t\t}\n\n\t\t\t\t\tArray.prototype.splice.apply(strarr, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn strarr;\n\t},\n\n\thooks: {\n\t\tall: {},\n\n\t\tadd: function (name, callback) {\n\t\t\tvar hooks = _.hooks.all;\n\n\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\thooks[name].push(callback);\n\t\t},\n\n\t\trun: function (name, env) {\n\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i=0, callback; callback = callbacks[i++];) {\n\t\t\t\tcallback(env);\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar Token = _.Token = function(type, content, alias, matchedStr, greedy) {\n\tthis.type = type;\n\tthis.content = content;\n\tthis.alias = alias;\n\t// Copy of the full string this token was created from\n\tthis.length = (matchedStr || \"\").length|0;\n\tthis.greedy = !!greedy;\n};\n\nToken.stringify = function(o, language, parent) {\n\tif (typeof o == 'string') {\n\t\treturn o;\n\t}\n\n\tif (_.util.type(o) === 'Array') {\n\t\treturn o.map(function(element) {\n\t\t\treturn Token.stringify(element, language, o);\n\t\t}).join('');\n\t}\n\n\tvar env = {\n\t\ttype: o.type,\n\t\tcontent: Token.stringify(o.content, language, parent),\n\t\ttag: 'span',\n\t\tclasses: ['token', o.type],\n\t\tattributes: {},\n\t\tlanguage: language,\n\t\tparent: parent\n\t};\n\n\tif (env.type == 'comment') {\n\t\tenv.attributes['spellcheck'] = 'true';\n\t}\n\n\tif (o.alias) {\n\t\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n\t\tArray.prototype.push.apply(env.classes, aliases);\n\t}\n\n\t_.hooks.run('wrap', env);\n\n\tvar attributes = Object.keys(env.attributes).map(function(name) {\n\t\treturn name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t}).join(' ');\n\n\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';\n\n};\n\nif (!_self.document) {\n\tif (!_self.addEventListener) {\n\t\t// in Node.js\n\t\treturn _self.Prism;\n\t}\n \t// In worker\n\t_self.addEventListener('message', function(evt) {\n\t\tvar message = JSON.parse(evt.data),\n\t\t    lang = message.language,\n\t\t    code = message.code,\n\t\t    immediateClose = message.immediateClose;\n\n\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\tif (immediateClose) {\n\t\t\t_self.close();\n\t\t}\n\t}, false);\n\n\treturn _self.Prism;\n}\n\n//Get current script and highlight\nvar script = document.currentScript || [].slice.call(document.getElementsByTagName(\"script\")).pop();\n\nif (script) {\n\t_.filename = script.src;\n\n\tif (document.addEventListener && !script.hasAttribute('data-manual')) {\n\t\tif(document.readyState !== \"loading\") {\n\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(_.highlightAll);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(_.highlightAll, 16);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\n\t\t}\n\t}\n}\n\nreturn _self.Prism;\n\n})();\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n\tglobal.Prism = Prism;\n}\n\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n\t'comment': /<!--[\\w\\W]*?-->/,\n\t'prolog': /<\\?[\\w\\W]+?\\?>/,\n\t'doctype': /<!DOCTYPE[\\w\\W]+?>/i,\n\t'cdata': /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\\\1|\\\\?(?!\\1)[\\w\\W])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /[=>\"']/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': /&#?[\\da-z]{1,8};/i\n};\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function(env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nPrism.languages.xml = Prism.languages.markup;\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\nPrism.languages.css = {\n\t'comment': /\\/\\*[\\w\\W]*?\\*\\//,\n\t'atrule': {\n\t\tpattern: /@[\\w-]+?.*?(;|(?=\\s*\\{))/i,\n\t\tinside: {\n\t\t\t'rule': /@[\\w-]+/\n\t\t\t// See rest below\n\t\t}\n\t},\n\t'url': /url\\((?:([\"'])(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1|.*?)\\)/i,\n\t'selector': /[^\\{\\}\\s][^\\{\\};]*?(?=\\s*\\{)/,\n\t'string': {\n\t\tpattern: /(\"|')(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'property': /(\\b|\\B)[\\w-]+(?=\\s*:)/i,\n\t'important': /\\B!important\\b/i,\n\t'function': /[-a-z0-9]+(?=\\()/i,\n\t'punctuation': /[(){};:]/\n};\n\nPrism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'style': {\n\t\t\tpattern: /(<style[\\w\\W]*?>)[\\w\\W]*?(?=<\\/style>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.css,\n\t\t\talias: 'language-css'\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('inside', 'attr-value', {\n\t\t'style-attr': {\n\t\t\tpattern: /\\s*style=(\"|').*?\\1/i,\n\t\t\tinside: {\n\t\t\t\t'attr-name': {\n\t\t\t\t\tpattern: /^\\s*style/i,\n\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t},\n\t\t\t\t'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /.+/i,\n\t\t\t\t\tinside: Prism.languages.css\n\t\t\t\t}\n\t\t\t},\n\t\t\talias: 'language-css'\n\t\t}\n\t}, Prism.languages.markup.tag);\n}\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\tpunctuation: /(\\.|\\\\)/\n\t\t}\n\t},\n\t'keyword': /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n\t'boolean': /\\b(true|false)\\b/,\n\t'function': /[a-z0-9_]+(?=\\()/i,\n\t'number': /\\b-?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+-]?\\d+)?)\\b/i,\n\t'operator': /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'keyword': /\\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,\n\t'number': /\\b-?(0x[\\dA-Fa-f]+|0b[01]+|0o[0-7]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|Infinity)\\b/,\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*(?=\\()/i,\n\t'operator': /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*\\*?|\\/|~|\\^|%|\\.{3}/\n});\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\\\\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'template-string': {\n\t\tpattern: /`(?:\\\\\\\\|\\\\?[^\\\\])*?`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /\\$\\{[^}]+\\}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t}\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'script': {\n\t\t\tpattern: /(<script[\\w\\W]*?>)[\\w\\W]*?(?=<\\/script>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript,\n\t\t\talias: 'language-javascript'\n\t\t}\n\t});\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n\tif (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {\n\t\treturn;\n\t}\n\n\tself.Prism.fileHighlight = function() {\n\n\t\tvar Extensions = {\n\t\t\t'js': 'javascript',\n\t\t\t'py': 'python',\n\t\t\t'rb': 'ruby',\n\t\t\t'ps1': 'powershell',\n\t\t\t'psm1': 'powershell',\n\t\t\t'sh': 'bash',\n\t\t\t'bat': 'batch',\n\t\t\t'h': 'c',\n\t\t\t'tex': 'latex'\n\t\t};\n\n\t\tif(Array.prototype.forEach) { // Check to prevent error in IE8\n\t\t\tArray.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {\n\t\t\t\tvar src = pre.getAttribute('data-src');\n\n\t\t\t\tvar language, parent = pre;\n\t\t\t\tvar lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\t\t\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\t\t\tparent = parent.parentNode;\n\t\t\t\t}\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tlanguage = (pre.className.match(lang) || [, ''])[1];\n\t\t\t\t}\n\n\t\t\t\tif (!language) {\n\t\t\t\t\tvar extension = (src.match(/\\.(\\w+)$/) || [, ''])[1];\n\t\t\t\t\tlanguage = Extensions[extension] || extension;\n\t\t\t\t}\n\n\t\t\t\tvar code = document.createElement('code');\n\t\t\t\tcode.className = 'language-' + language;\n\n\t\t\t\tpre.textContent = '';\n\n\t\t\t\tcode.textContent = 'Loading';\n\n\t\t\t\tpre.appendChild(code);\n\n\t\t\t\tvar xhr = new XMLHttpRequest();\n\n\t\t\t\txhr.open('GET', src, true);\n\n\t\t\t\txhr.onreadystatechange = function () {\n\t\t\t\t\tif (xhr.readyState == 4) {\n\n\t\t\t\t\t\tif (xhr.status < 400 && xhr.responseText) {\n\t\t\t\t\t\t\tcode.textContent = xhr.responseText;\n\n\t\t\t\t\t\t\tPrism.highlightElement(code);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (xhr.status >= 400) {\n\t\t\t\t\t\t\tcode.textContent = ' Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcode.textContent = ' Error: File does not exist or is empty';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\txhr.send(null);\n\t\t\t});\n\t\t}\n\n\t};\n\n\tdocument.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);\n\n})();\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))\n\n/***/ }),\n/* 77 */,\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */,\n/* 82 */,\n/* 83 */,\n/* 84 */,\n/* 85 */,\n/* 86 */,\n/* 87 */,\n/* 88 */,\n/* 89 */,\n/* 90 */,\n/* 91 */,\n/* 92 */,\n/* 93 */,\n/* 94 */,\n/* 95 */,\n/* 96 */,\n/* 97 */,\n/* 98 */,\n/* 99 */,\n/* 100 */,\n/* 101 */,\n/* 102 */,\n/* 103 */,\n/* 104 */,\n/* 105 */,\n/* 106 */,\n/* 107 */,\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(108)\nvar ieee754 = __webpack_require__(191)\nvar isArray = __webpack_require__(192)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))\n\n/***/ }),\n/* 110 */,\n/* 111 */,\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n    ];\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var echarts = __webpack_require__(1);\n    var zrUtil = __webpack_require__(0);\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](payload.name);\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name) || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    module.exports = __webpack_require__(116).extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        brushSelector: 'rect'\n    });\n\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n    var helper = __webpack_require__(118);\n\n    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\n    // FIXME\n    // Just for compatible with ec2.\n    zrUtil.extend(__webpack_require__(10).prototype, __webpack_require__(117));\n\n    var BarView = __webpack_require__(1).extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n            var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(dataIndex);\n                    var layout = getRectItemLayout(data, dataIndex, itemModel);\n                    var el = createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel);\n                    data.setItemGraphicEl(dataIndex, el);\n                    group.add(el);\n\n                    updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal);\n                })\n                .update(function (newIndex, oldIndex) {\n                    var el = oldData.getItemGraphicEl(oldIndex);\n\n                    if (!data.hasValue(newIndex)) {\n                        group.remove(el);\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(newIndex);\n                    var layout = getRectItemLayout(data, newIndex, itemModel);\n\n                    if (el) {\n                        graphic.updateProps(el, {shape: layout}, animationModel, newIndex);\n                    }\n                    else {\n                        el = createRect(data, newIndex, itemModel, layout, isHorizontal, animationModel, true);\n                    }\n\n                    data.setItemGraphicEl(newIndex, el);\n                    // Add back\n                    group.add(el);\n\n                    updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontal);\n                })\n                .remove(function (dataIndex) {\n                    var el = oldData.getItemGraphicEl(dataIndex);\n                    el && removeRect(dataIndex, animationModel, el);\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            var data = this._data;\n            if (ecModel.get('animation')) {\n                if (data) {\n                    data.eachItemGraphicEl(function (el) {\n                        removeRect(el.dataIndex, ecModel, el);\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n    function createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n        var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});\n\n        // Animation\n        if (animationModel) {\n            var rectShape = rect.shape;\n            var animateProperty = isHorizontal ? 'height' : 'width';\n            var animateTarget = {};\n            rectShape[animateProperty] = 0;\n            animateTarget[animateProperty] = layout[animateProperty];\n            graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n                shape: animateTarget\n            }, animationModel, dataIndex);\n        }\n\n        return rect;\n    }\n\n    function removeRect(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                width: 0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    function getRectItemLayout(data, dataIndex, itemModel) {\n        var layout = data.getItemLayout(dataIndex);\n        var fixedLineWidth = getLineWidth(itemModel, layout);\n\n        // fix layout with lineWidth\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        return {\n            x: layout.x + signX * fixedLineWidth / 2,\n            y: layout.y + signY * fixedLineWidth / 2,\n            width: layout.width - signX * fixedLineWidth,\n            height: layout.height - signY * fixedLineWidth\n        };\n    }\n\n    function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal) {\n        var color = data.getItemVisual(dataIndex, 'color');\n        var opacity = data.getItemVisual(dataIndex, 'opacity');\n        var itemStyleModel = itemModel.getModel('itemStyle.normal');\n        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n        el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\n        el.useStyle(zrUtil.defaults(\n            {\n                fill: color,\n                opacity: opacity\n            },\n            itemStyleModel.getBarItemStyle()\n        ));\n\n        var labelPositionOutside = isHorizontal\n            ? (layout.height > 0 ? 'bottom' : 'top')\n            : (layout.width > 0 ? 'left' : 'right');\n\n        helper.setLabel(\n            el.style, hoverStyle, itemModel, color,\n            seriesModel, dataIndex, labelPositionOutside\n        );\n\n        graphic.setHoverStyle(el, hoverStyle);\n    }\n\n    // In case width or height are too small.\n    function getLineWidth(itemModel, rawLayout) {\n        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n        return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n    }\n\n    module.exports = BarView;\n\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var SeriesModel = __webpack_require__(21);\n    var createListFromArray = __webpack_require__(39);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.__base_bar__',\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 0\n            barMinHeight: 0,\n\n            // barMaxWidth: null,\n            // \n            // barWidth: null,\n            // 30%\n            // barGap: '30%',\n            // 20%\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: ''\n                },\n                emphasis: {}\n            }\n        }\n    });\n\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\n    var getBarItemStyle = __webpack_require__(29)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n\n    var helper = {};\n\n    helper.setLabel = function (\n        normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n    ) {\n        var labelModel = itemModel.getModel('label.normal');\n        var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n        if (labelModel.get('show')) {\n            setLabel(\n                normalStyle, labelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            normalStyle.text = '';\n        }\n\n        if (hoverLabelModel.get('show')) {\n            setLabel(\n                hoverStyle, hoverLabelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'emphasis'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            hoverStyle.text = '';\n        }\n    };\n\n    function setLabel(style, model, color, labelText, labelPositionOutside) {\n        graphic.setText(style, model, color);\n        style.text = labelText;\n        if (style.textPosition === 'outside') {\n            style.textPosition = labelPositionOutside;\n        }\n    }\n\n    module.exports = helper;\n\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var echarts = __webpack_require__(1);\n\n    __webpack_require__(120);\n    __webpack_require__(121);\n\n    echarts.registerVisual(zrUtil.curry(__webpack_require__(43), 'funnel'));\n    echarts.registerLayout(__webpack_require__(122));\n\n    echarts.registerProcessor(zrUtil.curry(__webpack_require__(41), 'funnel'));\n\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var List = __webpack_require__(20);\n    var modelUtil = __webpack_require__(9);\n    var completeDimensions = __webpack_require__(28);\n\n    var FunnelSeries = __webpack_require__(1).extendSeriesModel({\n\n        type: 'series.funnel',\n\n        init: function (option) {\n            FunnelSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n            // Extend labelLine emphasis\n            this._defaultLabelLine(option);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            legendHoverLink: true,\n            left: 80,\n            top: 60,\n            right: 80,\n            bottom: 60,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n\n            // \n            // min: 0,\n            // max: 100,\n            minSize: '0%',\n            maxSize: '100%',\n            sort: 'descending', // 'ascending', 'descending'\n            gap: 0,\n            funnelAlign: 'center',\n            label: {\n                normal: {\n                    show: true,\n                    position: 'outer'\n                    // formatter: Tooltip.formatter\n                    // textStyle: null      // TEXTSTYLE\n                },\n                emphasis: {\n                    show: true\n                }\n            },\n            labelLine: {\n                normal: {\n                    show: true,\n                    length: 20,\n                    lineStyle: {\n                        // color: ,\n                        width: 1,\n                        type: 'solid'\n                    }\n                },\n                emphasis: {}\n            },\n            itemStyle: {\n                normal: {\n                    // color: ,\n                    borderColor: '#fff',\n                    borderWidth: 1\n                },\n                emphasis: {\n                    // color: ,\n                }\n            }\n        }\n    });\n\n    module.exports = FunnelSeries;\n\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var graphic = __webpack_require__(2);\n    var zrUtil = __webpack_require__(0);\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function FunnelPiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var polygon = new graphic.Polygon();\n        var labelLine = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(polygon);\n        this.add(labelLine);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            labelLine.ignore = labelLine.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            labelLine.ignore = labelLine.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var funnelPieceProto = FunnelPiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var position = labelModel.get('position');\n        var isLabelInside = position === 'inside' || position === 'inner' || position === 'center';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state),\n                data.getName(idx)\n            )\n        };\n    }\n\n    var opacityAccessPath = ['itemStyle', 'normal', 'opacity'];\n    funnelPieceProto.updateData = function (data, idx, firstCreate) {\n\n        var polygon = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var opacity = data.getItemModel(idx).get(opacityAccessPath);\n        opacity = opacity == null ? 1 : opacity;\n\n        // Reset style\n        polygon.useStyle({});\n\n        if (firstCreate) {\n            polygon.setShape({\n                points: layout.points\n            });\n            polygon.setStyle({ opacity : 0 });\n            graphic.initProps(polygon, {\n                style: {\n                    opacity: opacity\n                }\n            }, seriesModel, idx);\n        }\n        else {\n            graphic.updateProps(polygon, {\n                style: {\n                    opacity: opacity\n                },\n                shape: {\n                    points: layout.points\n                }\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        polygon.setStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'round',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle(['opacity'])\n            )\n        );\n        polygon.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    funnelPieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || labelLayout.linePoints\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textAlign: labelLayout.textAlign,\n                textVerticalAlign: labelLayout.verticalAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n    };\n\n    zrUtil.inherits(FunnelPiece, graphic.Group);\n\n\n    var Funnel = __webpack_require__(33).extend({\n\n        type: 'funnel',\n\n        render: function (seriesModel, ecModel, api) {\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var group = this.group;\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var funnelPiece = new FunnelPiece(data, idx);\n\n                    data.setItemGraphicEl(idx, funnelPiece);\n\n                    group.add(funnelPiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function () {\n            this.group.removeAll();\n            this._data = null;\n        },\n\n        dispose: function () {}\n    });\n\n    module.exports = Funnel;\n\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var layout = __webpack_require__(17);\n    var number = __webpack_require__(3);\n\n    var parsePercent = number.parsePercent;\n\n    function getViewRect(seriesModel, api) {\n        return layout.getLayoutRect(\n            seriesModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }\n        );\n    }\n\n    function getSortedIndices(data, sort) {\n        var valueArr = data.mapArray('value', function (val) {\n            return val;\n        });\n        var indices = [];\n        var isAscending = sort === 'ascending';\n        for (var i = 0, len = data.count(); i < len; i++) {\n            indices[i] = i;\n        }\n        indices.sort(function (a, b) {\n            return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];\n        });\n        return indices;\n    }\n\n    function labelLayout (data) {\n        data.each(function (idx) {\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            var labelPosition = labelModel.get('position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n\n            var layout = data.getItemLayout(idx);\n            var points = layout.points;\n\n            var isLabelInside = labelPosition === 'inner'\n                || labelPosition === 'inside' || labelPosition === 'center';\n\n            var textAlign;\n            var textX;\n            var textY;\n            var linePoints;\n\n            if (isLabelInside) {\n                textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;\n                textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;\n                textAlign = 'center';\n                linePoints = [\n                    [textX, textY], [textX, textY]\n                ];\n            }\n            else {\n                var x1;\n                var y1;\n                var x2;\n                var labelLineLen = labelLineModel.get('length');\n                if (labelPosition === 'left') {\n                    // Left side\n                    x1 = (points[3][0] + points[0][0]) / 2;\n                    y1 = (points[3][1] + points[0][1]) / 2;\n                    x2 = x1 - labelLineLen;\n                    textX = x2 - 5;\n                    textAlign = 'right';\n                }\n                else {\n                    // Right side\n                    x1 = (points[1][0] + points[2][0]) / 2;\n                    y1 = (points[1][1] + points[2][1]) / 2;\n                    x2 = x1 + labelLineLen;\n                    textX = x2 + 5;\n                    textAlign = 'left';\n                }\n                var y2 = y1;\n\n                linePoints = [[x1, y1], [x2, y2]];\n                textY = y2;\n            }\n\n            layout.label = {\n                linePoints: linePoints,\n                x: textX,\n                y: textY,\n                verticalAlign: 'middle',\n                textAlign: textAlign,\n                inside: isLabelInside\n            };\n        });\n    }\n\n    module.exports = function (ecModel, api, payload) {\n        ecModel.eachSeriesByType('funnel', function (seriesModel) {\n            var data = seriesModel.getData();\n            var sort = seriesModel.get('sort');\n            var viewRect = getViewRect(seriesModel, api);\n            var indices = getSortedIndices(data, sort);\n\n            var sizeExtent = [\n                parsePercent(seriesModel.get('minSize'), viewRect.width),\n                parsePercent(seriesModel.get('maxSize'), viewRect.width)\n            ];\n            var dataExtent = data.getDataExtent('value');\n            var min = seriesModel.get('min');\n            var max = seriesModel.get('max');\n            if (min == null) {\n                min = Math.min(dataExtent[0], 0);\n            }\n            if (max == null) {\n                max = dataExtent[1];\n            }\n\n            var funnelAlign = seriesModel.get('funnelAlign');\n            var gap = seriesModel.get('gap');\n            var itemHeight = (viewRect.height - gap * (data.count() - 1)) / data.count();\n\n            var y = viewRect.y;\n\n            var getLinePoints = function (idx, offY) {\n                // End point index is data.count() and we assign it 0\n                var val = data.get('value', idx) || 0;\n                var itemWidth = number.linearMap(val, [min, max], sizeExtent, true);\n                var x0;\n                switch (funnelAlign) {\n                    case 'left':\n                        x0 = viewRect.x;\n                        break;\n                    case 'center':\n                        x0 = viewRect.x + (viewRect.width - itemWidth) / 2;\n                        break;\n                    case 'right':\n                        x0 = viewRect.x + viewRect.width - itemWidth;\n                        break;\n                }\n                return [\n                    [x0, offY],\n                    [x0 + itemWidth, offY]\n                ];\n            };\n\n            if (sort === 'ascending') {\n                // From bottom to top\n                itemHeight = -itemHeight;\n                gap = -gap;\n                y += viewRect.height;\n                indices = indices.reverse();\n            }\n\n            for (var i = 0; i < indices.length; i++) {\n                var idx = indices[i];\n                var nextIdx = indices[i + 1];\n                var start = getLinePoints(idx, y);\n                var end = getLinePoints(nextIdx, y + itemHeight);\n\n                y += itemHeight + gap;\n\n                data.setItemLayout(idx, {\n                    points: start.concat(end.slice().reverse())\n                });\n            }\n\n            labelLayout(data);\n        });\n    };\n\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// TODO Batch by color\n\n\n\n    var graphic = __webpack_require__(2);\n    var symbolUtil = __webpack_require__(32);\n\n    var LargeSymbolPath = graphic.extendShape({\n\n        shape: {\n            points: null,\n            sizes: null\n        },\n\n        symbolProxy: null,\n\n        buildPath: function (path, shape) {\n            var points = shape.points;\n            var sizes = shape.sizes;\n\n            var symbolProxy = this.symbolProxy;\n            var symbolProxyShape = symbolProxy.shape;\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                var size = sizes[i];\n                if (size[0] < 4) {\n                    // Optimize for small symbol\n                    path.rect(\n                        pt[0] - size[0] / 2, pt[1] - size[1] / 2,\n                        size[0], size[1]\n                    );\n                }\n                else {\n                    symbolProxyShape.x = pt[0] - size[0] / 2;\n                    symbolProxyShape.y = pt[1] - size[1] / 2;\n                    symbolProxyShape.width = size[0];\n                    symbolProxyShape.height = size[1];\n\n                    symbolProxy.buildPath(path, symbolProxyShape, true);\n                }\n            }\n        },\n\n        findDataIndex: function (x, y) {\n            var shape = this.shape;\n            var points = shape.points;\n            var sizes = shape.sizes;\n\n            // Not consider transform\n            // Treat each element as a rect\n            // top down traverse\n            for (var i = points.length - 1; i >= 0; i--) {\n                var pt = points[i];\n                var size = sizes[i];\n                var x0 = pt[0] - size[0] / 2;\n                var y0 = pt[1] - size[1] / 2;\n                if (x >= x0 && y >= y0 && x <= x0 + size[0] && y <= y0 + size[1]) {\n                    // i is dataIndex\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n    });\n\n    function LargeSymbolDraw() {\n        this.group = new graphic.Group();\n\n        this._symbolEl = new LargeSymbolPath({\n            // rectHover: true,\n            // cursor: 'default'\n        });\n    }\n\n    var largeSymbolProto = LargeSymbolDraw.prototype;\n\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     */\n    largeSymbolProto.updateData = function (data) {\n        this.group.removeAll();\n\n        var symbolEl = this._symbolEl;\n\n        var seriesModel = data.hostModel;\n\n        symbolEl.setShape({\n            points: data.mapArray(data.getItemLayout),\n            sizes: data.mapArray(\n                function (idx) {\n                    var size = data.getItemVisual(idx, 'symbolSize');\n                    if (!(size instanceof Array)) {\n                        size = [size, size];\n                    }\n                    return size;\n                }\n            )\n        });\n\n        // Create symbolProxy to build path for each data\n        symbolEl.symbolProxy = symbolUtil.createSymbol(\n            data.getVisual('symbol'), 0, 0, 0, 0\n        );\n        // Use symbolProxy setColor method\n        symbolEl.setColor = symbolEl.symbolProxy.setColor;\n\n        symbolEl.useStyle(\n            seriesModel.getModel('itemStyle.normal').getItemStyle(['color'])\n        );\n\n        var visualColor = data.getVisual('color');\n        if (visualColor) {\n            symbolEl.setColor(visualColor);\n        }\n\n        // Enable tooltip\n        // PENDING May have performance issue when path is extremely large\n        symbolEl.seriesIndex = seriesModel.seriesIndex;\n        symbolEl.on('mousemove', function (e) {\n            symbolEl.dataIndex = null;\n            var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n            if (dataIndex > 0) {\n                // Provide dataIndex for tooltip\n                symbolEl.dataIndex = dataIndex;\n            }\n        });\n\n        // Add back\n        this.group.add(symbolEl);\n    };\n\n    largeSymbolProto.updateLayout = function (seriesModel) {\n        var data = seriesModel.getData();\n        this._symbolEl.setShape({\n            points: data.mapArray(data.getItemLayout)\n        });\n    };\n\n    largeSymbolProto.remove = function () {\n        this.group.removeAll();\n    };\n\n    module.exports = LargeSymbolDraw;\n\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var echarts = __webpack_require__(1);\n    var PRIORITY = echarts.PRIORITY;\n\n    __webpack_require__(125);\n    __webpack_require__(126);\n\n    echarts.registerVisual(zrUtil.curry(\n        __webpack_require__(44), 'line', 'circle', 'line'\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        __webpack_require__(61), 'line'\n    ));\n\n    // Down sample after filter\n    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n        __webpack_require__(179), 'line'\n    ));\n\n    // In case developer forget to include grid component\n    __webpack_require__(40);\n\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var createListFromArray = __webpack_require__(39);\n    var SeriesModel = __webpack_require__(21);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.line',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // stack: null\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // polarIndex: 0,\n\n            // If clip the overflow value\n            clipOverflow: true,\n\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // itemStyle: {\n            //     normal: {},\n            //     emphasis: {}\n            // },\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // areaStyle: {},\n            // false, 'start', 'end', 'middle'\n            step: false,\n\n            // Disabled if step is true\n            smooth: false,\n            smoothMonotone: null,\n            // \n            symbol: 'emptyCircle',\n            // \n            symbolSize: 4,\n            // \n            symbolRotate: null,\n\n            //  symbol,  tooltip hover \n            showSymbol: true,\n            // \n            showAllSymbol: false,\n\n            // \n            connectNulls: false,\n\n            // 'average', 'max', 'min', 'sum'\n            sampling: 'none',\n\n            animationEasing: 'linear',\n\n            // Disable progressive\n            progressive: 0,\n            hoverLayerThreshold: Infinity\n        }\n    });\n\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// FIXME step not support polar\n\n\n    var zrUtil = __webpack_require__(0);\n    var SymbolDraw = __webpack_require__(53);\n    var Symbol = __webpack_require__(52);\n    var lineAnimationDiff = __webpack_require__(127);\n    var graphic = __webpack_require__(2);\n    var modelUtil = __webpack_require__(9);\n    var polyHelper = __webpack_require__(128);\n    var ChartView = __webpack_require__(33);\n\n    function isPointsSame(points1, points2) {\n        if (points1.length !== points2.length) {\n            return;\n        }\n        for (var i = 0; i < points1.length; i++) {\n            var p1 = points1[i];\n            var p2 = points2[i];\n            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n                return;\n            }\n        }\n        return true;\n    }\n\n    function getSmooth(smooth) {\n        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n    }\n\n    function getAxisExtentWithGap(axis) {\n        var extent = axis.getGlobalExtent();\n        if (axis.onBand) {\n            // Remove extra 1px to avoid line miter in clipped edge\n            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n            var dir = extent[1] > extent[0] ? 1 : -1;\n            extent[0] += dir * halfBandWidth;\n            extent[1] -= dir * halfBandWidth;\n        }\n        return extent;\n    }\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n    /**\n     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n     * @param {module:echarts/data/List} data\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    function getStackedOnPoints(coordSys, data) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        return data.mapArray([valueDim], function (val, idx) {\n            var stackedOnSameSign;\n            var stackedOn = data.stackedOn;\n            // Find first stacked value with same sign\n            while (stackedOn &&\n                sign(stackedOn.get(valueDim, idx)) === sign(val)\n            ) {\n                stackedOnSameSign = stackedOn;\n                break;\n            }\n            var stackedData = [];\n            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n            stackedData[1 - baseDataOffset] = stackedOnSameSign\n                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n            return coordSys.dataToPoint(stackedData);\n        }, true);\n    }\n\n    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\n        var x = Math.min(xExtent[0], xExtent[1]);\n        var y = Math.min(yExtent[0], yExtent[1]);\n        var width = Math.max(xExtent[0], xExtent[1]) - x;\n        var height = Math.max(yExtent[0], yExtent[1]) - y;\n        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n        // Expand clip shape to avoid clipping when line value exceeds axis\n        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n        if (isHorizontal) {\n            y -= expandSize;\n            height += expandSize * 2;\n        }\n        else {\n            x -= expandSize;\n            width += expandSize * 2;\n        }\n\n        var clipPath = new graphic.Rect({\n            shape: {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n            graphic.initProps(clipPath, {\n                shape: {\n                    width: width,\n                    height: height\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n        var angleAxis = polar.getAngleAxis();\n        var radiusAxis = polar.getRadiusAxis();\n\n        var radiusExtent = radiusAxis.getExtent();\n        var angleExtent = angleAxis.getExtent();\n\n        var RADIAN = Math.PI / 180;\n\n        var clipPath = new graphic.Sector({\n            shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r0: radiusExtent[0],\n                r: radiusExtent[1],\n                startAngle: -angleExtent[0] * RADIAN,\n                endAngle: -angleExtent[1] * RADIAN,\n                clockwise: angleAxis.inverse\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: -angleExtent[1] * RADIAN\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createClipShape(coordSys, hasAnimation, seriesModel) {\n        return coordSys.type === 'polar'\n            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n    }\n\n    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n        var baseAxis = coordSys.getBaseAxis();\n        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n        var stepPoints = [];\n        for (var i = 0; i < points.length - 1; i++) {\n            var nextPt = points[i + 1];\n            var pt = points[i];\n            stepPoints.push(pt);\n\n            var stepPt = [];\n            switch (stepTurnAt) {\n                case 'end':\n                    stepPt[baseIndex] = nextPt[baseIndex];\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n                    break;\n                case 'middle':\n                    // default is start\n                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n                    var stepPt2 = [];\n                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n                    stepPoints.push(stepPt);\n                    stepPoints.push(stepPt2);\n                    break;\n                default:\n                    stepPt[baseIndex] = pt[baseIndex];\n                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n            }\n        }\n        // Last points\n        points[i] && stepPoints.push(points[i]);\n        return stepPoints;\n    }\n\n    function getVisualGradient(data, coordSys) {\n        var visualMetaList = data.getVisual('visualMeta');\n        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n            // When data.count() is 0, gradient range can not be calculated.\n            return;\n        }\n\n        var visualMeta;\n        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n            // Can only be x or y\n            if (visualMetaList[i].dimension < 2) {\n                visualMeta = visualMetaList[i];\n                break;\n            }\n        }\n        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n            if (__DEV__) {\n                console.warn('Visual map on line style only support x or y dimension.');\n            }\n            return;\n        }\n\n        // If the area to be rendered is bigger than area defined by LinearGradient,\n        // the canvas spec prescribes that the color of the first stop and the last\n        // stop should be used. But if two stops are added at offset 0, in effect\n        // browsers use the color of the second stop to render area outside\n        // LinearGradient. So we can only infinitesimally extend area defined in\n        // LinearGradient to render `outerColors`.\n\n        var dimension = visualMeta.dimension;\n        var dimName = data.dimensions[dimension];\n        var axis = coordSys.getAxis(dimName);\n\n        // dataToCoor mapping may not be linear, but must be monotonic.\n        var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n            return {\n                coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n                color: stop.color\n            };\n        });\n        var stopLen = colorStops.length;\n        var outerColors = visualMeta.outerColors.slice();\n\n        if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n            colorStops.reverse();\n            outerColors.reverse();\n        }\n\n        var tinyExtent = 10; // Arbitrary value: 10px\n        var minCoord = colorStops[0].coord - tinyExtent;\n        var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n        var coordSpan = maxCoord - minCoord;\n\n        if (coordSpan < 1e-3) {\n            return 'transparent';\n        }\n\n        zrUtil.each(colorStops, function (stop) {\n            stop.offset = (stop.coord - minCoord) / coordSpan;\n        });\n        colorStops.push({\n            offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n            color: outerColors[1] || 'transparent'\n        });\n        colorStops.unshift({ // notice colorStops.length have been changed.\n            offset: stopLen ? colorStops[0].offset : 0.5,\n            color: outerColors[0] || 'transparent'\n        });\n\n        // zrUtil.each(colorStops, function (colorStop) {\n        //     // Make sure each offset has rounded px to avoid not sharp edge\n        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n        // });\n\n        var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n        gradient[dimName] = minCoord;\n        gradient[dimName + '2'] = maxCoord;\n\n        return gradient;\n    }\n\n    module.exports = ChartView.extend({\n\n        type: 'line',\n\n        init: function () {\n            var lineGroup = new graphic.Group();\n\n            var symbolDraw = new SymbolDraw();\n            this.group.add(symbolDraw.group);\n\n            this._symbolDraw = symbolDraw;\n            this._lineGroup = lineGroup;\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var group = this.group;\n            var data = seriesModel.getData();\n            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\n            var points = data.mapArray(data.getItemLayout, true);\n\n            var isCoordSysPolar = coordSys.type === 'polar';\n            var prevCoordSys = this._coordSys;\n\n            var symbolDraw = this._symbolDraw;\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n\n            var lineGroup = this._lineGroup;\n\n            var hasAnimation = seriesModel.get('animation');\n\n            var isAreaChart = !areaStyleModel.isEmpty();\n            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\n            var showSymbol = seriesModel.get('showSymbol');\n\n            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n                && this._getSymbolIgnoreFunc(data, coordSys);\n\n            // Remove temporary symbols\n            var oldData = this._data;\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            // Remove previous created symbols if showSymbol changed to false\n            if (!showSymbol) {\n                symbolDraw.remove();\n            }\n\n            group.add(lineGroup);\n\n            // FIXME step not support polar\n            var step = !isCoordSysPolar && seriesModel.get('step');\n            // Initialization animation or coordinate system changed\n            if (\n                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n            ) {\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                if (step) {\n                    // TODO If stacked series is not step\n                    points = turnPointsIntoStep(points, coordSys, step);\n                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                }\n\n                polyline = this._newPolyline(points, coordSys, hasAnimation);\n                if (isAreaChart) {\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n            }\n            else {\n                if (isAreaChart && !polygon) {\n                    // If areaStyle is added\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                else if (polygon && !isAreaChart) {\n                    // If areaStyle is removed\n                    lineGroup.remove(polygon);\n                    polygon = this._polygon = null;\n                }\n\n                // Update clipPath\n                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\n                // Always update, or it is wrong in the case turning on legend\n                // because points are not changed\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                // Stop symbol animation and sync with line points\n                // FIXME performance?\n                data.eachItemGraphicEl(function (el) {\n                    el.stopAnimation(true);\n                });\n\n                // In the case data zoom triggerred refreshing frequently\n                // Data may not change if line has a category axis. So it should animate nothing\n                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n                    || !isPointsSame(this._points, points)\n                ) {\n                    if (hasAnimation) {\n                        this._updateAnimation(\n                            data, stackedOnPoints, coordSys, api, step\n                        );\n                    }\n                    else {\n                        // Not do it in update with animation\n                        if (step) {\n                            // TODO If stacked series is not step\n                            points = turnPointsIntoStep(points, coordSys, step);\n                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                        }\n\n                        polyline.setShape({\n                            points: points\n                        });\n                        polygon && polygon.setShape({\n                            points: points,\n                            stackedOnPoints: stackedOnPoints\n                        });\n                    }\n                }\n            }\n\n            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\n            polyline.useStyle(zrUtil.defaults(\n                // Use color in lineStyle first\n                lineStyleModel.getLineStyle(),\n                {\n                    fill: 'none',\n                    stroke: visualColor,\n                    lineJoin: 'bevel'\n                }\n            ));\n\n            var smooth = seriesModel.get('smooth');\n            smooth = getSmooth(seriesModel.get('smooth'));\n            polyline.setShape({\n                smooth: smooth,\n                smoothMonotone: seriesModel.get('smoothMonotone'),\n                connectNulls: seriesModel.get('connectNulls')\n            });\n\n            if (polygon) {\n                var stackedOn = data.stackedOn;\n                var stackedOnSmooth = 0;\n\n                polygon.useStyle(zrUtil.defaults(\n                    areaStyleModel.getAreaStyle(),\n                    {\n                        fill: visualColor,\n                        opacity: 0.7,\n                        lineJoin: 'bevel'\n                    }\n                ));\n\n                if (stackedOn) {\n                    var stackedOnSeries = stackedOn.hostModel;\n                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n                }\n\n                polygon.setShape({\n                    smooth: smooth,\n                    stackedOnSmooth: stackedOnSmooth,\n                    smoothMonotone: seriesModel.get('smoothMonotone'),\n                    connectNulls: seriesModel.get('connectNulls')\n                });\n            }\n\n            this._data = data;\n            // Save the coordinate system for transition animation when data changed\n            this._coordSys = coordSys;\n            this._stackedOnPoints = stackedOnPoints;\n            this._points = points;\n            this._step = step;\n        },\n\n        dispose: function () {},\n\n        highlight: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (!symbol) {\n                    // Create a temporary symbol if it is not exists\n                    var pt = data.getItemLayout(dataIndex);\n                    if (!pt) {\n                        // Null data\n                        return;\n                    }\n                    symbol = new Symbol(data, dataIndex);\n                    symbol.position = pt;\n                    symbol.setZ(\n                        seriesModel.get('zlevel'),\n                        seriesModel.get('z')\n                    );\n                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n                    symbol.__temp = true;\n                    data.setItemGraphicEl(dataIndex, symbol);\n\n                    // Stop scale animation\n                    symbol.stopSymbolAnimation(true);\n\n                    this.group.add(symbol);\n                }\n                symbol.highlight();\n            }\n            else {\n                // Highlight whole series\n                ChartView.prototype.highlight.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        downplay: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n            if (dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (symbol) {\n                    if (symbol.__temp) {\n                        data.setItemGraphicEl(dataIndex, null);\n                        this.group.remove(symbol);\n                    }\n                    else {\n                        symbol.downplay();\n                    }\n                }\n            }\n            else {\n                // Downplay whole series\n                ChartView.prototype.downplay.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolyline: function (points) {\n            var polyline = this._polyline;\n            // Remove previous created polyline\n            if (polyline) {\n                this._lineGroup.remove(polyline);\n            }\n\n            polyline = new polyHelper.Polyline({\n                shape: {\n                    points: points\n                },\n                silent: true,\n                z2: 10\n            });\n\n            this._lineGroup.add(polyline);\n\n            this._polyline = polyline;\n\n            return polyline;\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} stackedOnPoints\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolygon: function (points, stackedOnPoints) {\n            var polygon = this._polygon;\n            // Remove previous created polygon\n            if (polygon) {\n                this._lineGroup.remove(polygon);\n            }\n\n            polygon = new polyHelper.Polygon({\n                shape: {\n                    points: points,\n                    stackedOnPoints: stackedOnPoints\n                },\n                silent: true\n            });\n\n            this._lineGroup.add(polygon);\n\n            this._polygon = polygon;\n            return polygon;\n        },\n        /**\n         * @private\n         */\n        _getSymbolIgnoreFunc: function (data, coordSys) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n            // `getLabelInterval` is provided by echarts/component/axis\n            if (categoryAxis && categoryAxis.isLabelIgnored) {\n                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n            }\n        },\n\n        /**\n         * @private\n         */\n        // FIXME Two value axis\n        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n            var seriesModel = data.hostModel;\n\n            var diff = lineAnimationDiff(\n                this._data, data,\n                this._stackedOnPoints, stackedOnPoints,\n                this._coordSys, coordSys\n            );\n\n            var current = diff.current;\n            var stackedOnCurrent = diff.stackedOnCurrent;\n            var next = diff.next;\n            var stackedOnNext = diff.stackedOnNext;\n            if (step) {\n                // TODO If stacked series is not step\n                current = turnPointsIntoStep(diff.current, coordSys, step);\n                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n                next = turnPointsIntoStep(diff.next, coordSys, step);\n                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n            }\n            // `diff.current` is subset of `current` (which should be ensured by\n            // turnPointsIntoStep), so points in `__points` can be updated when\n            // points in `current` are update during animation.\n            polyline.shape.__points = diff.current;\n            polyline.shape.points = current;\n\n            graphic.updateProps(polyline, {\n                shape: {\n                    points: next\n                }\n            }, seriesModel);\n\n            if (polygon) {\n                polygon.setShape({\n                    points: current,\n                    stackedOnPoints: stackedOnCurrent\n                });\n                graphic.updateProps(polygon, {\n                    shape: {\n                        points: next,\n                        stackedOnPoints: stackedOnNext\n                    }\n                }, seriesModel);\n            }\n\n            var updatedDataInfo = [];\n            var diffStatus = diff.status;\n\n            for (var i = 0; i < diffStatus.length; i++) {\n                var cmd = diffStatus[i].cmd;\n                if (cmd === '=') {\n                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n                    if (el) {\n                        updatedDataInfo.push({\n                            el: el,\n                            ptIdx: i    // Index of points\n                        });\n                    }\n                }\n            }\n\n            if (polyline.animators && polyline.animators.length) {\n                polyline.animators[0].during(function () {\n                    for (var i = 0; i < updatedDataInfo.length; i++) {\n                        var el = updatedDataInfo[i].el;\n                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n                    }\n                });\n            }\n        },\n\n        remove: function (ecModel) {\n            var group = this.group;\n            var oldData = this._data;\n            this._lineGroup.removeAll();\n            this._symbolDraw.remove(true);\n            // Remove temporary created elements when highlighting\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            this._polyline =\n            this._polygon =\n            this._coordSys =\n            this._points =\n            this._stackedOnPoints =\n            this._data = null;\n        }\n    });\n\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports) {\n\n\n\n    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n    // 'zrender/core/arrayDiff' has been used before, but it did\n    // not do well in performance when roam with fixed dataZoom window.\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n\n    function getStackedOnPoint(coordSys, data, idx) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        var stackedOnSameSign;\n        var stackedOn = data.stackedOn;\n        var val = data.get(valueDim, idx);\n        // Find first stacked value with same sign\n        while (stackedOn &&\n            sign(stackedOn.get(valueDim, idx)) === sign(val)\n        ) {\n            stackedOnSameSign = stackedOn;\n            break;\n        }\n        var stackedData = [];\n        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n        stackedData[1 - baseDataOffset] = stackedOnSameSign\n            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n        return coordSys.dataToPoint(stackedData);\n    }\n\n    // function convertToIntId(newIdList, oldIdList) {\n    //     // Generate int id instead of string id.\n    //     // Compare string maybe slow in score function of arrDiff\n\n    //     // Assume id in idList are all unique\n    //     var idIndicesMap = {};\n    //     var idx = 0;\n    //     for (var i = 0; i < newIdList.length; i++) {\n    //         idIndicesMap[newIdList[i]] = idx;\n    //         newIdList[i] = idx++;\n    //     }\n    //     for (var i = 0; i < oldIdList.length; i++) {\n    //         var oldId = oldIdList[i];\n    //         // Same with newIdList\n    //         if (idIndicesMap[oldId]) {\n    //             oldIdList[i] = idIndicesMap[oldId];\n    //         }\n    //         else {\n    //             oldIdList[i] = idx++;\n    //         }\n    //     }\n    // }\n\n    function diffData(oldData, newData) {\n        var diffResult = [];\n\n        newData.diff(oldData)\n            .add(function (idx) {\n                diffResult.push({cmd: '+', idx: idx});\n            })\n            .update(function (newIdx, oldIdx) {\n                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n            })\n            .remove(function (idx) {\n                diffResult.push({cmd: '-', idx: idx});\n            })\n            .execute();\n\n        return diffResult;\n    }\n\n    module.exports = function (\n        oldData, newData,\n        oldStackedOnPoints, newStackedOnPoints,\n        oldCoordSys, newCoordSys\n    ) {\n        var diff = diffData(oldData, newData);\n\n        // var newIdList = newData.mapArray(newData.getId);\n        // var oldIdList = oldData.mapArray(oldData.getId);\n\n        // convertToIntId(newIdList, oldIdList);\n\n        // // FIXME One data ?\n        // diff = arrayDiff(oldIdList, newIdList);\n\n        var currPoints = [];\n        var nextPoints = [];\n        // Points for stacking base line\n        var currStackedPoints = [];\n        var nextStackedPoints = [];\n\n        var status = [];\n        var sortedIndices = [];\n        var rawIndices = [];\n        var dims = newCoordSys.dimensions;\n        for (var i = 0; i < diff.length; i++) {\n            var diffItem = diff[i];\n            var pointAdded = true;\n\n            // FIXME, animation is not so perfect when dataZoom window moves fast\n            // Which is in case remvoing or add more than one data in the tail or head\n            switch (diffItem.cmd) {\n                case '=':\n                    var currentPt = oldData.getItemLayout(diffItem.idx);\n                    var nextPt = newData.getItemLayout(diffItem.idx1);\n                    // If previous data is NaN, use next point directly\n                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n                        currentPt = nextPt.slice();\n                    }\n                    currPoints.push(currentPt);\n                    nextPoints.push(nextPt);\n\n                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\n                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n                    break;\n                case '+':\n                    var idx = diffItem.idx;\n                    currPoints.push(\n                        oldCoordSys.dataToPoint([\n                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n                        ])\n                    );\n\n                    nextPoints.push(newData.getItemLayout(idx).slice());\n\n                    currStackedPoints.push(\n                        getStackedOnPoint(oldCoordSys, newData, idx)\n                    );\n                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\n                    rawIndices.push(newData.getRawIndex(idx));\n                    break;\n                case '-':\n                    var idx = diffItem.idx;\n                    var rawIndex = oldData.getRawIndex(idx);\n                    // Data is replaced. In the case of dynamic data queue\n                    // FIXME FIXME FIXME\n                    if (rawIndex !== idx) {\n                        currPoints.push(oldData.getItemLayout(idx));\n                        nextPoints.push(newCoordSys.dataToPoint([\n                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n                        ]));\n\n                        currStackedPoints.push(oldStackedOnPoints[idx]);\n                        nextStackedPoints.push(\n                            getStackedOnPoint(\n                                newCoordSys, oldData, idx\n                            )\n                        );\n\n                        rawIndices.push(rawIndex);\n                    }\n                    else {\n                        pointAdded = false;\n                    }\n            }\n\n            // Original indices\n            if (pointAdded) {\n                status.push(diffItem);\n                sortedIndices.push(sortedIndices.length);\n            }\n        }\n\n        // Diff result may be crossed if all items are changed\n        // Sort by data index\n        sortedIndices.sort(function (a, b) {\n            return rawIndices[a] - rawIndices[b];\n        });\n\n        var sortedCurrPoints = [];\n        var sortedNextPoints = [];\n\n        var sortedCurrStackedPoints = [];\n        var sortedNextStackedPoints = [];\n\n        var sortedStatus = [];\n        for (var i = 0; i < sortedIndices.length; i++) {\n            var idx = sortedIndices[i];\n            sortedCurrPoints[i] = currPoints[idx];\n            sortedNextPoints[i] = nextPoints[idx];\n\n            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\n            sortedStatus[i] = status[idx];\n        }\n\n        return {\n            current: sortedCurrPoints,\n            next: sortedNextPoints,\n\n            stackedOnCurrent: sortedCurrStackedPoints,\n            stackedOnNext: sortedNextStackedPoints,\n\n            status: sortedStatus\n        };\n    };\n\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Poly path support NaN point\n\n\n    var Path = __webpack_require__(7);\n    var vec2 = __webpack_require__(6);\n\n    var vec2Min = vec2.min;\n    var vec2Max = vec2.max;\n\n    var scaleAndAdd = vec2.scaleAndAdd;\n    var v2Copy = vec2.copy;\n\n    // Temporary variable\n    var v = [];\n    var cp0 = [];\n    var cp1 = [];\n\n    function isPointNull(p) {\n        return isNaN(p[0]) || isNaN(p[1]);\n    }\n\n    function drawSegment(\n        ctx, points, start, segLen, allLen,\n        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n    ) {\n        var prevIdx = 0;\n        var idx = start;\n        for (var k = 0; k < segLen; k++) {\n            var p = points[idx];\n            if (idx >= allLen || idx < 0) {\n                break;\n            }\n            if (isPointNull(p)) {\n                if (connectNulls) {\n                    idx += dir;\n                    continue;\n                }\n                break;\n            }\n\n            if (idx === start) {\n                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n                v2Copy(cp0, p);\n            }\n            else {\n                if (smooth > 0) {\n                    var nextIdx = idx + dir;\n                    var nextP = points[nextIdx];\n                    if (connectNulls) {\n                        // Find next point not null\n                        while (nextP && isPointNull(points[nextIdx])) {\n                            nextIdx += dir;\n                            nextP = points[nextIdx];\n                        }\n                    }\n\n                    var ratioNextSeg = 0.5;\n                    var prevP = points[prevIdx];\n                    var nextP = points[nextIdx];\n                    // Last point\n                    if (!nextP || isPointNull(nextP)) {\n                        v2Copy(cp1, p);\n                    }\n                    else {\n                        // If next data is null in not connect case\n                        if (isPointNull(nextP) && !connectNulls) {\n                            nextP = p;\n                        }\n\n                        vec2.sub(v, nextP, prevP);\n\n                        var lenPrevSeg;\n                        var lenNextSeg;\n                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n                            var dim = smoothMonotone === 'x' ? 0 : 1;\n                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n                        }\n                        else {\n                            lenPrevSeg = vec2.dist(p, prevP);\n                            lenNextSeg = vec2.dist(p, nextP);\n                        }\n\n                        // Use ratio of seg length\n                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\n                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n                    }\n                    // Smooth constraint\n                    vec2Min(cp0, cp0, smoothMax);\n                    vec2Max(cp0, cp0, smoothMin);\n                    vec2Min(cp1, cp1, smoothMax);\n                    vec2Max(cp1, cp1, smoothMin);\n\n                    ctx.bezierCurveTo(\n                        cp0[0], cp0[1],\n                        cp1[0], cp1[1],\n                        p[0], p[1]\n                    );\n                    // cp0 of next segment\n                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n                }\n                else {\n                    ctx.lineTo(p[0], p[1]);\n                }\n            }\n\n            prevIdx = idx;\n            idx += dir;\n        }\n\n        return k;\n    }\n\n    function getBoundingBox(points, smoothConstraint) {\n        var ptMin = [Infinity, Infinity];\n        var ptMax = [-Infinity, -Infinity];\n        if (smoothConstraint) {\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n            }\n        }\n        return {\n            min: smoothConstraint ? ptMin : ptMax,\n            max: smoothConstraint ? ptMax : ptMin\n        };\n    }\n\n    module.exports = {\n\n        Polyline: Path.extend({\n\n            type: 'ec-polyline',\n\n            shape: {\n                points: [],\n\n                smooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            style: {\n                fill: null,\n\n                stroke: '#000'\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n\n                var i = 0;\n                var len = points.length;\n\n                var result = getBoundingBox(points, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    i += drawSegment(\n                        ctx, points, i, len, len,\n                        1, result.min, result.max, shape.smooth,\n                        shape.smoothMonotone, shape.connectNulls\n                    ) + 1;\n                }\n            }\n        }),\n\n        Polygon: Path.extend({\n\n            type: 'ec-polygon',\n\n            shape: {\n                points: [],\n\n                // Offset between stacked base points and points\n                stackedOnPoints: [],\n\n                smooth: 0,\n\n                stackedOnSmooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n                var stackedOnPoints = shape.stackedOnPoints;\n\n                var i = 0;\n                var len = points.length;\n                var smoothMonotone = shape.smoothMonotone;\n                var bbox = getBoundingBox(points, shape.smoothConstraint);\n                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    var k = drawSegment(\n                        ctx, points, i, len, len,\n                        1, bbox.min, bbox.max, shape.smooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    drawSegment(\n                        ctx, stackedOnPoints, i + k - 1, k, len,\n                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    i += k + 1;\n\n                    ctx.closePath();\n                }\n            }\n        })\n    };\n\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var List = __webpack_require__(20);\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(9);\n    var completeDimensions = __webpack_require__(28);\n\n    var dataSelectableMixin = __webpack_require__(144);\n\n    var PieSeries = __webpack_require__(1).extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this.getData();\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            var sum = data.getSum('value');\n            // FIXME toFixed?\n            //\n            // Percent is 0 if sum is 0\n            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // \n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // \n            clockwise: true,\n            startAngle: 90,\n            // 0\n            minAngle: 0,\n            // \n            selectedOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // singlemultiple\n            // selectedMode: false,\n            // 'radius' | 'area'\n            // roseType: null,\n\n            // If still show when all data zero.\n            stillShowZeroSum: true,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: Tooltip.formatter\n                    // textStyle: null      // TEXTSTYLE\n                    // distance: positioninnerlabel()\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // \n                    length: 15,\n                    // \n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: ,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            // Animation type canbe expansion, scale\n            animationType: 'expansion',\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var graphic = __webpack_require__(2);\n    var zrUtil = __webpack_require__(0);\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n            )\n        };\n    }\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n\n            var animationType = seriesModel.getShallow('animationType');\n            if (animationType === 'scale') {\n                sector.shape.r = layout.r0;\n                graphic.initProps(sector, {\n                    shape: {\n                        r: layout.r\n                    }\n                }, seriesModel, idx);\n            }\n            // Expansion\n            else {\n                sector.shape.endAngle = layout.startAngle;\n                graphic.updateProps(sector, {\n                    shape: {\n                        endAngle: layout.endAngle\n                    }\n                }, seriesModel, idx);\n            }\n\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + 10\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = __webpack_require__(33).extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n            var animationType = seriesModel.get('animationType');\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    // Default expansion animation\n                    if (isFirstRender && animationType !== 'scale') {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (\n                hasAnimation && isFirstRender && data.count() > 0\n                // Default expansion animation\n                && animationType !== 'scale'\n            ) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = __webpack_require__(18);\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // \n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // \n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0                     // \n                : isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0;                    // \n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// TODO minAngle\n\n\n\n    var numberUtil = __webpack_require__(3);\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = __webpack_require__(131);\n    var zrUtil = __webpack_require__(0);\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n            var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                if (isNaN(value)) {\n                    data.setItemLayout(idx, {\n                        angle: NaN,\n                        startAngle: NaN,\n                        endAngle: NaN,\n                        clockwise: clockwise,\n                        cx: cx,\n                        cy: cy,\n                        r0: r0,\n                        r: roseType\n                            ? NaN\n                            : r\n                    });\n                    return;\n                }\n\n                // FIXME  2.0  roseType  area \n                if (roseType !== 'area') {\n                    angle = (sum === 0 && stillShowZeroSum)\n                        ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / (data.count() || 1);\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle\n                            ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += dir * angle;\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var echarts = __webpack_require__(1);\n\n    // Must use radar component\n    __webpack_require__(150);\n\n    __webpack_require__(134);\n    __webpack_require__(135);\n\n    echarts.registerVisual(zrUtil.curry(__webpack_require__(43), 'radar'));\n    echarts.registerVisual(zrUtil.curry(\n        __webpack_require__(44), 'radar', 'circle', null\n    ));\n    echarts.registerLayout(__webpack_require__(137));\n\n    echarts.registerProcessor(\n        zrUtil.curry(__webpack_require__(41), 'radar')\n    );\n\n    echarts.registerPreprocessor(__webpack_require__(136));\n\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var SeriesModel = __webpack_require__(21);\n    var List = __webpack_require__(20);\n    var completeDimensions = __webpack_require__(28);\n    var zrUtil = __webpack_require__(0);\n    var encodeHTML = __webpack_require__(8).encodeHTML;\n\n    var RadarSeries = SeriesModel.extend({\n\n        type: 'series.radar',\n\n        dependencies: ['radar'],\n\n\n        // Overwrite\n        init: function (option) {\n            RadarSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n        },\n\n        getInitialData: function (option, ecModel) {\n            var data = option.data || [];\n            var dimensions = completeDimensions(\n                [], data, [], 'indicator_'\n            );\n            var list = new List(dimensions, this);\n            list.initData(data);\n            return list;\n        },\n\n        formatTooltip: function (dataIndex) {\n            var value = this.getRawValue(dataIndex);\n            var coordSys = this.coordinateSystem;\n            var indicatorAxes = coordSys.getIndicatorAxes();\n            var name = this.getData().getName(dataIndex);\n            return encodeHTML(name === '' ? this.name : name) + '<br/>'\n                + zrUtil.map(indicatorAxes, function (axis, idx) {\n                    return encodeHTML(axis.name + ' : ' + value[idx]);\n                }).join('<br />');\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            coordinateSystem: 'radar',\n            legendHoverLink: true,\n            radarIndex: 0,\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // areaStyle: {\n            // },\n            // itemStyle: {}\n            symbol: 'emptyCircle',\n            symbolSize: 4\n            // symbolRotate: null\n        }\n    });\n\n    module.exports = RadarSeries;\n\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var graphic = __webpack_require__(2);\n    var zrUtil = __webpack_require__(0);\n    var symbolUtil = __webpack_require__(32);\n\n    function normalizeSymbolSize(symbolSize) {\n        if (!zrUtil.isArray(symbolSize)) {\n            symbolSize = [+symbolSize, +symbolSize];\n        }\n        return symbolSize;\n    }\n    module.exports = __webpack_require__(1).extendChartView({\n        type: 'radar',\n\n        render: function (seriesModel, ecModel, api) {\n            var polar = seriesModel.coordinateSystem;\n            var group = this.group;\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            function createSymbol(data, idx) {\n                var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n                var color = data.getItemVisual(idx, 'color');\n                if (symbolType === 'none') {\n                    return;\n                }\n                var symbolPath = symbolUtil.createSymbol(\n                    symbolType, -0.5, -0.5, 1, 1, color\n                );\n                symbolPath.attr({\n                    style: {\n                        strokeNoScale: true\n                    },\n                    z2: 100,\n                    scale: normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))\n                });\n                return symbolPath;\n            }\n\n            function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n                // Simply rerender all\n                symbolGroup.removeAll();\n                for (var i = 0; i < newPoints.length - 1; i++) {\n                    var symbolPath = createSymbol(data, idx);\n                    if (symbolPath) {\n                        symbolPath.__dimIdx = i;\n                        if (oldPoints[i]) {\n                            symbolPath.attr('position', oldPoints[i]);\n                            graphic[isInit ? 'initProps' : 'updateProps'](\n                                symbolPath, {\n                                    position: newPoints[i]\n                                }, seriesModel, idx\n                            );\n                        }\n                        else {\n                            symbolPath.attr('position', newPoints[i]);\n                        }\n                        symbolGroup.add(symbolPath);\n                    }\n                }\n            }\n\n            function getInitialPoints(points) {\n                return zrUtil.map(points, function (pt) {\n                    return [polar.cx, polar.cy];\n                });\n            }\n            data.diff(oldData)\n                .add(function (idx) {\n                    var points = data.getItemLayout(idx);\n                    if (!points) {\n                        return;\n                    }\n                    var polygon = new graphic.Polygon();\n                    var polyline = new graphic.Polyline();\n                    var target = {\n                        shape: {\n                            points: points\n                        }\n                    };\n                    polygon.shape.points = getInitialPoints(points);\n                    polyline.shape.points = getInitialPoints(points);\n                    graphic.initProps(polygon, target, seriesModel, idx);\n                    graphic.initProps(polyline, target, seriesModel, idx);\n\n                    var itemGroup = new graphic.Group();\n                    var symbolGroup = new graphic.Group();\n                    itemGroup.add(polyline);\n                    itemGroup.add(polygon);\n                    itemGroup.add(symbolGroup);\n\n                    updateSymbols(\n                        polyline.shape.points, points, symbolGroup, data, idx, true\n                    );\n\n                    data.setItemGraphicEl(idx, itemGroup);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var itemGroup = oldData.getItemGraphicEl(oldIdx);\n                    var polyline = itemGroup.childAt(0);\n                    var polygon = itemGroup.childAt(1);\n                    var symbolGroup = itemGroup.childAt(2);\n                    var target = {\n                        shape: {\n                            points: data.getItemLayout(newIdx)\n                        }\n                    };\n                    if (!target.shape.points) {\n                        return;\n                    }\n                    updateSymbols(\n                        polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false\n                    );\n\n                    graphic.updateProps(polyline, target, seriesModel);\n                    graphic.updateProps(polygon, target, seriesModel);\n\n                    data.setItemGraphicEl(newIdx, itemGroup);\n                })\n                .remove(function (idx) {\n                    group.remove(oldData.getItemGraphicEl(idx));\n                })\n                .execute();\n\n            data.eachItemGraphicEl(function (itemGroup, idx) {\n                var itemModel = data.getItemModel(idx);\n                var polyline = itemGroup.childAt(0);\n                var polygon = itemGroup.childAt(1);\n                var symbolGroup = itemGroup.childAt(2);\n                var color = data.getItemVisual(idx, 'color');\n\n                group.add(itemGroup);\n\n                polyline.useStyle(\n                    zrUtil.defaults(\n                        itemModel.getModel('lineStyle.normal').getLineStyle(),\n                        {\n                            fill: 'none',\n                            stroke: color\n                        }\n                    )\n                );\n                polyline.hoverStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n                var areaStyleModel = itemModel.getModel('areaStyle.normal');\n                var hoverAreaStyleModel = itemModel.getModel('areaStyle.emphasis');\n                var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n                var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();\n\n                hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;\n                polygon.ignore = polygonIgnore;\n\n                polygon.useStyle(\n                    zrUtil.defaults(\n                        areaStyleModel.getAreaStyle(),\n                        {\n                            fill: color,\n                            opacity: 0.7\n                        }\n                    )\n                );\n                polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();\n\n                var itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);\n                var itemHoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();\n                var labelModel = itemModel.getModel('label.normal');\n                var labelHoverModel = itemModel.getModel('label.emphasis');\n                symbolGroup.eachChild(function (symbolPath) {\n                    symbolPath.setStyle(itemStyle);\n                    symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);\n\n                    var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);\n                    graphic.setText(symbolPath.style, labelModel, color);\n                    symbolPath.setStyle({\n                        text: labelModel.get('show') ? zrUtil.retrieve(\n                            seriesModel.getFormattedLabel(\n                                idx, 'normal', null, symbolPath.__dimIdx\n                            ),\n                            defaultText\n                        ) : ''\n                    });\n\n                    graphic.setText(symbolPath.hoverStyle, labelHoverModel, color);\n                    symbolPath.hoverStyle.text = labelHoverModel.get('show') ? zrUtil.retrieve(\n                        seriesModel.getFormattedLabel(\n                            idx, 'emphasis', null, symbolPath.__dimIdx\n                        ),\n                        defaultText\n                    ) : '';\n                });\n\n                function onEmphasis() {\n                    polygon.attr('ignore', hoverPolygonIgnore);\n                }\n\n                function onNormal() {\n                    polygon.attr('ignore', polygonIgnore);\n                }\n\n                itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');\n                itemGroup.on('emphasis', onEmphasis)\n                    .on('mouseover', onEmphasis)\n                    .on('normal', onNormal)\n                    .on('mouseout', onNormal);\n\n                graphic.setHoverStyle(itemGroup);\n            });\n\n            this._data = data;\n        },\n\n        remove: function () {\n            this.group.removeAll();\n            this._data = null;\n        },\n\n        dispose: function () {}\n    });\n\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Backward compat for radar chart in 2\n\n\n    var zrUtil = __webpack_require__(0);\n\n    module.exports = function (option) {\n        var polarOptArr = option.polar;\n        if (polarOptArr) {\n            if (!zrUtil.isArray(polarOptArr)) {\n                polarOptArr = [polarOptArr];\n            }\n            var polarNotRadar = [];\n            zrUtil.each(polarOptArr, function (polarOpt, idx) {\n                if (polarOpt.indicator) {\n                    if (polarOpt.type && !polarOpt.shape) {\n                        polarOpt.shape = polarOpt.type;\n                    }\n                    option.radar = option.radar || [];\n                    if (!zrUtil.isArray(option.radar)) {\n                        option.radar = [option.radar];\n                    }\n                    option.radar.push(polarOpt);\n                }\n                else {\n                    polarNotRadar.push(polarOpt);\n                }\n            });\n            option.polar = polarNotRadar;\n        }\n        zrUtil.each(option.series, function (seriesOpt) {\n            if (seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n                seriesOpt.radarIndex = seriesOpt.polarIndex;\n            }\n        });\n    };\n\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = function (ecModel) {\n        ecModel.eachSeriesByType('radar', function (seriesModel) {\n            var data = seriesModel.getData();\n            var points = [];\n            var coordSys = seriesModel.coordinateSystem;\n            if (!coordSys) {\n                return;\n            }\n\n            function pointsConverter(val, idx) {\n                points[idx] = points[idx] || [];\n                points[idx][i] = coordSys.dataToPoint(val, i);\n            }\n            for (var i = 0; i < coordSys.getIndicatorAxes().length; i++) {\n                var dim = data.dimensions[i];\n                data.each(dim, pointsConverter);\n            }\n\n            data.each(function (idx) {\n                // Close polygon\n                points[idx][0] && points[idx].push(points[idx][0].slice());\n                data.setItemLayout(idx, points[idx]);\n            });\n        });\n    };\n\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var echarts = __webpack_require__(1);\n\n    __webpack_require__(139);\n    __webpack_require__(140);\n\n    echarts.registerVisual(zrUtil.curry(\n        __webpack_require__(44), 'scatter', 'circle', null\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        __webpack_require__(61), 'scatter'\n    ));\n\n    // In case developer forget to include grid component\n    __webpack_require__(40);\n\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var createListFromArray = __webpack_require__(39);\n    var SeriesModel = __webpack_require__(21);\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.scatter',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            var list = createListFromArray(option.data, this, ecModel);\n            return list;\n        },\n\n        brushSelector: 'point',\n\n        defaultOption: {\n            coordinateSystem: 'cartesian2d',\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // Polar coordinate system\n            // polarIndex: 0,\n\n            // Geo coordinate system\n            // geoIndex: 0,\n\n            // symbol: null,        // \n            symbolSize: 10,          // symbolSize * 2\n            // symbolRotate: null,  // \n\n            large: false,\n            // Available when large is true\n            largeThreshold: 2000,\n\n            // label: {\n                // normal: {\n                    // show: false\n                    // distance: 5,\n                    // formatter: Tooltip.formatter\n                    // position: 'top''right'\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // TEXTSTYLE\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    opacity: 0.8\n                    // color: \n                }\n            }\n        }\n\n    });\n\n\n/***/ }),\n/* 140 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var SymbolDraw = __webpack_require__(53);\n    var LargeSymbolDraw = __webpack_require__(123);\n\n    __webpack_require__(1).extendChartView({\n\n        type: 'scatter',\n\n        init: function () {\n            this._normalSymbolDraw = new SymbolDraw();\n            this._largeSymbolDraw = new LargeSymbolDraw();\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var data = seriesModel.getData();\n            var largeSymbolDraw = this._largeSymbolDraw;\n            var normalSymbolDraw = this._normalSymbolDraw;\n            var group = this.group;\n\n            var symbolDraw = seriesModel.get('large') && data.count() > seriesModel.get('largeThreshold')\n                ? largeSymbolDraw : normalSymbolDraw;\n\n            this._symbolDraw = symbolDraw;\n            symbolDraw.updateData(data);\n            group.add(symbolDraw.group);\n\n            group.remove(\n                symbolDraw === largeSymbolDraw\n                ? normalSymbolDraw.group : largeSymbolDraw.group\n            );\n        },\n\n        updateLayout: function (seriesModel) {\n            this._symbolDraw.updateLayout(seriesModel);\n        },\n\n        remove: function (ecModel, api) {\n            this._symbolDraw && this._symbolDraw.remove(api, true);\n        },\n\n        dispose: function () {}\n    });\n\n\n/***/ }),\n/* 141 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// TODO boundaryGap\n\n\n    __webpack_require__(59);\n\n    __webpack_require__(142);\n\n\n/***/ }),\n/* 142 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n    var AxisBuilder = __webpack_require__(55);\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var AxisView = __webpack_require__(1).extendComponentView({\n\n        type: 'axis',\n\n        render: function (axisModel, ecModel) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.getCoordSysModel();\n\n            var layout = layoutAxis(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.isBlank()) {\n                return;\n            }\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.isBlank()) {\n                return;\n            }\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    AxisView.extend({\n        type: 'xAxis'\n    });\n    AxisView.extend({\n        type: 'yAxis'\n    });\n\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    }\n\n\n/***/ }),\n/* 143 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    // List layout\n    var layout = __webpack_require__(17);\n    var formatUtil = __webpack_require__(8);\n    var graphic = __webpack_require__(2);\n\n    function positionGroup(group, model, api) {\n        layout.positionElement(\n            group, model.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            model.get('padding')\n        );\n    }\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, componentModel.get('padding'));\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            positionGroup(group, componentModel, api);\n        },\n\n        addBackground: function (group, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var boundingRect = group.getBoundingRect();\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: boundingRect.x - padding[3],\n                    y: boundingRect.y - padding[0],\n                    width: boundingRect.width + padding[1] + padding[3],\n                    height: boundingRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    };\n\n\n/***/ }),\n/* 144 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = __webpack_require__(0);\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        /**\n         * @param {string} name\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n\n\n/***/ }),\n/* 145 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Legend component entry file8\n */\n\n\n    __webpack_require__(146);\n    __webpack_require__(148);\n    __webpack_require__(147);\n\n    var echarts = __webpack_require__(1);\n    // Series Filter\n    echarts.registerProcessor(__webpack_require__(149));\n\n\n/***/ }),\n/* 146 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var Model = __webpack_require__(10);\n\n    var LegendModel = __webpack_require__(1).extendComponentModel({\n\n        type: 'legend',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 4,\n            show: true,\n\n            // \n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 'top',\n            // bottom: 'top',\n\n            // \n            // 'auto' | 'left' | 'right'\n            //  'auto',  x \n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // \n            borderColor: '#ccc',\n            // px0\n            borderWidth: 0,\n            // px5\n            // css\n            padding: 5,\n            // itempx10\n            // \n            itemGap: 10,\n            // \n            itemWidth: 25,\n            // \n            itemHeight: 14,\n\n            // \n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // \n                color: '#333'\n            },\n            // formatter: '',\n            // \n            selectedMode: true,\n            // LEGEND.SELECTED\n            // selected: null,\n            // legend.dataitem\n            // data: [],\n\n            // Tooltip \n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n\n/***/ }),\n/* 147 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var symbolCreator = __webpack_require__(32);\n    var graphic = __webpack_require__(2);\n    var listComponentHelper = __webpack_require__(143);\n\n    var curry = zrUtil.curry;\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    module.exports = __webpack_require__(1).extendComponentView({\n\n        type: 'legend',\n\n        init: function () {\n            this._symbolTypeStore = {};\n        },\n\n        render: function (legendModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!legendModel.get('show')) {\n                return;\n            }\n\n            var selectMode = legendModel.get('selectedMode');\n            var itemAlign = legendModel.get('align');\n\n            if (itemAlign === 'auto') {\n                itemAlign = (legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical')\n                    ? 'right' : 'left';\n            }\n\n            var legendDrawedMap = {};\n\n            zrUtil.each(legendModel.getData(), function (itemModel) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (name === '' || name === '\\n') {\n                    group.add(new graphic.Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawedMap[name]) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawedMap[name] = true;\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawedMap[name]) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawedMap[name] = true;\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawedMap[name]) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n\n            listComponentHelper.layout(group, legendModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, legendModel);\n        },\n\n        _createItem: function (\n            name, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new graphic.Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            // Text\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name != null ? name : '');\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            var text = new graphic.Text({\n                style: {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textFont: textStyleModel.getFont(),\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                }\n            });\n            itemGroup.add(text);\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n\n\n            this.group.add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            return itemGroup;\n        }\n    });\n\n\n/***/ }),\n/* 148 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @file Legend action\n */\n\n\n    var echarts = __webpack_require__(1);\n    var zrUtil = __webpack_require__(0);\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (name in selectedMap) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n\n/***/ }),\n/* 149 */\n/***/ (function(module, exports) {\n\n\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n\n/***/ }),\n/* 150 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    __webpack_require__(164);\n    __webpack_require__(165);\n\n    __webpack_require__(151);\n\n\n/***/ }),\n/* 151 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var AxisBuilder = __webpack_require__(55);\n    var zrUtil = __webpack_require__(0);\n    var graphic = __webpack_require__(2);\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n\n    module.exports = __webpack_require__(1).extendComponentView({\n\n        type: 'radar',\n\n        render: function (radarModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            this._buildAxes(radarModel);\n            this._buildSplitLineAndArea(radarModel);\n        },\n\n        _buildAxes: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {\n                var axisBuilder = new AxisBuilder(indicatorAxis.model, {\n                    position: [radar.cx, radar.cy],\n                    rotation: indicatorAxis.angle,\n                    labelDirection: -1,\n                    tickDirection: -1,\n                    nameDirection: 1\n                });\n                return axisBuilder;\n            });\n\n            zrUtil.each(axisBuilders, function (axisBuilder) {\n                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n                this.group.add(axisBuilder.getGroup());\n            }, this);\n        },\n\n        _buildSplitLineAndArea: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            if (!indicatorAxes.length) {\n                return;\n            }\n            var shape = radarModel.get('shape');\n            var splitLineModel = radarModel.getModel('splitLine');\n            var splitAreaModel = radarModel.getModel('splitArea');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\n            var showSplitLine = splitLineModel.get('show');\n            var showSplitArea = splitAreaModel.get('show');\n            var splitLineColors = lineStyleModel.get('color');\n            var splitAreaColors = areaStyleModel.get('color');\n\n            splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n            splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n\n            var splitLines = [];\n            var splitAreas = [];\n\n            function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n                var colorIndex = idx % areaOrLineColorList.length;\n                areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n                return colorIndex;\n            }\n\n            if (shape === 'circle') {\n                var ticksRadius = indicatorAxes[0].getTicksCoords();\n                var cx = radar.cx;\n                var cy = radar.cy;\n                for (var i = 0; i < ticksRadius.length; i++) {\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Circle({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r: ticksRadius[i]\n                            }\n                        }));\n                    }\n                    if (showSplitArea && i < ticksRadius.length - 1) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);\n                        splitAreas[colorIndex].push(new graphic.Ring({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r0: ticksRadius[i],\n                                r: ticksRadius[i + 1]\n                            }\n                        }));\n                    }\n                }\n            }\n            // Polyyon\n            else {\n                var realSplitNumber = -1;\n                var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {\n                    var ticksCoords = indicatorAxis.getTicksCoords();\n                    realSplitNumber = Math.max(ticksCoords.length - 1, realSplitNumber);\n                    return zrUtil.map(ticksCoords, function (tickCoord) {\n                        return radar.coordToPoint(tickCoord, idx);\n                    });\n                });\n\n                var prevPoints = [];\n                for (var i = 0; i <= realSplitNumber; i++) {\n                    var points = [];\n                    for (var j = 0; j < indicatorAxes.length; j++) {\n                        points.push(axesTicksPoints[j][i]);\n                    }\n                    // Close\n                    if (points[0]) {\n                        points.push(points[0].slice());\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.error('Can\\'t draw value axis ' + i);\n                        }\n                    }\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Polyline({\n                            shape: {\n                                points: points\n                            }\n                        }));\n                    }\n                    if (showSplitArea && prevPoints) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);\n                        splitAreas[colorIndex].push(new graphic.Polygon({\n                            shape: {\n                                points: points.concat(prevPoints)\n                            }\n                        }));\n                    }\n                    prevPoints = points.slice().reverse();\n                }\n            }\n\n            var lineStyle = lineStyleModel.getLineStyle();\n            var areaStyle = areaStyleModel.getAreaStyle();\n            // Add splitArea before splitLine\n            zrUtil.each(splitAreas, function (splitAreas, idx) {\n                this.group.add(graphic.mergePath(\n                    splitAreas, {\n                        style: zrUtil.defaults({\n                            stroke: 'none',\n                            fill: splitAreaColors[idx % splitAreaColors.length]\n                        }, areaStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n            zrUtil.each(splitLines, function (splitLines, idx) {\n                this.group.add(graphic.mergePath(\n                    splitLines, {\n                        style: zrUtil.defaults({\n                            fill: 'none',\n                            stroke: splitLineColors[idx % splitLineColors.length]\n                        }, lineStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n        }\n    });\n\n\n/***/ }),\n/* 152 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var echarts = __webpack_require__(1);\n    var graphic = __webpack_require__(2);\n    var layout = __webpack_require__(17);\n\n    // Model\n    echarts.extendComponentModel({\n\n        type: 'title',\n\n        layoutMode: {type: 'box', ignoreSize: true},\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 6,\n            show: true,\n\n            text: '',\n            // \n            // link: null,\n            // self | blank\n            target: 'blank',\n            subtext: '',\n\n            // \n            // sublink: null,\n            // self | blank\n            subtarget: 'blank',\n\n            // 'center'  'left'  'right'\n            //  {number}xpx\n            left: 0,\n            // 'top'  'bottom'  'center'\n            //  {number}ypx\n            top: 0,\n\n            // \n            // 'auto' | 'left' | 'right' | 'center'\n            //  left \n            // textAlign: null\n            //\n            // \n            // 'auto' | 'top' | 'bottom' | 'middle'\n            //  top \n            // textBaseline: null\n\n            backgroundColor: 'rgba(0,0,0,0)',\n\n            // \n            borderColor: '#ccc',\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // px10\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: {\n                color: '#aaa'\n            }\n        }\n    });\n\n    // View\n    echarts.extendComponentView({\n\n        type: 'title',\n\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n\n            if (!titleModel.get('show')) {\n                return;\n            }\n\n            var group = this.group;\n\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n\n            var textEl = new graphic.Text({\n                style: {\n                    text: titleModel.get('text'),\n                    textFont: textStyleModel.getFont(),\n                    fill: textStyleModel.getTextColor()\n                },\n                z2: 10\n            });\n\n            var textRect = textEl.getBoundingRect();\n\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                style: {\n                    text: subText,\n                    textFont: subtextStyleModel.getFont(),\n                    fill: subtextStyleModel.getTextColor(),\n                    y: textRect.height + titleModel.get('itemGap'),\n                    textBaseline: 'top'\n                },\n                z2: 10\n            });\n\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(\n                layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding')\n            );\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                }\n                else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                }\n                else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n\n                textBaseline = textBaseline || 'top';\n            }\n\n            group.attr('position', [layoutRect.x, layoutRect.y]);\n            var alignStyle = {\n                textAlign: textAlign,\n                textVerticalAlign: textBaseline\n            };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle(['color', 'opacity']);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: groupRect.x - padding[3],\n                    y: groupRect.y - padding[0],\n                    width: groupRect.width + padding[1] + padding[3],\n                    height: groupRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    });\n\n\n/***/ }),\n/* 153 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// FIXME Better way to pack data in graphic element\n\n\n    __webpack_require__(155);\n\n    __webpack_require__(156);\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    __webpack_require__(1).registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    __webpack_require__(1).registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n\n\n/***/ }),\n/* 154 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var zrColor = __webpack_require__(25);\n    var eventUtil = __webpack_require__(37);\n    var formatUtil = __webpack_require__(8);\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = __webpack_require__(11);\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        tooltipModel = tooltipModel;\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self.enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self.enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self.enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            var el = this.el;\n            el.innerHTML = content;\n            el.style.display = content ? 'block' : 'none';\n        },\n\n        moveTo: function (x, y) {\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        // showLater: function ()\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this.enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n\n/***/ }),\n/* 155 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    __webpack_require__(1).extendComponentModel({\n\n        type: 'tooltip',\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip\n            showContent: true,\n\n            // 'item'  'axis'\n            trigger: 'item',\n\n            //  'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove',\n\n            //  content\n            alwaysShowContent: false,\n\n            //  {Array} | {Function}\n            // position: null\n\n            //  content  viewRect  false \n            confine: false,\n\n            // {string}Template  {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // ms\n            hideDelay: 100,\n\n            // s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 0.7\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // \n            borderColor: '#333',\n\n            // px4\n            borderRadius: 4,\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // \n            axisPointer: {\n                // \n                // 'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type  line  tooltip line \n                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n                //  'auto' cateogry  x \n                //  angle \n                axis: 'auto',\n\n                animation: true,\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                // \n                lineStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'solid'\n                },\n\n                crossStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                },\n\n                // \n                shadowStyle: {\n                    color: 'rgba(150,150,150,0.3)'\n                }\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n\n/***/ }),\n/* 156 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var TooltipContent = __webpack_require__(154);\n    var graphic = __webpack_require__(2);\n    var zrUtil = __webpack_require__(0);\n    var formatUtil = __webpack_require__(8);\n    var numberUtil = __webpack_require__(3);\n    var modelUtil = __webpack_require__(9);\n    var parsePercent = numberUtil.parsePercent;\n    var env = __webpack_require__(11);\n    var Model = __webpack_require__(10);\n\n    function dataEqual(a, b) {\n        if (!a || !b) {\n            return false;\n        }\n        var round = numberUtil.round;\n        return round(a[0]) === round(b[0])\n            && round(a[1]) === round(b[1]);\n    }\n    /**\n     * @inner\n     */\n    function makeLineShape(x1, y1, x2, y2) {\n        return {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeRectShape(x, y, width, height) {\n        return {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n        var gap = 20;\n\n        if (x + width + gap > viewWidth) {\n            x -= width + gap;\n        }\n        else {\n            x += gap;\n        }\n        if (y + height + gap > viewHeight) {\n            y -= height + gap;\n        }\n        else {\n            y += gap;\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, dom) {\n        var domWidth = dom.clientWidth;\n        var domHeight = dom.clientHeight;\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    /**\n     * @param  {string|Function|Array.<number>} positionExpr\n     * @param  {number} x Mouse x\n     * @param  {number} y Mouse y\n     * @param  {boolean} confine Whether confine tooltip content in view rect.\n     * @param  {module:echarts/component/tooltip/TooltipContent} content\n     * @param  {Object|<Array.<Object>} params\n     * @param  {module:zrender/Element} el target element\n     * @param  {module:echarts/ExtensionAPI} api\n     * @return {Array.<number>}\n     */\n    function updatePosition(positionExpr, x, y, confine, content, params, el, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n\n        var rect = el && el.getBoundingRect().clone();\n        el && rect.applyTransform(el.transform);\n        if (typeof positionExpr === 'function') {\n            // Callback of position can be an array or a string specify the position\n            positionExpr = positionExpr([x, y], params, content.el, rect);\n        }\n\n        if (zrUtil.isArray(positionExpr)) {\n            x = parsePercent(positionExpr[0], viewWidth);\n            y = parsePercent(positionExpr[1], viewHeight);\n        }\n        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n        else if (typeof positionExpr === 'string' && el) {\n            var pos = calcTooltipPosition(\n                positionExpr, rect, content.el\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n        else {\n            var pos = refixTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        if (confine) {\n            var pos = confineTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        content.moveTo(x, y);\n    }\n\n    function ifSeriesSupportAxisTrigger(seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var trigger = seriesModel.get('tooltip.trigger', true);\n        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n        return !(!coordSys\n            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n            || trigger === 'item');\n    }\n\n    __webpack_require__(1).extendComponentView({\n\n        type: 'tooltip',\n\n        _axisPointers: {},\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._axisPointers = {};\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._lastHover = {\n                // data\n                // payloadBatch\n            };\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.enterable = tooltipModel.get('enterable');\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            /**\n             * @type {Object.<string, Array>}\n             */\n            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n                tooltipModel, ecModel\n            );\n\n            var crossText = this._crossText;\n            if (crossText) {\n                this.group.add(crossText);\n            }\n\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && triggerOn !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n\n            var zr = this._api.getZr();\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n\n            if (triggerOn === 'click') {\n                zr.on('click', this._tryShow, this);\n            }\n            else if (triggerOn === 'mousemove') {\n                zr.on('mousemove', this._mousemove, this);\n                zr.on('mouseout', this._hide, this);\n                zr.on('globalout', this._hide, this);\n            }\n            // else triggerOn is 'none', which enable user\n            // to control tooltip totally using API.\n        },\n\n        _mousemove: function (e) {\n            var showDelay = this._tooltipModel.get('showDelay');\n            var self = this;\n            clearTimeout(this._showTimeout);\n            if (showDelay > 0) {\n                this._showTimeout = setTimeout(function () {\n                    self._tryShow(e);\n                }, showDelay);\n            }\n            else {\n                this._tryShow(e);\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            // From self\n            if (payload.from === this.uid) {\n                return;\n            }\n\n            var ecModel = this._ecModel;\n            var seriesIndex = payload.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            var api = this._api;\n\n            var isTriggerAxis = this._tooltipModel.get('trigger') === 'axis';\n            function seriesHaveDataOnIndex(_series) {\n                var data = _series.getData();\n                var dataIndex = modelUtil.queryDataIndex(data, payload);\n                // Have single dataIndex\n                if (dataIndex != null && !zrUtil.isArray(dataIndex)\n                    && data.hasValue(dataIndex)\n                ) {\n                    return true;\n                }\n            }\n\n            if (payload.x == null || payload.y == null) {\n                if (isTriggerAxis) {\n                    // Find another series.\n                    if (seriesModel && !seriesHaveDataOnIndex(seriesModel)) {\n                        seriesModel = null;\n                    }\n                    if (!seriesModel) {\n                        // Find the first series can use axis trigger And data is not null\n                        ecModel.eachSeries(function (_series) {\n                            if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n                                if (seriesHaveDataOnIndex(_series)) {\n                                    seriesModel = _series;\n                                }\n                            }\n                        });\n                    }\n                }\n                else {\n                    // Use the first series by default.\n                    seriesModel = seriesModel || ecModel.getSeriesByIndex(0);\n                }\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n                        return;\n                    }\n\n                    var el = data.getItemGraphicEl(dataIndex);\n                    var cx;\n                    var cy;\n                    // Try to get the point in coordinate system\n                    var coordSys = seriesModel.coordinateSystem;\n                    if (seriesModel.getTooltipPosition) {\n                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n                        cx = point[0];\n                        cy = point[1];\n                    }\n                    else if (coordSys && coordSys.dataToPoint) {\n                        var point = coordSys.dataToPoint(\n                            data.getValues(\n                                zrUtil.map(coordSys.dimensions, function (dim) {\n                                    return seriesModel.coordDimToDataDim(dim)[0];\n                                }), dataIndex, true\n                            )\n                        );\n                        cx = point && point[0];\n                        cy = point && point[1];\n                    }\n                    else if (el) {\n                        // Use graphic bounding rect\n                        var rect = el.getBoundingRect().clone();\n                        rect.applyTransform(el.transform);\n                        cx = rect.x + rect.width / 2;\n                        cy = rect.y + rect.height / 2;\n                    }\n\n                    if (cx != null && cy != null) {\n                        this._tryShow({\n                            offsetX: cx,\n                            offsetY: cy,\n                            position: payload.position,\n                            target: el,\n                            event: {}\n                        });\n                    }\n                }\n            }\n            else {\n                var el = api.getZr().handler.findHover(payload.x, payload.y);\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: el,\n                    event: {}\n                });\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid) {\n                return;\n            }\n\n            this._hide();\n        },\n\n        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n            // Prepare data for axis trigger\n            var seriesGroupByAxis = {};\n            ecModel.eachSeries(function (seriesModel) {\n                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n                    var coordSys = seriesModel.coordinateSystem;\n                    var baseAxis;\n                    var key;\n\n                    // Only cartesian2d, polar and single support axis trigger\n                    if (coordSys.type === 'cartesian2d') {\n                        // FIXME `axisPointer.axis` is not baseAxis\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + baseAxis.index;\n                    }\n                    else if (coordSys.type === 'singleAxis') {\n                        baseAxis = coordSys.getAxis();\n                        key = baseAxis.dim + baseAxis.type;\n                    }\n                    else {\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + coordSys.name;\n                    }\n\n                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n                        coordSys: [],\n                        series: []\n                    };\n                    seriesGroupByAxis[key].coordSys.push(coordSys);\n                    seriesGroupByAxis[key].series.push(seriesModel);\n                }\n            }, this);\n\n            return seriesGroupByAxis;\n        },\n\n        /**\n         * mousemove handler\n         * @param {Object} e\n         * @private\n         */\n        _tryShow: function (e) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n            var globalTrigger = tooltipModel.get('trigger');\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            // Always show item tooltip if mouse is on the element with dataIndex\n            if (el && el.dataIndex != null) {\n                // Use dataModel in element if possible\n                // Used when mouseover on a element like markPoint or edge\n                // In which case, the data is not main data in series.\n                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                var dataIndex = el.dataIndex;\n                var data = dataModel.getData();\n                var itemModel = data.getItemModel(dataIndex);\n                // Series or single data may use item trigger when global is axis trigger\n                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n                else {\n                    // Reset ticket\n                    this._ticket = '';\n                    // If either single data or series use item trigger\n                    this._hideAxisPointer();\n                    // Reset last hover and dispatch downplay action\n                    this._resetLastHover();\n\n                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n                }\n\n                api.dispatchAction({\n                    type: 'showTip',\n                    from: this.uid,\n                    dataIndexInside: dataIndex,\n                    dataIndex: data.getRawIndex(dataIndex), // expose to user.\n                    seriesIndex: el.seriesIndex\n                });\n            }\n            // Tooltip provided directly. Like legend\n            else if (el && el.tooltip) {\n                var tooltipOpt = el.tooltip;\n                if (typeof tooltipOpt === 'string') {\n                    var content = tooltipOpt;\n                    tooltipOpt = {\n                        content: content,\n                        // Fixed formatter\n                        formatter: content\n                    };\n                }\n                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n                var defaultHtml = subTooltipModel.get('content');\n                var asyncTicket = Math.random();\n                this._showTooltipContent(\n                    // TODO params\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n                );\n            }\n            else {\n                if (globalTrigger === 'item') {\n                    this._hide();\n                }\n                else {\n                    // Try show axis tooltip\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n\n                // Action of cross pointer\n                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n                if (tooltipModel.get('axisPointer.type') === 'cross') {\n                    api.dispatchAction({\n                        type: 'showTip',\n                        from: this.uid,\n                        x: e.offsetX,\n                        y: e.offsetY\n                    });\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on axis\n         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} e\n         * @private\n         */\n        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n            var axisPointerModel = tooltipModel.getModel('axisPointer');\n            var axisPointerType = axisPointerModel.get('type');\n\n            if (axisPointerType === 'cross') {\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n                    var dataIndex = el.dataIndex;\n                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n                }\n            }\n\n            this._showAxisPointer();\n            var allNotShow = true;\n            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n                // Try show the axis pointer\n                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n                var coordSys = allCoordSys[0];\n\n                // If mouse position is not in the grid or polar\n                var point = [e.offsetX, e.offsetY];\n\n                if (!coordSys.containPoint(point)) {\n                    // Hide axis pointer\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                allNotShow = false;\n                // Make sure point is discrete on cateogry axis\n                var dimensions = coordSys.dimensions;\n                var value = coordSys.pointToData(point, true);\n                point = coordSys.dataToPoint(value);\n\n                var baseAxis = coordSys.getBaseAxis();\n                var axisType = axisPointerModel.get('axis');\n                if (axisType === 'auto') {\n                    axisType = baseAxis.dim;\n                }\n\n                if (baseAxis.isBlank() || zrUtil.eqNaN(point[0]) || zrUtil.eqNaN(point[1])) {\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                var contentNotChange = false;\n                var lastHover = this._lastHover;\n                if (axisPointerType === 'cross') {\n                    // If hover data not changed\n                    // Possible when two axes are all category\n                    if (dataEqual(lastHover.data, value)) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value;\n                }\n                else {\n                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\n                    // If hover data not changed on the axis dimension\n                    if (lastHover.data === value[valIndex]) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value[valIndex];\n                }\n\n                var enableAnimation = tooltipModel.get('animation');\n\n                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n                    this._showCartesianPointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n                else if (coordSys.type === 'polar' && !contentNotChange) {\n                    this._showPolarPointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n                    this._showSinglePointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n\n                if (axisPointerType !== 'cross') {\n                    this._dispatchAndShowSeriesTooltipContent(\n                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n                    );\n                }\n            }, this);\n\n            if (!this._tooltipModel.get('show')) {\n                this._hideAxisPointer();\n            }\n\n            if (allNotShow) {\n                this._hide();\n            }\n        },\n\n        /**\n         * Show tooltip on axis of cartesian coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         * @private\n         */\n        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point, enableAnimation) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n            var baseAxis = cartesian.getBaseAxis();\n            var moveAnimation = enableAnimation\n                && axisPointerType !== 'cross'\n                && baseAxis.type === 'category'\n                && baseAxis.getBandWidth() > 20;\n\n            if (axisPointerType === 'cross') {\n                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\n                this._updateCrossText(cartesian, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n                var otherExtent = otherAxis.getGlobalExtent();\n\n                if (cartesian.type === 'cartesian2d') {\n                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n                        axisType, point, otherExtent\n                    );\n                }\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridLine(axisType, point, otherExtent) {\n                var targetShape = axisType === 'x'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                graphic.subPixelOptimizeLine({\n                    shape: targetShape,\n                    style: pointerEl.style\n                });\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridShadow(axisType, point, otherExtent) {\n                var axis = cartesian.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n                var span = otherExtent[1] - otherExtent[0];\n                var targetShape = axisType === 'x'\n                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _showSinglePointer: function (axisPointerModel, single, axisType, point, enableAnimation) {\n            var self = this;\n            var axisPointerType = axisPointerModel.get('type');\n            var moveAnimation =\n                enableAnimation\n                && axisPointerType !== 'cross'\n                && single.getBaseAxis().type === 'category';\n            var rect = single.getRect();\n            var otherExtent = [rect.y, rect.y + rect.height];\n\n            moveSingleLine(axisType, point, otherExtent);\n\n            /**\n             * @inner\n             */\n            function moveSingleLine(axisType, point, otherExtent) {\n                var axis = single.getAxis();\n                var orient = axis.orient;\n\n                var targetShape = orient === 'horizontal'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    single, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n        },\n\n        /**\n         * Show tooltip on axis of polar coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         */\n        _showPolarPointer: function (axisPointerModel, polar, axisType, point, enableAnimation) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n\n            var angleAxis = polar.getAngleAxis();\n            var radiusAxis = polar.getRadiusAxis();\n\n            var moveAnimation = enableAnimation\n                && axisPointerType !== 'cross'\n                && polar.getBaseAxis().type === 'category';\n\n            if (axisPointerType === 'cross') {\n                movePolarLine('angle', point, radiusAxis.getExtent());\n                movePolarLine('radius', point, angleAxis.getExtent());\n\n                this._updateCrossText(polar, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n                var otherExtent = otherAxis.getExtent();\n\n                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n                    axisType, point, otherExtent\n                );\n            }\n            /**\n             * @inner\n             */\n            function movePolarLine(axisType, point, otherExtent) {\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                if (axisType === 'angle') {\n                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n                }\n                else {\n                    targetShape = {\n                        cx: polar.cx,\n                        cy: polar.cy,\n                        r: mouseCoord[0]\n                    };\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function movePolarShadow(axisType, point, otherExtent) {\n                var axis = polar.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                var radian = Math.PI / 180;\n\n                if (axisType === 'angle') {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        otherExtent[0], otherExtent[1],\n                        // In ECharts y is negative if angle is positive\n                        (-mouseCoord[1] - bandWidth / 2) * radian,\n                        (-mouseCoord[1] + bandWidth / 2) * radian\n                    );\n                }\n                else {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        mouseCoord[0] - bandWidth / 2,\n                        mouseCoord[0] + bandWidth / 2,\n                        0, Math.PI * 2\n                    );\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _updateCrossText: function (coordSys, point, axisPointerModel) {\n            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n            var textStyleModel = crossStyleModel.getModel('textStyle');\n\n            var tooltipModel = this._tooltipModel;\n\n            var text = this._crossText;\n            if (!text) {\n                text = this._crossText = new graphic.Text({\n                    style: {\n                        textAlign: 'left',\n                        textVerticalAlign: 'bottom'\n                    }\n                });\n                this.group.add(text);\n            }\n\n            var value = coordSys.pointToData(point);\n\n            var dims = coordSys.dimensions;\n            value = zrUtil.map(value, function (val, idx) {\n                var axis = coordSys.getAxis(dims[idx]);\n                if (axis.type === 'category' || axis.type === 'time') {\n                    val = axis.scale.getLabel(val);\n                }\n                else {\n                    val = formatUtil.addCommas(\n                        val.toFixed(axis.getPixelPrecision())\n                    );\n                }\n                return val;\n            });\n\n            text.setStyle({\n                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n                textFont: textStyleModel.getFont(),\n                text: value.join(', '),\n                x: point[0] + 5,\n                y: point[1] - 5\n            });\n            text.z = tooltipModel.get('z');\n            text.zlevel = tooltipModel.get('zlevel');\n        },\n\n        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n            var tooltipModel = this._tooltipModel;\n            var z = tooltipModel.get('z');\n            var zlevel = tooltipModel.get('zlevel');\n            var axisPointers = this._axisPointers;\n            var coordSysName = coordSys.name;\n            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n            if (axisPointers[coordSysName][axisType]) {\n                return axisPointers[coordSysName][axisType];\n            }\n\n            // Create if not exists\n            var pointerType = pointerModel.get('type');\n            var styleModel = pointerModel.getModel(pointerType + 'Style');\n            var isShadow = pointerType === 'shadow';\n            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\n            var elementType = coordSys.type === 'polar'\n                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n                : (isShadow ? 'Rect' : 'Line');\n\n            isShadow ? (style.stroke = null) : (style.fill = null);\n\n            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n                style: style,\n                z: z,\n                zlevel: zlevel,\n                silent: true,\n                shape: initShape\n            });\n\n            this.group.add(el);\n            return el;\n        },\n\n        /**\n         * Dispatch actions and show tooltip on series\n         * @param {Array.<module:echarts/model/Series>} seriesList\n         * @param {Array.<number>} point\n         * @param {Array.<number>} value\n         * @param {boolean} contentNotChange\n         * @param {Array.<number>|string|Function} [positionExpr]\n         */\n        _dispatchAndShowSeriesTooltipContent: function (\n            coordSys, seriesList, point, value, contentNotChange, positionExpr\n        ) {\n\n            var rootTooltipModel = this._tooltipModel;\n\n            var baseAxis = coordSys.getBaseAxis();\n            var baseDimIndex = ({x: 1, radius: 1, single: 1})[baseAxis.dim] ? 0 : 1;\n\n            if (!seriesList.length) {\n                return;\n            }\n\n            var payloadBatch = zrUtil.map(seriesList, function (series) {\n                return {\n                    seriesIndex: series.seriesIndex,\n                    dataIndexInside: series.getAxisTooltipDataIndex\n                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n                        : series.getData().indexOfNearest(\n                            series.coordDimToDataDim(baseAxis.dim)[0],\n                            value[baseDimIndex],\n                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n                            false, baseAxis.type === 'category' ? 0.5 : null\n                        )\n                };\n            });\n            var sampleSeriesIndex;\n            zrUtil.each(payloadBatch, function (payload, idx) {\n                if (seriesList[idx].getData().hasValue(payload.dataIndexInside)) {\n                    sampleSeriesIndex = idx;\n                }\n            });\n            // Fallback to 0.\n            sampleSeriesIndex = sampleSeriesIndex || 0;\n\n            var lastHover = this._lastHover;\n            var api = this._api;\n            // Dispatch downplay action\n            if (lastHover.payloadBatch && !contentNotChange) {\n                api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Dispatch highlight action\n            if (!contentNotChange) {\n                api.dispatchAction({\n                    type: 'highlight',\n                    batch: payloadBatch\n                });\n                lastHover.payloadBatch = payloadBatch;\n            }\n            // Dispatch showTip action\n            var dataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n            api.dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                // expose to user.\n                dataIndex: seriesList[sampleSeriesIndex].getData().getRawIndex(dataIndex),\n                seriesIndex: payloadBatch[sampleSeriesIndex].seriesIndex,\n                from: this.uid\n            });\n\n            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n                var paramsList = zrUtil.map(seriesList, function (series, index) {\n                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n                });\n\n                if (!contentNotChange) {\n                    // Update html content\n                    var firstDataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = baseAxis.type === 'time'\n                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n                        : seriesList[sampleSeriesIndex].getData().getName(firstDataIndex);\n                    var defaultHtml = (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + zrUtil.map(seriesList, function (series, index) {\n                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n                        }).join('<br />');\n\n                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\n                    this._showTooltipContent(\n                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n                        point[0], point[1], positionExpr, null, api\n                    );\n                }\n                else {\n                    updatePosition(\n                        positionExpr || rootTooltipModel.get('position'),\n                        point[0], point[1],\n                        rootTooltipModel.get('confine'),\n                        this._tooltipContent, paramsList, null, api\n                    );\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on item\n         * @param {module:echarts/model/Series} seriesModel\n         * @param {number} dataIndex\n         * @param {string} dataType\n         * @param {Object} e\n         */\n        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n            // FIXME Graph data\n            var api = this._api;\n            var data = seriesModel.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var tooltipOpt = itemModel.get('tooltip', true);\n            if (typeof tooltipOpt === 'string') {\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                var tooltipContent = tooltipOpt;\n                tooltipOpt = {\n                    formatter: tooltipContent\n                };\n            }\n            var rootTooltipModel = this._tooltipModel;\n            var seriesTooltipModel = seriesModel.getModel(\n                'tooltip', rootTooltipModel\n            );\n            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\n            var params = seriesModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\n            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\n            this._showTooltipContent(\n                tooltipModel, defaultHtml, params, asyncTicket,\n                e.offsetX, e.offsetY, e.position, e.target, api\n            );\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n                var tooltipContent = this._tooltipContent;\n                var confine = tooltipModel.get('confine');\n\n                var formatter = tooltipModel.get('formatter');\n                positionExpr = positionExpr || tooltipModel.get('position');\n                var html = defaultHtml;\n\n                if (formatter) {\n                    if (typeof formatter === 'string') {\n                        html = formatUtil.formatTpl(formatter, params, true);\n                    }\n                    else if (typeof formatter === 'function') {\n                        var self = this;\n                        var ticket = asyncTicket;\n                        var callback = function (cbTicket, html) {\n                            if (cbTicket === self._ticket) {\n                                tooltipContent.setContent(html);\n\n                                updatePosition(\n                                    positionExpr, x, y, confine,\n                                    tooltipContent, params, target, api\n                                );\n                            }\n                        };\n                        self._ticket = ticket;\n                        html = formatter(params, ticket, callback);\n                    }\n                }\n\n                tooltipContent.show(tooltipModel);\n                tooltipContent.setContent(html);\n\n                updatePosition(\n                    positionExpr, x, y, confine,\n                    tooltipContent, params, target, api\n                );\n            }\n        },\n\n        /**\n         * Show axis pointer\n         * @param {string} [coordSysName]\n         */\n        _showAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.show();\n                });\n            }\n            else {\n                this.group.eachChild(function (child) {\n                    child.show();\n                });\n                this.group.show();\n            }\n        },\n\n        _resetLastHover: function () {\n            var lastHover = this._lastHover;\n            if (lastHover.payloadBatch) {\n                this._api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Reset lastHover\n            this._lastHover = {};\n        },\n        /**\n         * Hide axis pointer\n         * @param {string} [coordSysName]\n         */\n        _hideAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.hide();\n                });\n            }\n            else {\n                if (this.group.children().length) {\n                    this.group.hide();\n                }\n            }\n        },\n\n        _hide: function () {\n            clearTimeout(this._showTimeout);\n\n            this._hideAxisPointer();\n            this._resetLastHover();\n            if (!this._alwaysShowContent) {\n                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._api.dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n\n            this._lastX = this._lastY = null;\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var zr = api.getZr();\n            this._tooltipContent.hide();\n\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n        }\n    });\n\n\n/***/ }),\n/* 157 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var axisDefault = __webpack_require__(57);\n    var zrUtil = __webpack_require__(0);\n    var ComponentModel = __webpack_require__(16);\n    var layout = __webpack_require__(17);\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n\n/***/ }),\n/* 158 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var Axis = __webpack_require__(56);\n    var axisLabelInterval = __webpack_require__(162);\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n\n        /**\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n\n/***/ }),\n/* 159 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = __webpack_require__(0);\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n\n/***/ }),\n/* 160 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var Cartesian = __webpack_require__(159);\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n\n/***/ }),\n/* 161 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Grid \n//  Cartesian2D \n\n\n    __webpack_require__(59);\n    var ComponentModel = __webpack_require__(16);\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n\n/***/ }),\n/* 162 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Helper function for axisLabelInterval calculation\n */\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var axisHelper = __webpack_require__(27);\n\n    module.exports = function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n\n        return axisHelper.getAxisLabelInterval(\n            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n            axisModel.getFormattedLabels(),\n            labelModel.getModel('textStyle').getFont(),\n            axis.isHorizontal()\n        );\n    };\n\n\n/***/ }),\n/* 163 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var Axis = __webpack_require__(56);\n\n    function IndicatorAxis(dim, scale, radiusExtent) {\n        Axis.call(this, dim, scale, radiusExtent);\n\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = 'value';\n\n        this.angle = 0;\n\n        /**\n         * Indicator name\n         * @type {string}\n         */\n        this.name = '';\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.model;\n    }\n\n    zrUtil.inherits(IndicatorAxis, Axis);\n\n    module.exports = IndicatorAxis;\n\n\n/***/ }),\n/* 164 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// TODO clockwise\n\n\n    var zrUtil = __webpack_require__(0);\n    var IndicatorAxis = __webpack_require__(163);\n    var IntervalScale = __webpack_require__(30);\n    var numberUtil = __webpack_require__(3);\n    var axisHelper = __webpack_require__(27);\n\n    function Radar(radarModel, ecModel, api) {\n\n        this._model = radarModel;\n        /**\n         * Radar dimensions\n         * @type {Array.<string>}\n         */\n        this.dimensions = [];\n\n        this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n            var dim = 'indicator_' + idx;\n            var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n            indicatorAxis.name = indicatorModel.get('name');\n            // Inject model and axis\n            indicatorAxis.model = indicatorModel;\n            indicatorModel.axis = indicatorAxis;\n            this.dimensions.push(dim);\n            return indicatorAxis;\n        }, this);\n\n        this.resize(radarModel, api);\n\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cx;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cy;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.r;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.startAngle;\n    }\n\n    Radar.prototype.getIndicatorAxes = function () {\n        return this._indicatorAxes;\n    };\n\n    Radar.prototype.dataToPoint = function (value, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n\n        return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n    };\n\n    Radar.prototype.coordToPoint = function (coord, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n        var angle = indicatorAxis.angle;\n        var x = this.cx + coord * Math.cos(angle);\n        var y = this.cy - coord * Math.sin(angle);\n        return [x, y];\n    };\n\n    Radar.prototype.pointToData = function (pt) {\n        var dx = pt[0] - this.cx;\n        var dy = pt[1] - this.cy;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        dx /= radius;\n        dy /= radius;\n\n        var radian = Math.atan2(-dy, dx);\n\n        // Find the closest angle\n        // FIXME index can calculated directly\n        var minRadianDiff = Infinity;\n        var closestAxis;\n        var closestAxisIdx = -1;\n        for (var i = 0; i < this._indicatorAxes.length; i++) {\n            var indicatorAxis = this._indicatorAxes[i];\n            var diff = Math.abs(radian - indicatorAxis.angle);\n            if (diff < minRadianDiff) {\n                closestAxis = indicatorAxis;\n                closestAxisIdx = i;\n                minRadianDiff = diff;\n            }\n        }\n\n        return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];\n    };\n\n    Radar.prototype.resize = function (radarModel, api) {\n        var center = radarModel.get('center');\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        var viewSize = Math.min(viewWidth, viewHeight) / 2;\n        this.cx = numberUtil.parsePercent(center[0], viewWidth);\n        this.cy = numberUtil.parsePercent(center[1], viewHeight);\n\n        this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n\n        this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);\n\n        zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {\n            indicatorAxis.setExtent(0, this.r);\n            var angle = (this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length);\n            // Normalize to [-PI, PI]\n            angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n            indicatorAxis.angle = angle;\n        }, this);\n    };\n\n    Radar.prototype.update = function (ecModel, api) {\n        var indicatorAxes = this._indicatorAxes;\n        var radarModel = this._model;\n        zrUtil.each(indicatorAxes, function (indicatorAxis) {\n            indicatorAxis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n            if (radarSeries.get('coordinateSystem') !== 'radar'\n                || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel\n            ) {\n                return;\n            }\n            var data = radarSeries.getData();\n            zrUtil.each(indicatorAxes, function (indicatorAxis) {\n                indicatorAxis.scale.unionExtentFromData(data, indicatorAxis.dim);\n            });\n        }, this);\n\n        var splitNumber = radarModel.get('splitNumber');\n\n        function increaseInterval(interval) {\n            var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));\n            // Increase interval\n            var f = interval / exp10;\n            if (f === 2) {\n                f = 5;\n            }\n            else { // f is 2 or 5\n                f *= 2;\n            }\n            return f * exp10;\n        }\n        // Force all the axis fixing the maxSplitNumber.\n        zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {\n            var rawExtent = axisHelper.getScaleExtent(indicatorAxis, indicatorAxis.model);\n            axisHelper.niceScaleExtent(indicatorAxis, indicatorAxis.model);\n\n            var axisModel = indicatorAxis.model;\n            var scale = indicatorAxis.scale;\n            var fixedMin = axisModel.getMin();\n            var fixedMax = axisModel.getMax();\n            var interval = scale.getInterval();\n\n            if (fixedMin != null && fixedMax != null) {\n                // User set min, max, divide to get new interval\n                // FIXME precision\n                scale.setInterval(\n                    (fixedMax - fixedMin) / splitNumber\n                );\n            }\n            else if (fixedMin != null) {\n                var max;\n                // User set min, expand extent on the other side\n                do {\n                    max = fixedMin + interval * splitNumber;\n                    scale.setExtent(+fixedMin, max);\n                    // Interval must been set after extent\n                    // FIXME\n                    scale.setInterval(interval);\n\n                    interval = increaseInterval(interval);\n                } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n            }\n            else if (fixedMax != null) {\n                var min;\n                // User set min, expand extent on the other side\n                do {\n                    min = fixedMax - interval * splitNumber;\n                    scale.setExtent(min, +fixedMax);\n                    scale.setInterval(interval);\n                    interval = increaseInterval(interval);\n                } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n            }\n            else {\n                var nicedSplitNumber = scale.getTicks().length - 1;\n                if (nicedSplitNumber > splitNumber) {\n                    interval = increaseInterval(interval);\n                }\n                // PENDING\n                var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;\n                var halfSplitNumber = Math.round(splitNumber / 2);\n                scale.setExtent(\n                    numberUtil.round(center - halfSplitNumber * interval),\n                    numberUtil.round(center + (splitNumber - halfSplitNumber) * interval)\n                );\n                scale.setInterval(interval);\n            }\n        });\n    };\n\n    /**\n     * Radar dimensions is based on the data\n     * @type {Array}\n     */\n    Radar.dimensions = [];\n\n    Radar.create = function (ecModel, api) {\n        var radarList = [];\n        ecModel.eachComponent('radar', function (radarModel) {\n            var radar = new Radar(radarModel, ecModel, api);\n            radarList.push(radar);\n            radarModel.coordinateSystem = radar;\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries) {\n            if (radarSeries.get('coordinateSystem') === 'radar') {\n                // Inject coordinate system\n                radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n            }\n        });\n        return radarList;\n    };\n\n    __webpack_require__(26).register('radar', Radar);\n    module.exports = Radar;\n\n\n/***/ }),\n/* 165 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\n    var axisDefault = __webpack_require__(57);\n    var valueAxisDefault = axisDefault.valueAxis;\n    var Model = __webpack_require__(10);\n    var zrUtil = __webpack_require__(0);\n\n    var axisModelCommonMixin = __webpack_require__(58);\n\n    function defaultsShow(opt, show) {\n        return zrUtil.defaults({\n            show: show\n        }, opt);\n    }\n\n    var RadarModel = __webpack_require__(1).extendComponentModel({\n\n        type: 'radar',\n\n        optionUpdated: function () {\n            var boundaryGap = this.get('boundaryGap');\n            var splitNumber = this.get('splitNumber');\n            var scale = this.get('scale');\n            var axisLine = this.get('axisLine');\n            var axisTick = this.get('axisTick');\n            var axisLabel = this.get('axisLabel');\n            var nameTextStyle = this.get('name.textStyle');\n            var showName = this.get('name.show');\n            var nameFormatter = this.get('name.formatter');\n            var nameGap = this.get('nameGap');\n            var triggerEvent = this.get('triggerEvent');\n\n            var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {\n                // PENDING\n                if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n                    indicatorOpt.min = 0;\n                }\n                else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n                    indicatorOpt.max = 0;\n                }\n                // Use same configuration\n                indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {\n                    boundaryGap: boundaryGap,\n                    splitNumber: splitNumber,\n                    scale: scale,\n                    axisLine: axisLine,\n                    axisTick: axisTick,\n                    axisLabel: axisLabel,\n                    // Competitable with 2 and use text\n                    name: indicatorOpt.text,\n                    nameLocation: 'end',\n                    nameGap: nameGap,\n                    // min: 0,\n                    nameTextStyle: nameTextStyle,\n                    triggerEvent: triggerEvent\n                }, false);\n                if (!showName) {\n                    indicatorOpt.name = '';\n                }\n                if (typeof nameFormatter === 'string') {\n                    var indName = indicatorOpt.name;\n                    indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n                }\n                else if (typeof nameFormatter === 'function') {\n                    indicatorOpt.name = nameFormatter(\n                        indicatorOpt.name, indicatorOpt\n                    );\n                }\n                var model = zrUtil.extend(\n                    new Model(indicatorOpt, null, this.ecModel),\n                    axisModelCommonMixin\n                );\n\n                // For triggerEvent.\n                model.mainType = 'radar';\n                model.componentIndex = this.componentIndex;\n\n                return model;\n            }, this);\n\n            this.getIndicatorModels = function () {\n                return indicatorModels;\n            };\n        },\n\n        defaultOption: {\n\n            zlevel: 0,\n\n            z: 0,\n\n            center: ['50%', '50%'],\n\n            radius: '75%',\n\n            startAngle: 90,\n\n            name: {\n                show: true\n                // formatter: null\n                // textStyle: {}\n            },\n\n            boundaryGap: [0, 0],\n\n            splitNumber: 5,\n\n            nameGap: 15,\n\n            scale: false,\n\n            // Polygon or circle\n            shape: 'polygon',\n\n            axisLine: zrUtil.merge(\n                {\n                    lineStyle: {\n                        color: '#bbb'\n                    }\n                },\n                valueAxisDefault.axisLine\n            ),\n            axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n            axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n            splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n            splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n\n            // {text, min, max}\n            indicator: []\n        }\n    });\n\n    module.exports = RadarModel;\n\n\n/***/ }),\n/* 166 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n/***/ }),\n/* 167 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var numberUtil = __webpack_require__(3);\n    var parsePercent = numberUtil.parsePercent;\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\n            var stackId = getSeriesStackId(seriesModel);\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n\n            // Caution: In a single coordinate system, these barGrid attributes\n            // will be shared by series. Consider that they have default values,\n            // only the attributes set on the last series will work.\n            // Do not change this fact unless there will be a break change.\n\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (!column.width && maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                if (isNaN(value)) {\n                    return;\n                }\n\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    module.exports = barLayoutGrid;\n\n\n/***/ }),\n/* 168 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var graphic = __webpack_require__(2);\n    var zrUtil = __webpack_require__(0);\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n/***/ }),\n/* 169 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(9);\n    var Model = __webpack_require__(10);\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = __webpack_require__(16);\n\n    var globalDefault = __webpack_require__(171);\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption();\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap[mainType], newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap[mainType] = [];\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap[mainType][index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap[mainType];\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap[mainType];\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts;\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap[mainType];\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                each(componentsMap, function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap[mainType], cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.series[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.series.slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.series, cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.series, cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\n            var componentTypes = [];\n            each(componentsMap, function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, __webpack_require__(62));\n\n    module.exports = GlobalModel;\n\n\n/***/ }),\n/* 170 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var modelUtil = __webpack_require__(9);\n    var ComponentModel = __webpack_require__(16);\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n/***/ }),\n/* 171 */\n/***/ (function(module, exports) {\n\n\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000\n    };\n\n\n/***/ }),\n/* 172 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    module.exports = {\n        getAreaStyle: __webpack_require__(29)(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n/***/ }),\n/* 173 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n/***/ }),\n/* 174 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var getItemStyle = __webpack_require__(29)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n/***/ }),\n/* 175 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var getLineStyle = __webpack_require__(29)(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n/***/ }),\n/* 176 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var textContain = __webpack_require__(18);\n\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                // FIXME in node-canvas fontWeight is before fontStyle\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n\n/***/ }),\n/* 177 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Compatitable with 2.0\n\n\n    var zrUtil = __webpack_require__(0);\n    var compatStyle = __webpack_require__(178);\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n/***/ }),\n/* 178 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n\n/***/ }),\n/* 179 */\n/***/ (function(module, exports) {\n\n\n    var samplers = {\n        average: function (frame) {\n            var sum = 0;\n            var count = 0;\n            for (var i = 0; i < frame.length; i++) {\n                if (!isNaN(frame[i])) {\n                    sum += frame[i];\n                    count++;\n                }\n            }\n            // Return NaN if count is 0\n            return count === 0 ? NaN : sum / count;\n        },\n        sum: function (frame) {\n            var sum = 0;\n            for (var i = 0; i < frame.length; i++) {\n                // Ignore NaN\n                sum += frame[i] || 0;\n            }\n            return sum;\n        },\n        max: function (frame) {\n            var max = -Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] > max && (max = frame[i]);\n            }\n            return max;\n        },\n        min: function (frame) {\n            var min = Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] < min && (min = frame[i]);\n            }\n            return min;\n        },\n        // TODO\n        // Median\n        nearest: function (frame) {\n            return frame[0];\n        }\n    };\n\n    var indexSampler = function (frame, value) {\n        return Math.round(frame.length / 2);\n    };\n    module.exports = function (seriesType, ecModel, api) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var sampling = seriesModel.get('sampling');\n            var coordSys = seriesModel.coordinateSystem;\n            // Only cartesian2d support down sampling\n            if (coordSys.type === 'cartesian2d' && sampling) {\n                var baseAxis = coordSys.getBaseAxis();\n                var valueAxis = coordSys.getOtherAxis(baseAxis);\n                var extent = baseAxis.getExtent();\n                // Coordinste system has been resized\n                var size = extent[1] - extent[0];\n                var rate = Math.round(data.count() / size);\n                if (rate > 1) {\n                    var sampler;\n                    if (typeof sampling === 'string') {\n                        sampler = samplers[sampling];\n                    }\n                    else if (typeof sampling === 'function') {\n                        sampler = sampling;\n                    }\n                    if (sampler) {\n                        data = data.downSample(\n                            valueAxis.dim, 1 / rate, sampler, indexSampler\n                        );\n                        seriesModel.setData(data);\n                    }\n                }\n            }\n        }, this);\n    };\n\n\n/***/ }),\n/* 180 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = __webpack_require__(0);\n    var Scale = __webpack_require__(31);\n    var numberUtil = __webpack_require__(3);\n\n    // Use some method of IntervalScale\n    var IntervalScale = __webpack_require__(30);\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [approxTickNum = 10] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = fixMin;\n            originalScale.__fixMax = fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n/***/ }),\n/* 181 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = __webpack_require__(0);\n    var Scale = __webpack_require__(31);\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n/***/ }),\n/* 182 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    var zrUtil = __webpack_require__(0);\n    var numberUtil = __webpack_require__(3);\n    var formatUtil = __webpack_require__(8);\n\n    var IntervalScale = __webpack_require__(30);\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        // Overwrite\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date);\n        },\n\n        // Overwrite\n        niceExtent: function (approxTickNum, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(approxTickNum);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        // Overwrite\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                mathCeil(extent[0] / interval) * interval,\n                mathFloor(extent[1] / interval) * interval\n            ];\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n\n    module.exports = TimeScale;\n\n\n/***/ }),\n/* 183 */\n/***/ (function(module, exports) {\n\n\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            diff = currCall - (debounce ? lastCall : lastExec) - delay;\n\n            clearTimeout(timer);\n\n            if (debounce) {\n                timer = setTimeout(exec, delay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n/***/ }),\n/* 184 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Group = __webpack_require__(35);\n    var componentUtil = __webpack_require__(42);\n    var clazzUtil = __webpack_require__(14);\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n/***/ }),\n/* 185 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var Gradient = __webpack_require__(47);\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n/***/ }),\n/* 186 */,\n/* 187 */,\n/* 188 */,\n/* 189 */,\n/* 190 */,\n/* 191 */\n/***/ (function(module, exports) {\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/***/ }),\n/* 192 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n/***/ }),\n/* 193 */\n/***/ (function(module, exports) {\n\n\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\tvar fixedCss = css.replace(/url *\\( *(.+?) *\\)/g, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n/***/ }),\n/* 194 */,\n/* 195 */,\n/* 196 */,\n/* 197 */,\n/* 198 */,\n/* 199 */,\n/* 200 */,\n/* 201 */,\n/* 202 */,\n/* 203 */,\n/* 204 */,\n/* 205 */,\n/* 206 */,\n/* 207 */,\n/* 208 */,\n/* 209 */,\n/* 210 */,\n/* 211 */,\n/* 212 */,\n/* 213 */,\n/* 214 */,\n/* 215 */,\n/* 216 */,\n/* 217 */,\n/* 218 */,\n/* 219 */,\n/* 220 */,\n/* 221 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n  * vue-router v2.2.1\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if (!condition) {\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n  }\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (h, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h()\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // inject instance registration hooks\n    var hooks = data.hook || (data.hook = {});\n    hooks.init = function (vnode) {\n      matched.instances[name] = vnode.child;\n    };\n    hooks.prepatch = function (oldVnode, vnode) {\n      matched.instances[name] = vnode.child;\n    };\n    hooks.destroy = function (vnode) {\n      if (matched.instances[name] === vnode.child) {\n        matched.instances[name] = undefined;\n      }\n    };\n\n    // resolve props\n    data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    return h(component, data, children)\n  }\n};\n\nfunction resolveProps (route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return\n    case 'object':\n      return config\n    case 'function':\n      return config(route)\n    case 'boolean':\n      return config ? route.params : undefined\n    default:\n      warn(false, (\"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", expecting an object, function or boolean.\"));\n  }\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more comformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function (str) { return encodeURIComponent(str)\n  .replace(encodeReserveRE, encodeReserveReplacer)\n  .replace(commaRE, ','); };\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery (\n  query,\n  extraQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  if (query) {\n    var parsedQuery;\n    try {\n      parsedQuery = parseQuery(query);\n    } catch (e) {\n      \"production\".NODE_ENV !== 'production' && warn(false, e.message);\n      parsedQuery = {};\n    }\n    for (var key in extraQuery) {\n      parsedQuery[key] = extraQuery[key];\n    }\n    return parsedQuery\n  } else {\n    return extraQuery\n  }\n}\n\nfunction parseQuery (query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0\n      ? decode(parts.join('='))\n      : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return ''\n    }\n\n    if (val === null) {\n      return encode(key)\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.slice().forEach(function (val2) {\n        if (val2 === undefined) {\n          return\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&')\n    }\n\n    return encode(key) + '=' + encode(val)\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom\n) {\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: location.query || {},\n    params: location.params || {},\n    fullPath: getFullPath(location),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom);\n  }\n  return Object.freeze(route)\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch (record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res\n}\n\nfunction getFullPath (ref) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  return (path || '/') + stringifyQuery(query) + hash\n}\n\nfunction isSameRoute (a, b) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return (\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query)\n    )\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params)\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.replace(trailingSlashRE, '/').indexOf(\n      target.path.replace(trailingSlashRE, '/')\n    ) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n    var classes = {};\n    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';\n    var compareTarget = location.path ? createRoute(null, location) : route;\n    classes[activeClass] = this.exact\n      ? isSameRoute(current, compareTarget)\n      : isIncludedRoute(current, compareTarget);\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) { on[e] = handler; });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n};\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  if (e.target && e.target.getAttribute) {\n    var target = e.target.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) { return }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install (Vue) {\n  if (install.installed) { return }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this.$root._router }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get () { return this.$root._route }\n  });\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (this.$options.router) {\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      }\n    }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  if (relative.charAt(0) === '/') {\n    return relative\n  }\n\n  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '.') {\n      continue\n    } else if (segment === '..') {\n      stack.pop();\n    } else {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/\\//g, '/')\n}\n\n/*  */\n\nfunction createRouteMap (\n  routes,\n  oldPathMap,\n  oldNameMap\n) {\n  var pathMap = oldPathMap || Object.create(null);\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathMap, nameMap, route);\n  });\n\n  return {\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (\"production\".NODE_ENV !== 'production') {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(\n      typeof route.component !== 'string',\n      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n      \"string id. Use an actual component instead.\"\n    );\n  }\n\n  var record = {\n    path: normalizePath(path, parent),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (\"production\".NODE_ENV !== 'production') {\n      if (route.name && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n        warn(\n          false,\n          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n          \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\n          \"the default child route will not be rendered. Remove the name from \" +\n          \"this route and use the name of the default child route for named \" +\n          \"links instead.\"\n        );\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs\n        ? cleanPath((matchAs + \"/\" + (child.path)))\n        : undefined;\n      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    if (Array.isArray(route.alias)) {\n      route.alias.forEach(function (alias) {\n        var aliasRoute = {\n          path: alias,\n          children: route.children\n        };\n        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n      });\n    } else {\n      var aliasRoute = {\n        path: route.alias,\n        children: route.children\n      };\n      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n    }\n  }\n\n  if (!pathMap[record.path]) {\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (\"production\".NODE_ENV !== 'production' && !matchAs) {\n      warn(\n        false,\n        \"Duplicate named routes definition: \" +\n        \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n      );\n    }\n  }\n}\n\nfunction normalizePath (path, parent) {\n  path = path.replace(/\\/$/, '');\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\nvar index$1 = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\nvar isarray = index$1;\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\nvar regexpCache = Object.create(null);\n\nfunction getRouteRegex (path) {\n  var hit = regexpCache[path];\n  var keys, regexp;\n\n  if (hit) {\n    keys = hit.keys;\n    regexp = hit.regexp;\n  } else {\n    keys = [];\n    regexp = index(path, keys);\n    regexpCache[path] = { keys: keys, regexp: regexp };\n  }\n\n  return { keys: keys, regexp: regexp }\n}\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = index.compile(path));\n    return filler(params || {}, { pretty: true })\n  } catch (e) {\n    if (\"production\".NODE_ENV !== 'production') {\n      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)));\n    }\n    return ''\n  }\n}\n\n/*  */\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next);\n    next._normalized = true;\n    var params = assign(assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\n    } else if (\"production\".NODE_ENV !== 'production') {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = (current && current.path) || '/';\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : (current && current.path) || '/';\n  var query = resolveQuery(parsedPath.query, next.query);\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction assign (a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a\n}\n\n/*  */\n\nfunction createMatcher (routes) {\n  var ref = createRouteMap(routes);\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes (routes) {\n    createRouteMap(routes, pathMap, nameMap);\n  }\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (\"production\".NODE_ENV !== 'production') {\n        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n      }\n      var paramNames = getRouteRegex(record.path).keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n        return _createRoute(record, location, redirectedFrom)\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var path in pathMap) {\n        if (matchRoute(path, location.params, location.path)) {\n          return _createRoute(pathMap[path], location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function'\n        ? originalRedirect(createRoute(record, location))\n        : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      \"production\".NODE_ENV !== 'production' && warn(\n        false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n      );\n      return _createRoute(null, location)\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (\"production\".NODE_ENV !== 'production') {\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom)\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  }\n}\n\nfunction matchRoute (\n  path,\n  params,\n  pathname\n) {\n  var ref = getRouteRegex(path);\n  var regexp = ref.regexp;\n  var keys = ref.keys;\n  var m = pathname.match(regexp);\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) { params[key.name] = val; }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll () {\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll (\n  router,\n  to,\n  from,\n  isPop\n) {\n  if (!router.app) {\n    return\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return\n  }\n\n  if (\"production\".NODE_ENV !== 'production') {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n    if (!shouldScroll) {\n      return\n    }\n    var isObject = typeof shouldScroll === 'object';\n    if (isObject && typeof shouldScroll.selector === 'string') {\n      var el = document.querySelector(shouldScroll.selector);\n      if (el) {\n        position = getElementPosition(el);\n      } else if (isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n    } else if (isObject && isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n\n    if (position) {\n      window.scrollTo(position.x, position.y);\n    }\n  });\n}\n\nfunction saveScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key]\n  }\n}\n\nfunction getElementPosition (el) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left,\n    y: elRect.top - docRect.top\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && (function () {\n  var ua = window.navigator.userAgent;\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now\n  ? window.performance\n  : Date;\n\nvar _key = genKey();\n\nfunction genKey () {\n  return Time.now().toFixed(3)\n}\n\nfunction getStateKey () {\n  return _key\n}\n\nfunction setStateKey (key) {\n  _key = key;\n}\n\nfunction pushState (url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\n\nvar History = function History (router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady (cb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n  }\n};\n\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) {\n        cb(route);\n      });\n    }\n  }, onAbort);\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current;\n  var abort = function () { onAbort && onAbort(); };\n  if (\n    isSameRoute(route, current) &&\n    // in the case the route map has been dynamically appended to\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL();\n    return abort()\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // in-component update hooks\n    extractUpdateHooks(updated),\n    // in-config enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  );\n\n  this.pending = route;\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort()\n    }\n    hook(route, current, function (to) {\n      if (to === false) {\n        // next(false) -> abort navigation, ensure current URL\n        this$1.ensureURL(true);\n        abort();\n      } else if (typeof to === 'string' || typeof to === 'object') {\n        // next('/') or next({ path: '/' }) -> redirect\n        (typeof to === 'object' && to.replace) ? this$1.replace(to) : this$1.push(to);\n        abort();\n      } else {\n        // confirm transition and pass on the value\n        next(to);\n      }\n    });\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function () { return this$1.current === route; };\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    runQueue(enterGuards, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort()\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) { return cb(); });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse\n) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n        : bind(guard, instance, match, key)\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n\nfunction extractUpdateHooks (updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n\nfunction bindGuard (guard, instance) {\n  return function boundRouteGuard () {\n    return guard.apply(instance, arguments)\n  }\n}\n\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    })\n  }\n}\n\nfunction poll (\n  cb, // somehow flow cannot infer this is a function\n  instances,\n  key,\n  isValid\n) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\nfunction resolveAsyncComponents (matched) {\n  return flatMapComponents(matched, function (def, _, match, key) {\n    // if it's a function and doesn't have Vue options attached,\n    // assume it's an async component resolve function.\n    // we are not using Vue's default async resolving mechanism because\n    // we want to halt the navigation until the incoming component has been\n    // resolved.\n    if (typeof def === 'function' && !def.options) {\n      return function (to, from, next) {\n        var resolve = once(function (resolvedDef) {\n          match.components[key] = resolvedDef;\n          next();\n        });\n\n        var reject = once(function (reason) {\n          warn(false, (\"Failed to resolve async component \" + key + \": \" + reason));\n          next(false);\n        });\n\n        var res = def(resolve, reject);\n        if (res && typeof res.then === 'function') {\n          res.then(resolve, reject);\n        }\n      }\n    }\n  })\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (called) { return }\n    called = true;\n    return fn.apply(this, arguments)\n  }\n}\n\n/*  */\n\n\nvar HTML5History = (function (History$$1) {\n  function HTML5History (router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener('popstate', function (e) {\n      this$1.transitionTo(getLocation(this$1.base), function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, this$1.current, true);\n        }\n      });\n    });\n  }\n\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, this$1.current, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, this$1.current, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getLocation(this.base)\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\n/*  */\n\n\nvar HashHistory = (function (History$$1) {\n  function HashHistory (router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    ensureSlash();\n  }\n\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    window.addEventListener('hashchange', function () {\n      if (!ensureSlash()) {\n        return\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        replaceHash(route.fullPath);\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getHash()\n  };\n\n  return HashHistory;\n}(History));\n\nfunction checkFallback (base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(\n      cleanPath(base + '/#' + location)\n    );\n    return true\n  }\n}\n\nfunction ensureSlash () {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path);\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path;\n}\n\nfunction replaceHash (path) {\n  var i = window.location.href.indexOf('#');\n  window.location.replace(\n    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n  );\n}\n\n/*  */\n\n\nvar AbstractHistory = (function (History$$1) {\n  function AbstractHistory (router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/'\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || []);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break\n    default:\n      if (\"production\".NODE_ENV !== 'production') {\n        assert(false, (\"invalid mode: \" + mode));\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: {} };\n\nVueRouter.prototype.match = function match (\n  raw,\n  current,\n  redirectedFrom\n) {\n  return this.matcher.match(raw, current, redirectedFrom)\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n  \"production\".NODE_ENV !== 'production' && assert(\n    install.installed,\n    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n    \"before creating root instance.\"\n  );\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      history.setupListeners();\n    };\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    );\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  this.beforeHooks.push(fn);\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  this.afterHooks.push(fn);\n};\n\nVueRouter.prototype.onReady = function onReady (cb) {\n  this.history.onReady(cb);\n};\n\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? this.resolve(to).route\n    : this.currentRoute;\n  if (!route) {\n    return []\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key]\n    })\n  }))\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  var location = normalizeLocation(to, current || this.history.current, append);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  }\n};\n\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = install;\nVueRouter.version = '2.2.1';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = VueRouter;\n\n\n/***/ }),\n/* 222 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = __webpack_require__(0);\n    var Draggable = __webpack_require__(257);\n\n    var Eventful = __webpack_require__(24);\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetEl \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n/***/ }),\n/* 223 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = __webpack_require__(0);\n    var config = __webpack_require__(34);\n    var Style = __webpack_require__(72);\n    var Pattern = __webpack_require__(71);\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n/***/ }),\n/* 224 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = __webpack_require__(34);\n    var util = __webpack_require__(0);\n    var log = __webpack_require__(69);\n    var BoundingRect = __webpack_require__(13);\n    var timsort = __webpack_require__(45);\n\n    var Layer = __webpack_require__(223);\n\n    var requestAnimationFrame = __webpack_require__(66);\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.isBuildin) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        this.pathToImage = this._createPathToImage();\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuildinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuildinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.isBuildin) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n\n            layersMap[zlevel] = layer;\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (! layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [0, 0, 0];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = __webpack_require__(70);\n            var imgShape = new ImageShape({\n                id: id,\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        },\n\n        _createPathToImage: function () {\n            var me = this;\n\n            return function (id, e, width, height) {\n                return me._pathToImage(\n                    id, e, width, height, me.dpr\n                );\n            };\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n/***/ }),\n/* 225 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = __webpack_require__(0);\n    var env = __webpack_require__(11);\n\n    var Group = __webpack_require__(35);\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = __webpack_require__(45);\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // idmap\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [elId] Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // elId\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n/***/ }),\n/* 226 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = __webpack_require__(0);\n    var Dispatcher = __webpack_require__(37).Dispatcher;\n\n    var requestAnimationFrame = __webpack_require__(66);\n\n    var Animator = __webpack_require__(65);\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n/***/ }),\n/* 227 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = __webpack_require__(228);\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (globalTime - this._startTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n/***/ }),\n/* 228 */\n/***/ (function(module, exports) {\n\n/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n/***/ }),\n/* 229 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var normalizeRadian = __webpack_require__(67).normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n/***/ }),\n/* 230 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var curve = __webpack_require__(19);\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n/***/ }),\n/* 231 */\n/***/ (function(module, exports) {\n\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n/***/ }),\n/* 232 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var CMD = __webpack_require__(36).CMD;\n    var line = __webpack_require__(231);\n    var cubic = __webpack_require__(230);\n    var quadratic = __webpack_require__(233);\n    var arc = __webpack_require__(229);\n    var normalizeRadian = __webpack_require__(67).normalizeRadian;\n    var curve = __webpack_require__(19);\n\n    var windingLine = __webpack_require__(234);\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n/***/ }),\n/* 233 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var curve = __webpack_require__(19);\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n/***/ }),\n/* 234 */\n/***/ (function(module, exports) {\n\n\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n/***/ }),\n/* 235 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = __webpack_require__(37);\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n/***/ }),\n/* 236 */\n/***/ (function(module, exports) {\n\n// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function() {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function(val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function(entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function(entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function() {\n        return this._len;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function(val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function(maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function(key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function(key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function() {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n/***/ }),\n/* 237 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(6);\n    var curve = __webpack_require__(19);\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n/***/ }),\n/* 238 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var eventTool = __webpack_require__(37);\n    var zrUtil = __webpack_require__(0);\n    var Eventful = __webpack_require__(24);\n    var env = __webpack_require__(11);\n    var GestureMgr = __webpack_require__(235);\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n/***/ }),\n/* 239 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// CompoundPath to improve performance\n\n\n    var Path = __webpack_require__(7);\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n/***/ }),\n/* 240 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var Gradient = __webpack_require__(47);\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n/***/ }),\n/* 241 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(0);\n\n    var Gradient = __webpack_require__(47);\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n/***/ }),\n/* 242 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = __webpack_require__(46);\n    var zrUtil = __webpack_require__(0);\n    var textContain = __webpack_require__(18);\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n/***/ }),\n/* 243 */\n/***/ (function(module, exports) {\n\n\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n/***/ }),\n/* 244 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = __webpack_require__(6);\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n/***/ }),\n/* 245 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = __webpack_require__(6);\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n/***/ }),\n/* 246 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = __webpack_require__(18);\n    var BoundingRect = __webpack_require__(13);\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n/***/ }),\n/* 247 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = __webpack_require__(7).extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n/***/ }),\n/* 248 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = __webpack_require__(19);\n    var vec2 = __webpack_require__(6);\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = __webpack_require__(7).extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n/***/ }),\n/* 249 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = __webpack_require__(7).extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n/***/ }),\n/* 250 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = __webpack_require__(7).extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n/***/ }),\n/* 251 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = __webpack_require__(73);\n\n    module.exports = __webpack_require__(7).extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n/***/ }),\n/* 252 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = __webpack_require__(73);\n\n    module.exports = __webpack_require__(7).extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n/***/ }),\n/* 253 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = __webpack_require__(243);\n\n    module.exports = __webpack_require__(7).extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n/***/ }),\n/* 254 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = __webpack_require__(7).extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n/***/ }),\n/* 255 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = __webpack_require__(11);\n    var Path = __webpack_require__(7);\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n/***/ }),\n/* 256 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = __webpack_require__(65);\n    var util = __webpack_require__(0);\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = __webpack_require__(69);\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n/***/ }),\n/* 257 */\n/***/ (function(module, exports) {\n\n// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n/***/ }),\n/* 258 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = __webpack_require__(23);\n    var vector = __webpack_require__(6);\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n/***/ }),\n/* 259 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Path = __webpack_require__(7);\n    var PathProxy = __webpack_require__(36);\n    var transformPath = __webpack_require__(260);\n    var matrix = __webpack_require__(23);\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n/***/ }),\n/* 260 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var CMD = __webpack_require__(36).CMD;\n    var vec2 = __webpack_require__(6);\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n/***/ }),\n/* 261 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = __webpack_require__(68);\n    var env = __webpack_require__(11);\n    var zrUtil = __webpack_require__(0);\n\n    var Handler = __webpack_require__(222);\n    var Storage = __webpack_require__(225);\n    var Animation = __webpack_require__(226);\n    var HandlerProxy = __webpack_require__(238);\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: __webpack_require__(224)\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.3.0';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromMap, \n        // FIXME ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n/***/ })\n]);\n\n\n// WEBPACK FOOTER //\n// js/vendor.1d4dedcc.js","/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 0\n// module chunks = 0","// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = require('zrender/lib/core/env');\n\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var modelUtil = require('./util/model');\n    var throttle = require('./util/throttle');\n\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/lib/core/util');\n    var colorTool = require('zrender/lib/tool/color');\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var timsort = require('zrender/lib/core/timsort');\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts (dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        // FIXME\n        // ugly\n        this.__lastOnlyGraphic = !!(option && option.graphic);\n        zrUtil.each(option, function (o, mainType) {\n            mainType !== 'graphic' && (this.__lastOnlyGraphic = false);\n        }, this);\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.time && console.time('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            // console.time && console.timeEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            // FIXME\n            // ugly\n            if (this.__lastOnlyGraphic) {\n                each(this._componentsViews, function (componentView) {\n                    var componentModel = componentView.__model;\n                    if (componentModel && componentModel.mainType === 'graphic') {\n                        componentView.render(componentModel, ecModel, this._api, payload);\n                        updateZ(componentModel, componentView);\n                    }\n                }, this);\n                this.__lastOnlyGraphic = false;\n            }\n            else {\n                updateMethods.update.call(this, payload);\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            var view = ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId];\n            if (view && view.__alive) {\n                view[method](model, ecModel, ecIns._api, payload);\n            }\n        }, ecIns);\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.4.0',\n        dependencies: {\n            zrender: '3.3.0'\n        }\n    };\n\n    function enableConnect(chart) {\n\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        dom.setAttribute &&\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        }\n        else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = require('zrender/lib/core/matrix');\n    echarts.vector = require('zrender/lib/core/vector');\n    echarts.color = require('zrender/lib/tool/color');\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/echarts.js\n// module id = 1\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var pathTool = require('zrender/lib/tool/path');\n    var round = Math.round;\n    var Path = require('zrender/lib/graphic/Path');\n    var colorTool = require('zrender/lib/tool/color');\n    var matrix = require('zrender/lib/core/matrix');\n    var vector = require('zrender/lib/core/vector');\n\n    var graphic = {};\n\n    graphic.Group = require('zrender/lib/container/Group');\n\n    graphic.Image = require('zrender/lib/graphic/Image');\n\n    graphic.Text = require('zrender/lib/graphic/Text');\n\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\n\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\n\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\n\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\n\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\n\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\n\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\n\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\n\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\n\n    graphic.CompoundPath = require('zrender/lib/graphic/CompoundPath');\n\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\n\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\n\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.attr(props), cb && cb());\n        }\n        else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    module.exports = graphic;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/graphic.js\n// module id = 2\n// module chunks = 0","/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        return +(+x).toFixed(precision);\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10; // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        return nf * exp10;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/number.js\n// module id = 3\n// module chunks = 0","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = Object.create(options.computed || null)\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n    options.computed = computed\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 5\n// module chunks = 0","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 6\n// module chunks = 0","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 7\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/lib/contain/text');\n\n    var formatUtil = {};\n    /**\n     * ,\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/format.js\n// module id = 8\n// module chunks = 0","\n\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get(['label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = {};\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && (idMap[opt.id] = item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-';\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap[keyInfo.id]);\n            }\n\n            idMap[keyInfo.id] = item;\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, goeName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = parsedKey[2];\n\n            if (!mainType || !queryType) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            queryParam[queryType.toLowerCase()] = value;\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/model.js\n// module id = 9\n// module chunks = 0","/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../util/clazz');\n    var env = require('zrender/lib/core/env');\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n\n    module.exports = Model;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Model.js\n// module id = 10\n// module chunks = 0","/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 11\n// module chunks = 0","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 13\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/clazz.js\n// module id = 14\n// module chunks = 0","/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = require('./Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\n    module.exports = ComponentModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Component.js\n// module id = 16\n// module chunks = 0","'use strict';\n// Layout helpers for each component positioning\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = ['width', 'left', 'right']; // Order by priority.\n        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/layout.js\n// module id = 17\n// module chunks = 0","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 18\n// module chunks = 0","'use strict';\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 19\n// module chunks = 0","/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var idList = [];\n        var nameRepeatCount = {};\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n\n            indices.push(idx);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (\n                    diff <= maxDistance\n                    && (dist < minDist\n                        // For the case of two data are same on xAxis, which has sequence data.\n                        // Show the nearest index\n                        // https://github.com/ecomfe/echarts/issues/2869\n                        || (dist === minDist && diff > 0)\n                    )\n                ) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/List.js\n// module id = 20\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../util/format');\n    var classUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/lib/core/env');\n    var layout = require('../util/layout');\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', this.getInitialData(option, ecModel));\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return [coordDim];\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return dataDim;\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var result = [];\n\n                zrUtil.each(value, function (val, idx) {\n                    var dimInfo = data.getDimensionInfo(idx);\n                    var dimType = dimInfo && dimInfo.type;\n                    var valStr;\n\n                    if (dimType === 'ordinal') {\n                        valStr = val + '';\n                    }\n                    else if (dimType === 'time') {\n                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);\n                    }\n                    else {\n                        valStr = addCommas(val);\n                    }\n\n                    valStr && result.push(valStr);\n                });\n\n                return result.join(', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = encodeHTML(\n                zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value)\n            );\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + '\"></span>';\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            return !multipleSeries\n                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n                    + (name\n                        ? encodeHTML(name) + ' : ' + formattedValue\n                        : formattedValue\n                    )\n                  )\n                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Array.<number>} data indices.\n         */\n        getAxisTooltipDataIndex: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Series.js\n// module id = 21\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 22\n// module chunks = 0","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 23\n// module chunks = 0","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 24\n// module chunks = 0","/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 25\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Interface of Coordinate System Class\n     *\n     * create:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *     @return {Object} coordinate system instance\n     *\n     * update:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *\n     * convertToPixel:\n     * convertFromPixel:\n     *     These two methods is also responsible for determine whether this\n     *     coodinate system is applicable to the given `finder`.\n     *     Each coordinate system will be tried, util one returns none\n     *     null/undefined value.\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {Object} finder\n     *     @param {Array|number} value\n     *     @return {Array|number} convert result.\n     *\n     * containPoint:\n     *     @param {Array.<number>} point In pixel coordinate system.\n     *     @return {boolean}\n     */\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/CoordinateSystem.js\n// module id = 26\n// module chunks = 0","\n\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/lib/core/util');\n    var textContain = require('zrender/lib/contain/text');\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = originalExtent[1] - originalExtent[0];\n        }\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        axis.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            var origin = (extent[1] + extent[0]) / 2;\n            scale.setExtent(\n                intervalScale * (extent[0] - origin) + origin,\n                intervalScale * (extent[1] - origin) + origin\n            );\n            scale.niceExtent(splitNumber);\n        }\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    module.exports = axisHelper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisHelper.js\n// module id = 27\n// module chunks = 0","/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} [defaultNames]    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} [extraPrefix]             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n                dimensions[i] = guessOrdinal(data, i)\n                    ? {type: 'ordinal', name: name}\n                    : name;\n            }\n        }\n\n        return dimensions;\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (zrUtil.isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/helper/completeDimensions.js\n// module id = 28\n// module chunks = 0","// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/makeStyleMapper.js\n// module id = 29\n// module chunks = 0","/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            var interval = this._interval;\n            var extent = this._extent;\n            var ticks = [];\n\n            // Consider this case: using dataZoom toolbox, zoom and zoom.\n            var safeLimit = 10000;\n\n            if (interval) {\n                var niceExtent = this._niceExtent;\n                var precision = getPrecisionSafe(interval) + 2;\n\n                if (extent[0] < niceExtent[0]) {\n                    ticks.push(extent[0]);\n                }\n                var tick = niceExtent[0];\n\n                while (tick <= niceExtent[1]) {\n                    ticks.push(tick);\n                    // Avoid rounding error\n                    tick = roundingErrorFix(tick + interval, precision);\n                    if (ticks.length > safeLimit) {\n                        return [];\n                    }\n                }\n                // Consider this case: the last item of ticks is smaller\n                // than niceExtent[1] and niceExtent[1] === extent[1].\n                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n                    ticks.push(extent[1]);\n                }\n            }\n\n            return ticks;\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} n\n         * @return {number}\n         */\n        getLabel: function (data) {\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         */\n        niceTicks: function (splitNumber) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n            // var niceSpan = numberUtil.nice(span, false);\n            var step = roundingErrorFix(\n                numberUtil.nice(span / splitNumber, true),\n                Math.max(\n                    getPrecisionSafe(extent[0]),\n                    getPrecisionSafe(extent[1])\n                // extent may be [0, 1], and step should have 1 more digits.\n                // To make it safe we add 2 more digits\n                ) + 2\n            );\n\n            var precision = getPrecisionSafe(step) + 2;\n            // Niced extent inside original extent\n            var niceExtent = [\n                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n            ];\n\n            this._interval = step;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [splitNumber = 5] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Interval.js\n// module id = 30\n// module chunks = 0","/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = require('../util/clazz');\n\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Scale.js\n// module id = 31\n// module chunks = 0","'use strict';\n// Symbol factory\n\n\n    var graphic = require('./graphic');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/symbol.js\n// module id = 32\n// module chunks = 0","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Chart.js\n// module id = 33\n// module chunks = 0","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 34\n// module chunks = 0","/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 35\n// module chunks = 0","'use strict';\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 36\n// module chunks = 0","'use strict';\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 37\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    require('../coord/cartesian/Grid');\n\n    require('./bar/BarSeries');\n    require('./bar/BarView');\n\n    var barLayoutGrid = require('../layout/barGrid');\n    var echarts = require('../echarts');\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar.js\n// module id = 38\n// module chunks = 0","'use strict';\n\n\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            completeDimensions(dimensions, data);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, ['lng', 'lat', 'value'])\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/createListFromArray.js\n// module id = 39\n// module chunks = 0","'use strict';\n\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('../coord/cartesian/Grid');\n\n    require('./axis');\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/grid.js\n// module id = 40\n// module chunks = 0","\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/processor/dataFilter.js\n// module id = 41\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazz = require('./clazz');\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/component.js\n// module id = 42\n// module chunks = 0","// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        // FIXME Performance\n                        var itemModel = dataAll.getItemModel(rawIdx);\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/dataColor.js\n// module id = 43\n// module chunks = 0","\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/symbol.js\n// module id = 44\n// module chunks = 0","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 45\n// module chunks = 0","/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 46\n// module chunks = 0","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 47\n// module chunks = 0","/*!\n * Vue.js v2.2.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'function' && vm.options\n      ? vm.options.name\n      : vm._isVue\n        ? vm.$options.name || vm.$options._componentTag\n        : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === \"<Anonymous>\") {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = target.__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = target.__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$3) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Error in \" + info + \":\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      if (!cur.fns) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (!oldHook) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (oldHook.fns && oldHook.merged) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns\n) {\n  var res = {};\n  for (var i = 0; i < fns.length; i++) {\n    res[fns[i][0]] = fns[i][1];\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive == null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar queue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id, vm;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // call updated hooks\n  index = queue.length;\n  while (index--) {\n    watcher = queue[index];\n    vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n\n  resetSchedulerState();\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    if (!vnode.componentInstance._isMounted) {\n      vnode.componentInstance._isMounted = true;\n      callHook(vnode.componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      activateChildComponent(vnode.componentInstance, true /* direct */);\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    if (!vnode.componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        vnode.componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(vnode.componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (data.model) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractProps(data, Ctor);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && attrs.hasOwnProperty(keyInLowerCase)\n        ) {\n          warn(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is not declared in component \" +\n            (formatComponentName(Ctor)) + \". Note that HTML attributes are \" +\n            \"case-insensitive and camelCased props need to use their kebab-case \" +\n            \"equivalents when using in-DOM templates. You should probably use \" +\n            \"\\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (on[event]) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = _toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var inject = vm.$options.inject;\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          vm[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n    }\n  }\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      mark('vue-perf-init');\n    }\n\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark('vue-perf-init-end');\n      measure(((vm._name) + \" init\"), 'vue-perf-init', 'vue-perf-init-end');\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    for (var i = 0; i < latest.length; i++) {\n      if (sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (pattern instanceof RegExp) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cachedNode);\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    if (!vnode.componentInstance._inactive) {\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$3.version = '2.2.4';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.componentInstance) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (s) {\n  return s == null\n}\n\nfunction isDef (s) {\n  return s != null\n}\n\nfunction sameVnode (vnode1, vnode2) {\n  return (\n    vnode1.key === vnode2.key &&\n    vnode1.tag === vnode2.tag &&\n    vnode1.isComment === vnode2.isComment &&\n    !vnode1.data === !vnode2.data\n  )\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks[i]] !== undefined) { cbs[hooks[i]].push(modules[j][hooks[i]]); }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (parent) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (vnode.isComment) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isReactivated) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (vnode.data.pendingInsert) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (parent) {\n      if (ref) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (i.create) { i.create(emptyNode, vnode); }\n      if (i.insert) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (rm || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (!rm) {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } else {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (vnode.isStatic &&\n        oldVnode.isStatic &&\n        vnode.key === oldVnode.key &&\n        (vnode.isCloned || vnode.isOnce)) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    var hasData = isDef(data);\n    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (hasData && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (hasData) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (initial && vnode.parent) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (vnode.tag) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (!vnode) {\n      if (oldVnode) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (!oldVnode) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (hydrating) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (vnode.parent) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (parentElm$1 !== null) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important\n) {\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + value + \"=$$c}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (on[RANGE_TOKEN]) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (on[CHECKBOX_RADIO_TOKEN]) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once,\n  capture\n) {\n  if (once) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (!fn) { return false }\n  var invokerFns = fn.fns;\n  if (invokerFns) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      config.productionTip !== false &&\n      inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n            (i > pos || !tagName) &&\n            options.warn) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (events, native) {\n  var res = native ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  return \"[\" + key + \",function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}]\"\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot') {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);\n  if (keywordMatch) {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nexport default Vue$3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue/dist/vue.esm.js\n// module id = 48\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap) {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n  var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n  return '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 51\n// module chunks = 0","/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolUtil = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var numberUtil = require('../../util/number');\n\n    function getSymbolSize(data, idx) {\n        var symbolSize = data.getItemVisual(idx, 'symbolSize');\n        return symbolSize instanceof Array\n            ? symbolSize.slice()\n            : [+symbolSize, +symbolSize];\n    }\n\n    function getScale(symbolSize) {\n        return [symbolSize[0] / 2, symbolSize[1] / 2];\n    }\n\n    /**\n     * @constructor\n     * @alias {module:echarts/chart/helper/Symbol}\n     * @param {module:echarts/data/List} data\n     * @param {number} idx\n     * @extends {module:zrender/graphic/Group}\n     */\n    function Symbol(data, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this.updateData(data, idx, seriesScope);\n    }\n\n    var symbolProto = Symbol.prototype;\n\n    function driftSymbol(dx, dy) {\n        this.parent.drift(dx, dy);\n    }\n\n    symbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n        // Remove paths created before\n        this.removeAll();\n\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // var symbolPath = symbolUtil.createSymbol(\n        //     symbolType, -0.5, -0.5, 1, 1, color\n        // );\n        // If width/height are set too small (e.g., set to 1) on ios10\n        // and macOS Sierra, a circle stroke become a rect, no matter what\n        // the scale is set. So we set width/height as 2. See #4150.\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -1, -1, 2, 2, color\n        );\n\n        symbolPath.attr({\n            z2: 100,\n            culling: true,\n            scale: [0, 0]\n        });\n        // Rewrite drift method\n        symbolPath.drift = driftSymbol;\n\n        graphic.initProps(symbolPath, {\n            scale: getScale(symbolSize)\n        }, seriesModel, idx);\n        this._symbolType = symbolType;\n\n        this.add(symbolPath);\n    };\n\n    /**\n     * Stop animation\n     * @param {boolean} toLastFrame\n     */\n    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n        this.childAt(0).stopAnimation(toLastFrame);\n    };\n\n    /**\n     * Get symbol path element\n     */\n    symbolProto.getSymbolPath = function () {\n        return this.childAt(0);\n    };\n\n    /**\n     * Get scale(aka, current symbol size).\n     * Including the change caused by animation\n     */\n    symbolProto.getScale = function () {\n        return this.childAt(0).scale;\n    };\n\n    /**\n     * Highlight symbol\n     */\n    symbolProto.highlight = function () {\n        this.childAt(0).trigger('emphasis');\n    };\n\n    /**\n     * Downplay symbol\n     */\n    symbolProto.downplay = function () {\n        this.childAt(0).trigger('normal');\n    };\n\n    /**\n     * @param {number} zlevel\n     * @param {number} z\n     */\n    symbolProto.setZ = function (zlevel, z) {\n        var symbolPath = this.childAt(0);\n        symbolPath.zlevel = zlevel;\n        symbolPath.z = z;\n    };\n\n    symbolProto.setDraggable = function (draggable) {\n        var symbolPath = this.childAt(0);\n        symbolPath.draggable = draggable;\n        symbolPath.cursor = draggable ? 'move' : 'pointer';\n    };\n\n    /**\n     * Update symbol properties\n     * @param  {module:echarts/data/List} data\n     * @param  {number} idx\n     */\n    symbolProto.updateData = function (data, idx, seriesScope) {\n        this.silent = false;\n\n        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n        var seriesModel = data.hostModel;\n        var symbolSize = getSymbolSize(data, idx);\n\n        if (symbolType !== this._symbolType) {\n            this._createSymbol(symbolType, data, idx, symbolSize);\n        }\n        else {\n            var symbolPath = this.childAt(0);\n            graphic.updateProps(symbolPath, {\n                scale: getScale(symbolSize)\n            }, seriesModel, idx);\n        }\n        this._updateCommon(data, idx, symbolSize, seriesScope);\n        this._seriesModel = seriesModel;\n    };\n\n    // Update common properties\n    var normalStyleAccessPath = ['itemStyle', 'normal'];\n    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n    var normalLabelAccessPath = ['label', 'normal'];\n    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\n    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // Reset style\n        if (symbolPath.type !== 'image') {\n            symbolPath.useStyle({\n                strokeNoScale: true\n            });\n        }\n\n        seriesScope = seriesScope || null;\n\n        var itemStyle = seriesScope && seriesScope.itemStyle;\n        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n\n        if (!seriesScope || data.hasItemOption) {\n            var itemModel = data.getItemModel(idx);\n\n            // Color must be excluded.\n            // Because symbol provide setColor individually to set fill and stroke\n            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\n            symbolRotate = itemModel.getShallow('symbolRotate');\n            symbolOffset = itemModel.getShallow('symbolOffset');\n\n            labelModel = itemModel.getModel(normalLabelAccessPath);\n            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n            hoverAnimation = itemModel.getShallow('hoverAnimation');\n        }\n        else {\n            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n        }\n\n        var elStyle = symbolPath.style;\n\n        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n        if (symbolOffset) {\n            symbolPath.attr('position', [\n                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n            ]);\n        }\n\n        // PENDING setColor before setStyle!!!\n        symbolPath.setColor(color);\n\n        symbolPath.setStyle(itemStyle);\n\n        var opacity = data.getItemVisual(idx, 'opacity');\n        if (opacity != null) {\n            elStyle.opacity = opacity;\n        }\n\n        // Get last value dim\n        var dimensions = data.dimensions.slice();\n        var valueDim;\n        var dataType;\n        while (dimensions.length && (\n            valueDim = dimensions.pop(),\n            dataType = data.getDimensionInfo(valueDim).type,\n            dataType === 'ordinal' || dataType === 'time'\n        )) {} // jshint ignore:line\n\n        if (valueDim != null && labelModel.getShallow('show')) {\n            graphic.setText(elStyle, labelModel, color);\n            elStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'normal'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            elStyle.text = '';\n        }\n\n        if (valueDim != null && hoverLabelModel.getShallow('show')) {\n            graphic.setText(hoverItemStyle, hoverLabelModel, color);\n            hoverItemStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'emphasis'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            hoverItemStyle.text = '';\n        }\n\n        symbolPath.off('mouseover')\n            .off('mouseout')\n            .off('emphasis')\n            .off('normal');\n\n        symbolPath.hoverStyle = hoverItemStyle;\n\n        graphic.setHoverStyle(symbolPath);\n\n        var scale = getScale(symbolSize);\n\n        if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n            var onEmphasis = function() {\n                var ratio = scale[1] / scale[0];\n                this.animateTo({\n                    scale: [\n                        Math.max(scale[0] * 1.1, scale[0] + 3),\n                        Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)\n                    ]\n                }, 400, 'elasticOut');\n            };\n            var onNormal = function() {\n                this.animateTo({\n                    scale: scale\n                }, 400, 'elasticOut');\n            };\n            symbolPath.on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n    };\n\n    symbolProto.fadeOut = function (cb) {\n        var symbolPath = this.childAt(0);\n        // Avoid mistaken hover when fading out\n        this.silent = true;\n        // Not show text when animating\n        symbolPath.style.text = '';\n        graphic.updateProps(symbolPath, {\n            scale: [0, 0]\n        }, this._seriesModel, this.dataIndex, cb);\n    };\n\n    zrUtil.inherits(Symbol, graphic.Group);\n\n    module.exports = Symbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/Symbol.js\n// module id = 52\n// module chunks = 0","/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n\n    var graphic = require('../../util/graphic');\n    var Symbol = require('./Symbol');\n\n    /**\n     * @constructor\n     * @alias module:echarts/chart/helper/SymbolDraw\n     * @param {module:zrender/graphic/Group} [symbolCtor]\n     */\n    function SymbolDraw(symbolCtor) {\n        this.group = new graphic.Group();\n\n        this._symbolCtor = symbolCtor || Symbol;\n    }\n\n    var symbolDrawProto = SymbolDraw.prototype;\n\n    function symbolNeedsDraw(data, idx, isIgnore) {\n        var point = data.getItemLayout(idx);\n        // Is an object\n        // if (point && point.hasOwnProperty('point')) {\n        //     point = point.point;\n        // }\n        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n                    && data.getItemVisual(idx, 'symbol') !== 'none';\n    }\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     * @param {Array.<boolean>} [isIgnore]\n     */\n    symbolDrawProto.updateData = function (data, isIgnore) {\n        var group = this.group;\n        var seriesModel = data.hostModel;\n        var oldData = this._data;\n\n        var SymbolCtor = this._symbolCtor;\n\n        var seriesScope = {\n            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n            symbolRotate: seriesModel.get('symbolRotate'),\n            symbolOffset: seriesModel.get('symbolOffset'),\n            hoverAnimation: seriesModel.get('hoverAnimation'),\n\n            labelModel: seriesModel.getModel('label.normal'),\n            hoverLabelModel: seriesModel.getModel('label.emphasis')\n        };\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                var point = data.getItemLayout(newIdx);\n                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n                    symbolEl.attr('position', point);\n                    data.setItemGraphicEl(newIdx, symbolEl);\n                    group.add(symbolEl);\n                }\n            })\n            .update(function (newIdx, oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                var point = data.getItemLayout(newIdx);\n                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    group.remove(symbolEl);\n                    return;\n                }\n                if (!symbolEl) {\n                    symbolEl = new SymbolCtor(data, newIdx);\n                    symbolEl.attr('position', point);\n                }\n                else {\n                    symbolEl.updateData(data, newIdx, seriesScope);\n                    graphic.updateProps(symbolEl, {\n                        position: point\n                    }, seriesModel);\n                }\n\n                // Add back\n                group.add(symbolEl);\n\n                data.setItemGraphicEl(newIdx, symbolEl);\n            })\n            .remove(function (oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                el && el.fadeOut(function () {\n                    group.remove(el);\n                });\n            })\n            .execute();\n\n        this._data = data;\n    };\n\n    symbolDrawProto.updateLayout = function () {\n        var data = this._data;\n        if (data) {\n            // Not use animation\n            data.eachItemGraphicEl(function (el, idx) {\n                var point = data.getItemLayout(idx);\n                el.attr('position', point);\n            });\n        }\n    };\n\n    symbolDrawProto.remove = function (enableAnimation) {\n        var group = this.group;\n        var data = this._data;\n        if (data) {\n            if (enableAnimation) {\n                data.eachItemGraphicEl(function (el) {\n                    el.fadeOut(function () {\n                        group.remove(el);\n                    });\n                });\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    };\n\n    module.exports = SymbolDraw;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/SymbolDraw.js\n// module id = 53\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n\n    require('../action/createDataSelectAction')('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        require('./pie/pieLayout'), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie.js\n// module id = 54\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/lib/core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n            // To radian.\n            labelRotation = labelRotation * PI / 180;\n\n            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelBeforeFormat = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelBeforeFormat;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            function isTwoLabelOverlapped(current, next) {\n                var firstRect = current && current.getBoundingRect().clone();\n                var nextRect = next && next.getBoundingRect().clone();\n                if (firstRect && nextRect) {\n                    firstRect.applyTransform(current.getLocalTransform());\n                    nextRect.applyTransform(next.getLocalTransform());\n                    return firstRect.intersect(nextRect);\n                }\n            }\n\n            // If min or max are user set, we need to check\n            // If the tick on min(max) are overlap on their neighbour tick\n            // If they are overlapped, we need to hide the min(max) tick label\n            if (axisModel.getMin() != null) {\n                var firstLabel = textEls[0];\n                var nextLabel = textEls[1];\n                if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                    firstLabel.ignore = true;\n                }\n            }\n            if (axisModel.getMax() != null) {\n                var lastLabel = textEls[textEls.length - 1];\n                var prevLabel = textEls[textEls.length - 2];\n                if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                    lastLabel.ignore = true;\n                }\n            }\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.verticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisBuilder.js\n// module id = 55\n// module chunks = 0","\n\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/lib/core/util');\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * When axis extent depends on data and no data exists,\n         * axis ticks should not be drawn, which is named 'blank'.\n         */\n        isBlank: function () {\n            return this._isBlank;\n        },\n\n        /**\n         * When axis extent depends on data and no data exists,\n         * axis ticks should not be drawn, which is named 'blank'.\n         */\n        setBlank: function (isBlank) {\n            this._isBlank = isBlank;\n        }\n\n    };\n\n    module.exports = Axis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/Axis.js\n// module id = 56\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // \n        z: 0,                       // \n        // \n        inverse: false,\n\n        // \n        name: '',\n        // 'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // degree\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // \n        nameTextStyle: {},\n        // \n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        // \n        axisLine: {\n            // show\n            show: true,\n            onZero: true,\n            // lineStyle\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // grid\n            inside: false,\n            // length\n            length: 5,\n            // lineStyle\n            lineStyle: {\n                width: 1\n            }\n        },\n        // axis.axisLabel\n        axisLabel: {\n            show: true,\n            // grid\n            inside: false,\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            // TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // lineStylelineStyle\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        splitArea: {\n            // show\n            show: false,\n            // areaStyleareaStyle\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // \n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // \n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            // Default with axisTick\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // \n        boundaryGap: [0, 0],\n        // ,  'dataMin' \n        // min: null,\n        //  'dataMax' \n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 0_min_max\n        // scale: false,\n        // 5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n    var logAxis = zrUtil.defaults({\n        logBase: 10\n    }, valueAxis);\n    logAxis.scale = true;\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisDefault.js\n// module id = 57\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj;\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCommonMixin.js\n// module id = 58\n// module chunks = 0","'use strict';\n\n\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/lib/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         * @return {module:echarts/model/Component}\n         */\n        getCoordSysModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.option.gridIndex,\n                id: this.option.gridId\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/AxisModel.js\n// module id = 59\n// module chunks = 0","/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    //  GridModel, AxisModel \n    require('./GridModel');\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.getCoordSysModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var textStyleModel = axisModel.getModel('axisLabel.textStyle');\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = textStyleModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this._model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this._model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n        else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex\n                    || coordList[i].getAxis('y').index === yAxisIndex\n                ) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtentFromData(data, dim);\n            });\n        }\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.getCoordSysModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Grid.js\n// module id = 60\n// module chunks = 0","\n\n    module.exports = function (seriesType, ecModel) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys) {\n                var dims = coordSys.dimensions;\n\n                if (coordSys.type === 'singleAxis') {\n                    data.each(dims[0], function (x, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n                    });\n                }\n                else {\n                    data.each(dims, function (x, y, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(\n                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n                        );\n                    }, true);\n                }\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/layout/points.js\n// module id = 61\n// module chunks = 0","\n\n    var classUtil = require('../../util/clazz');\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/colorPalette.js\n// module id = 62\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [],\n\tfixUrls = require(\"./fixUrls\");\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\toptions.attrs.type = \"text/css\";\n\n\tattachTagAttrs(styleElement, options.attrs);\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\tattachTagAttrs(linkElement, options.attrs);\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction attachTagAttrs(element, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\telement.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement, options);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls){\n\t\tcss = fixUrls(css);\n\t}\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 63\n// module chunks = 0","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 64\n// module chunks = 0","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 65\n// module chunks = 0","\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 66\n// module chunks = 0","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 67\n// module chunks = 0","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 68\n// module chunks = 0","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 69\n// module chunks = 0","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                // \n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 70\n// module chunks = 0","\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 71\n// module chunks = 0","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 72\n// module chunks = 0","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 73\n// module chunks = 0","\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t? self // if in worker\n\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = (function(){\n\n// Private helper vars\nvar lang = /\\blang(?:uage)?-(\\w+)\\b/i;\nvar uniqueId = 0;\n\nvar _ = _self.Prism = {\n\tutil: {\n\t\tencode: function (tokens) {\n\t\t\tif (tokens instanceof Token) {\n\t\t\t\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n\t\t\t} else if (_.util.type(tokens) === 'Array') {\n\t\t\t\treturn tokens.map(_.util.encode);\n\t\t\t} else {\n\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t}\n\t\t},\n\n\t\ttype: function (o) {\n\t\t\treturn Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n\t\t},\n\n\t\tobjId: function (obj) {\n\t\t\tif (!obj['__id']) {\n\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t}\n\t\t\treturn obj['__id'];\n\t\t},\n\n\t\t// Deep clone a language definition (e.g. to extend it)\n\t\tclone: function (o) {\n\t\t\tvar type = _.util.type(o);\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'Object':\n\t\t\t\t\tvar clone = {};\n\n\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tclone[key] = _.util.clone(o[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn clone;\n\n\t\t\t\tcase 'Array':\n\t\t\t\t\t// Check for existence for IE8\n\t\t\t\t\treturn o.map && o.map(function(v) { return _.util.clone(v); });\n\t\t\t}\n\n\t\t\treturn o;\n\t\t}\n\t},\n\n\tlanguages: {\n\t\textend: function (id, redef) {\n\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\tfor (var key in redef) {\n\t\t\t\tlang[key] = redef[key];\n\t\t\t}\n\n\t\t\treturn lang;\n\t\t},\n\n\t\t/**\n\t\t * Insert a token before another token in a language literal\n\t\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n\t\t * we cannot just provide an object, we need anobject and a key.\n\t\t * @param inside The key (or language id) of the parent\n\t\t * @param before The key to insert before. If not provided, the function appends instead.\n\t\t * @param insert Object with the key/value pairs to insert\n\t\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n\t\t */\n\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\troot = root || _.languages;\n\t\t\tvar grammar = root[inside];\n\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tinsert = arguments[1];\n\n\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\tgrammar[newToken] = insert[newToken];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn grammar;\n\t\t\t}\n\n\t\t\tvar ret = {};\n\n\t\t\tfor (var token in grammar) {\n\n\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\tif (token == before) {\n\n\t\t\t\t\t\tfor (var newToken in insert) {\n\n\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update references in other language definitions\n\t\t\t_.languages.DFS(_.languages, function(key, value) {\n\t\t\t\tif (value === root[inside] && key != inside) {\n\t\t\t\t\tthis[key] = ret;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn root[inside] = ret;\n\t\t},\n\n\t\t// Traverse a language definition with Depth First Search\n\t\tDFS: function(o, callback, type, visited) {\n\t\t\tvisited = visited || {};\n\t\t\tfor (var i in o) {\n\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\tif (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, null, visited);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {\n\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;\n\t\t\t\t\t\t_.languages.DFS(o[i], callback, i, visited);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tplugins: {},\n\n\thighlightAll: function(async, callback) {\n\t\tvar env = {\n\t\t\tcallback: callback,\n\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t};\n\n\t\t_.hooks.run(\"before-highlightall\", env);\n\n\t\tvar elements = env.elements || document.querySelectorAll(env.selector);\n\n\t\tfor (var i=0, element; element = elements[i++];) {\n\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t}\n\t},\n\n\thighlightElement: function(element, async, callback) {\n\t\t// Find language\n\t\tvar language, grammar, parent = element;\n\n\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\tif (parent) {\n\t\t\tlanguage = (parent.className.match(lang) || [,''])[1].toLowerCase();\n\t\t\tgrammar = _.languages[language];\n\t\t}\n\n\t\t// Set language on the element, if not present\n\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\n\t\t// Set language on the parent, for styling\n\t\tparent = element.parentNode;\n\n\t\tif (/pre/i.test(parent.nodeName)) {\n\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\t}\n\n\t\tvar code = element.textContent;\n\n\t\tvar env = {\n\t\t\telement: element,\n\t\t\tlanguage: language,\n\t\t\tgrammar: grammar,\n\t\t\tcode: code\n\t\t};\n\n\t\t_.hooks.run('before-sanity-check', env);\n\n\t\tif (!env.code || !env.grammar) {\n\t\t\tif (env.code) {\n\t\t\t\tenv.element.textContent = env.code;\n\t\t\t}\n\t\t\t_.hooks.run('complete', env);\n\t\t\treturn;\n\t\t}\n\n\t\t_.hooks.run('before-highlight', env);\n\n\t\tif (async && _self.Worker) {\n\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\tworker.onmessage = function(evt) {\n\t\t\t\tenv.highlightedCode = evt.data;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t};\n\n\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\tlanguage: env.language,\n\t\t\t\tcode: env.code,\n\t\t\t\timmediateClose: true\n\t\t\t}));\n\t\t}\n\t\telse {\n\t\t\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\n\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\tcallback && callback.call(element);\n\n\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t_.hooks.run('complete', env);\n\t\t}\n\t},\n\n\thighlight: function (text, grammar, language) {\n\t\tvar tokens = _.tokenize(text, grammar);\n\t\treturn Token.stringify(_.util.encode(tokens), language);\n\t},\n\n\ttokenize: function(text, grammar, language) {\n\t\tvar Token = _.Token;\n\n\t\tvar strarr = [text];\n\n\t\tvar rest = grammar.rest;\n\n\t\tif (rest) {\n\t\t\tfor (var token in rest) {\n\t\t\t\tgrammar[token] = rest[token];\n\t\t\t}\n\n\t\t\tdelete grammar.rest;\n\t\t}\n\n\t\ttokenloop: for (var token in grammar) {\n\t\t\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tvar pattern = patterns[j],\n\t\t\t\t\tinside = pattern.inside,\n\t\t\t\t\tlookbehind = !!pattern.lookbehind,\n\t\t\t\t\tgreedy = !!pattern.greedy,\n\t\t\t\t\tlookbehindLength = 0,\n\t\t\t\t\talias = pattern.alias;\n\n\t\t\t\tif (greedy && !pattern.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = pattern.pattern.toString().match(/[imuy]*$/)[0];\n\t\t\t\t\tpattern.pattern = RegExp(pattern.pattern.source, flags + \"g\");\n\t\t\t\t}\n\n\t\t\t\tpattern = pattern.pattern || pattern;\n\n\t\t\t\t// Dont cache length as it changes during the loop\n\t\t\t\tfor (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {\n\n\t\t\t\t\tvar str = strarr[i];\n\n\t\t\t\t\tif (strarr.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\tbreak tokenloop;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpattern.lastIndex = 0;\n\n\t\t\t\t\tvar match = pattern.exec(str),\n\t\t\t\t\t    delNum = 1;\n\n\t\t\t\t\t// Greedy patterns can override/remove up to two previously matched tokens\n\t\t\t\t\tif (!match && greedy && i != strarr.length - 1) {\n\t\t\t\t\t\tpattern.lastIndex = pos;\n\t\t\t\t\t\tmatch = pattern.exec(text);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index + (lookbehind ? match[1].length : 0),\n\t\t\t\t\t\t    to = match.index + match[0].length,\n\t\t\t\t\t\t    k = i,\n\t\t\t\t\t\t    p = pos;\n\n\t\t\t\t\t\tfor (var len = strarr.length; k < len && p < to; ++k) {\n\t\t\t\t\t\t\tp += strarr[k].length;\n\t\t\t\t\t\t\t// Move the index i to the element in strarr that is closest to from\n\t\t\t\t\t\t\tif (from >= p) {\n\t\t\t\t\t\t\t\t++i;\n\t\t\t\t\t\t\t\tpos = p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If strarr[i] is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\t * If strarr[k - 1] is greedy we are in conflict with another greedy pattern\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (strarr[i] instanceof Token || strarr[k - 1].greedy) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Number of tokens to delete and replace with the new match\n\t\t\t\t\t\tdelNum = k - i;\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(lookbehind) {\n\t\t\t\t\t\tlookbehindLength = match[1].length;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar from = match.index + lookbehindLength,\n\t\t\t\t\t    match = match[0].slice(lookbehindLength),\n\t\t\t\t\t    to = from + match.length,\n\t\t\t\t\t    before = str.slice(0, from),\n\t\t\t\t\t    after = str.slice(to);\n\n\t\t\t\t\tvar args = [i, delNum];\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\targs.push(before);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);\n\n\t\t\t\t\targs.push(wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\targs.push(after);\n\t\t\t\t\t}\n\n\t\t\t\t\tArray.prototype.splice.apply(strarr, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn strarr;\n\t},\n\n\thooks: {\n\t\tall: {},\n\n\t\tadd: function (name, callback) {\n\t\t\tvar hooks = _.hooks.all;\n\n\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\thooks[name].push(callback);\n\t\t},\n\n\t\trun: function (name, env) {\n\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i=0, callback; callback = callbacks[i++];) {\n\t\t\t\tcallback(env);\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar Token = _.Token = function(type, content, alias, matchedStr, greedy) {\n\tthis.type = type;\n\tthis.content = content;\n\tthis.alias = alias;\n\t// Copy of the full string this token was created from\n\tthis.length = (matchedStr || \"\").length|0;\n\tthis.greedy = !!greedy;\n};\n\nToken.stringify = function(o, language, parent) {\n\tif (typeof o == 'string') {\n\t\treturn o;\n\t}\n\n\tif (_.util.type(o) === 'Array') {\n\t\treturn o.map(function(element) {\n\t\t\treturn Token.stringify(element, language, o);\n\t\t}).join('');\n\t}\n\n\tvar env = {\n\t\ttype: o.type,\n\t\tcontent: Token.stringify(o.content, language, parent),\n\t\ttag: 'span',\n\t\tclasses: ['token', o.type],\n\t\tattributes: {},\n\t\tlanguage: language,\n\t\tparent: parent\n\t};\n\n\tif (env.type == 'comment') {\n\t\tenv.attributes['spellcheck'] = 'true';\n\t}\n\n\tif (o.alias) {\n\t\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n\t\tArray.prototype.push.apply(env.classes, aliases);\n\t}\n\n\t_.hooks.run('wrap', env);\n\n\tvar attributes = Object.keys(env.attributes).map(function(name) {\n\t\treturn name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t}).join(' ');\n\n\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';\n\n};\n\nif (!_self.document) {\n\tif (!_self.addEventListener) {\n\t\t// in Node.js\n\t\treturn _self.Prism;\n\t}\n \t// In worker\n\t_self.addEventListener('message', function(evt) {\n\t\tvar message = JSON.parse(evt.data),\n\t\t    lang = message.language,\n\t\t    code = message.code,\n\t\t    immediateClose = message.immediateClose;\n\n\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\tif (immediateClose) {\n\t\t\t_self.close();\n\t\t}\n\t}, false);\n\n\treturn _self.Prism;\n}\n\n//Get current script and highlight\nvar script = document.currentScript || [].slice.call(document.getElementsByTagName(\"script\")).pop();\n\nif (script) {\n\t_.filename = script.src;\n\n\tif (document.addEventListener && !script.hasAttribute('data-manual')) {\n\t\tif(document.readyState !== \"loading\") {\n\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(_.highlightAll);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(_.highlightAll, 16);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\n\t\t}\n\t}\n}\n\nreturn _self.Prism;\n\n})();\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n\tglobal.Prism = Prism;\n}\n\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n\t'comment': /<!--[\\w\\W]*?-->/,\n\t'prolog': /<\\?[\\w\\W]+?\\?>/,\n\t'doctype': /<!DOCTYPE[\\w\\W]+?>/i,\n\t'cdata': /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\\\1|\\\\?(?!\\1)[\\w\\W])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /[=>\"']/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': /&#?[\\da-z]{1,8};/i\n};\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function(env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nPrism.languages.xml = Prism.languages.markup;\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\nPrism.languages.css = {\n\t'comment': /\\/\\*[\\w\\W]*?\\*\\//,\n\t'atrule': {\n\t\tpattern: /@[\\w-]+?.*?(;|(?=\\s*\\{))/i,\n\t\tinside: {\n\t\t\t'rule': /@[\\w-]+/\n\t\t\t// See rest below\n\t\t}\n\t},\n\t'url': /url\\((?:([\"'])(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1|.*?)\\)/i,\n\t'selector': /[^\\{\\}\\s][^\\{\\};]*?(?=\\s*\\{)/,\n\t'string': {\n\t\tpattern: /(\"|')(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'property': /(\\b|\\B)[\\w-]+(?=\\s*:)/i,\n\t'important': /\\B!important\\b/i,\n\t'function': /[-a-z0-9]+(?=\\()/i,\n\t'punctuation': /[(){};:]/\n};\n\nPrism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'style': {\n\t\t\tpattern: /(<style[\\w\\W]*?>)[\\w\\W]*?(?=<\\/style>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.css,\n\t\t\talias: 'language-css'\n\t\t}\n\t});\n\t\n\tPrism.languages.insertBefore('inside', 'attr-value', {\n\t\t'style-attr': {\n\t\t\tpattern: /\\s*style=(\"|').*?\\1/i,\n\t\t\tinside: {\n\t\t\t\t'attr-name': {\n\t\t\t\t\tpattern: /^\\s*style/i,\n\t\t\t\t\tinside: Prism.languages.markup.tag.inside\n\t\t\t\t},\n\t\t\t\t'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /.+/i,\n\t\t\t\t\tinside: Prism.languages.css\n\t\t\t\t}\n\t\t\t},\n\t\t\talias: 'language-css'\n\t\t}\n\t}, Prism.languages.markup.tag);\n}\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\tpunctuation: /(\\.|\\\\)/\n\t\t}\n\t},\n\t'keyword': /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n\t'boolean': /\\b(true|false)\\b/,\n\t'function': /[a-z0-9_]+(?=\\()/i,\n\t'number': /\\b-?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+-]?\\d+)?)\\b/i,\n\t'operator': /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'keyword': /\\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,\n\t'number': /\\b-?(0x[\\dA-Fa-f]+|0b[01]+|0o[0-7]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|Infinity)\\b/,\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*(?=\\()/i,\n\t'operator': /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*\\*?|\\/|~|\\^|%|\\.{3}/\n});\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\\\\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})]))/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'template-string': {\n\t\tpattern: /`(?:\\\\\\\\|\\\\?[^\\\\])*?`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /\\$\\{[^}]+\\}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t}\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.insertBefore('markup', 'tag', {\n\t\t'script': {\n\t\t\tpattern: /(<script[\\w\\W]*?>)[\\w\\W]*?(?=<\\/script>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript,\n\t\t\talias: 'language-javascript'\n\t\t}\n\t});\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n\tif (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {\n\t\treturn;\n\t}\n\n\tself.Prism.fileHighlight = function() {\n\n\t\tvar Extensions = {\n\t\t\t'js': 'javascript',\n\t\t\t'py': 'python',\n\t\t\t'rb': 'ruby',\n\t\t\t'ps1': 'powershell',\n\t\t\t'psm1': 'powershell',\n\t\t\t'sh': 'bash',\n\t\t\t'bat': 'batch',\n\t\t\t'h': 'c',\n\t\t\t'tex': 'latex'\n\t\t};\n\n\t\tif(Array.prototype.forEach) { // Check to prevent error in IE8\n\t\t\tArray.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {\n\t\t\t\tvar src = pre.getAttribute('data-src');\n\n\t\t\t\tvar language, parent = pre;\n\t\t\t\tvar lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\t\t\t\twhile (parent && !lang.test(parent.className)) {\n\t\t\t\t\tparent = parent.parentNode;\n\t\t\t\t}\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tlanguage = (pre.className.match(lang) || [, ''])[1];\n\t\t\t\t}\n\n\t\t\t\tif (!language) {\n\t\t\t\t\tvar extension = (src.match(/\\.(\\w+)$/) || [, ''])[1];\n\t\t\t\t\tlanguage = Extensions[extension] || extension;\n\t\t\t\t}\n\n\t\t\t\tvar code = document.createElement('code');\n\t\t\t\tcode.className = 'language-' + language;\n\n\t\t\t\tpre.textContent = '';\n\n\t\t\t\tcode.textContent = 'Loading';\n\n\t\t\t\tpre.appendChild(code);\n\n\t\t\t\tvar xhr = new XMLHttpRequest();\n\n\t\t\t\txhr.open('GET', src, true);\n\n\t\t\t\txhr.onreadystatechange = function () {\n\t\t\t\t\tif (xhr.readyState == 4) {\n\n\t\t\t\t\t\tif (xhr.status < 400 && xhr.responseText) {\n\t\t\t\t\t\t\tcode.textContent = xhr.responseText;\n\n\t\t\t\t\t\t\tPrism.highlightElement(code);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (xhr.status >= 400) {\n\t\t\t\t\t\t\tcode.textContent = ' Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcode.textContent = ' Error: File does not exist or is empty';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\txhr.send(null);\n\t\t\t});\n\t\t}\n\n\t};\n\n\tdocument.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);\n\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prismjs/prism.js\n// module id = 76\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 108\n// module chunks = 0","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 109\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n    ];\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/ExtensionAPI.js\n// module id = 112\n// module chunks = 0","\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](payload.name);\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name) || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/action/createDataSelectAction.js\n// module id = 113\n// module chunks = 0","\n\n    module.exports = require('./BaseBarSeries').extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        brushSelector: 'rect'\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarSeries.js\n// module id = 114\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var helper = require('./helper');\n\n    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\n    // FIXME\n    // Just for compatible with ec2.\n    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n\n    var BarView = require('../../echarts').extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n            var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(dataIndex);\n                    var layout = getRectItemLayout(data, dataIndex, itemModel);\n                    var el = createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel);\n                    data.setItemGraphicEl(dataIndex, el);\n                    group.add(el);\n\n                    updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal);\n                })\n                .update(function (newIndex, oldIndex) {\n                    var el = oldData.getItemGraphicEl(oldIndex);\n\n                    if (!data.hasValue(newIndex)) {\n                        group.remove(el);\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(newIndex);\n                    var layout = getRectItemLayout(data, newIndex, itemModel);\n\n                    if (el) {\n                        graphic.updateProps(el, {shape: layout}, animationModel, newIndex);\n                    }\n                    else {\n                        el = createRect(data, newIndex, itemModel, layout, isHorizontal, animationModel, true);\n                    }\n\n                    data.setItemGraphicEl(newIndex, el);\n                    // Add back\n                    group.add(el);\n\n                    updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontal);\n                })\n                .remove(function (dataIndex) {\n                    var el = oldData.getItemGraphicEl(dataIndex);\n                    el && removeRect(dataIndex, animationModel, el);\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            var data = this._data;\n            if (ecModel.get('animation')) {\n                if (data) {\n                    data.eachItemGraphicEl(function (el) {\n                        removeRect(el.dataIndex, ecModel, el);\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n    function createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n        var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});\n\n        // Animation\n        if (animationModel) {\n            var rectShape = rect.shape;\n            var animateProperty = isHorizontal ? 'height' : 'width';\n            var animateTarget = {};\n            rectShape[animateProperty] = 0;\n            animateTarget[animateProperty] = layout[animateProperty];\n            graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n                shape: animateTarget\n            }, animationModel, dataIndex);\n        }\n\n        return rect;\n    }\n\n    function removeRect(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                width: 0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    function getRectItemLayout(data, dataIndex, itemModel) {\n        var layout = data.getItemLayout(dataIndex);\n        var fixedLineWidth = getLineWidth(itemModel, layout);\n\n        // fix layout with lineWidth\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        return {\n            x: layout.x + signX * fixedLineWidth / 2,\n            y: layout.y + signY * fixedLineWidth / 2,\n            width: layout.width - signX * fixedLineWidth,\n            height: layout.height - signY * fixedLineWidth\n        };\n    }\n\n    function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal) {\n        var color = data.getItemVisual(dataIndex, 'color');\n        var opacity = data.getItemVisual(dataIndex, 'opacity');\n        var itemStyleModel = itemModel.getModel('itemStyle.normal');\n        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n        el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\n        el.useStyle(zrUtil.defaults(\n            {\n                fill: color,\n                opacity: opacity\n            },\n            itemStyleModel.getBarItemStyle()\n        ));\n\n        var labelPositionOutside = isHorizontal\n            ? (layout.height > 0 ? 'bottom' : 'top')\n            : (layout.width > 0 ? 'left' : 'right');\n\n        helper.setLabel(\n            el.style, hoverStyle, itemModel, color,\n            seriesModel, dataIndex, labelPositionOutside\n        );\n\n        graphic.setHoverStyle(el, hoverStyle);\n    }\n\n    // In case width or height are too small.\n    function getLineWidth(itemModel, rawLayout) {\n        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n        return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n    }\n\n    module.exports = BarView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarView.js\n// module id = 115\n// module chunks = 0","'use strict';\n\n\n    var SeriesModel = require('../../model/Series');\n    var createListFromArray = require('../helper/createListFromArray');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.__base_bar__',\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 0\n            barMinHeight: 0,\n\n            // barMaxWidth: null,\n            // \n            // barWidth: null,\n            // 30%\n            // barGap: '30%',\n            // 20%\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: ''\n                },\n                emphasis: {}\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BaseBarSeries.js\n// module id = 116\n// module chunks = 0","\n\n\n    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/barItemStyle.js\n// module id = 117\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n\n    var helper = {};\n\n    helper.setLabel = function (\n        normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n    ) {\n        var labelModel = itemModel.getModel('label.normal');\n        var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n        if (labelModel.get('show')) {\n            setLabel(\n                normalStyle, labelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            normalStyle.text = '';\n        }\n\n        if (hoverLabelModel.get('show')) {\n            setLabel(\n                hoverStyle, hoverLabelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'emphasis'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            hoverStyle.text = '';\n        }\n    };\n\n    function setLabel(style, model, color, labelText, labelPositionOutside) {\n        graphic.setText(style, model, color);\n        style.text = labelText;\n        if (style.textPosition === 'outside') {\n            style.textPosition = labelPositionOutside;\n        }\n    }\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/helper.js\n// module id = 118\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./funnel/FunnelSeries');\n    require('./funnel/FunnelView');\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'funnel'));\n    echarts.registerLayout(require('./funnel/funnelLayout'));\n\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'funnel'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/funnel.js\n// module id = 119\n// module chunks = 0","'use strict';\n\n\n    var List = require('../../data/List');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n\n    var FunnelSeries = require('../../echarts').extendSeriesModel({\n\n        type: 'series.funnel',\n\n        init: function (option) {\n            FunnelSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n            // Extend labelLine emphasis\n            this._defaultLabelLine(option);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            legendHoverLink: true,\n            left: 80,\n            top: 60,\n            right: 80,\n            bottom: 60,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n\n            // \n            // min: 0,\n            // max: 100,\n            minSize: '0%',\n            maxSize: '100%',\n            sort: 'descending', // 'ascending', 'descending'\n            gap: 0,\n            funnelAlign: 'center',\n            label: {\n                normal: {\n                    show: true,\n                    position: 'outer'\n                    // formatter: Tooltip.formatter\n                    // textStyle: null      // TEXTSTYLE\n                },\n                emphasis: {\n                    show: true\n                }\n            },\n            labelLine: {\n                normal: {\n                    show: true,\n                    length: 20,\n                    lineStyle: {\n                        // color: ,\n                        width: 1,\n                        type: 'solid'\n                    }\n                },\n                emphasis: {}\n            },\n            itemStyle: {\n                normal: {\n                    // color: ,\n                    borderColor: '#fff',\n                    borderWidth: 1\n                },\n                emphasis: {\n                    // color: ,\n                }\n            }\n        }\n    });\n\n    module.exports = FunnelSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/funnel/FunnelSeries.js\n// module id = 120\n// module chunks = 0","\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function FunnelPiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var polygon = new graphic.Polygon();\n        var labelLine = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(polygon);\n        this.add(labelLine);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            labelLine.ignore = labelLine.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            labelLine.ignore = labelLine.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var funnelPieceProto = FunnelPiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var position = labelModel.get('position');\n        var isLabelInside = position === 'inside' || position === 'inner' || position === 'center';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state),\n                data.getName(idx)\n            )\n        };\n    }\n\n    var opacityAccessPath = ['itemStyle', 'normal', 'opacity'];\n    funnelPieceProto.updateData = function (data, idx, firstCreate) {\n\n        var polygon = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var opacity = data.getItemModel(idx).get(opacityAccessPath);\n        opacity = opacity == null ? 1 : opacity;\n\n        // Reset style\n        polygon.useStyle({});\n\n        if (firstCreate) {\n            polygon.setShape({\n                points: layout.points\n            });\n            polygon.setStyle({ opacity : 0 });\n            graphic.initProps(polygon, {\n                style: {\n                    opacity: opacity\n                }\n            }, seriesModel, idx);\n        }\n        else {\n            graphic.updateProps(polygon, {\n                style: {\n                    opacity: opacity\n                },\n                shape: {\n                    points: layout.points\n                }\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        polygon.setStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'round',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle(['opacity'])\n            )\n        );\n        polygon.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    funnelPieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || labelLayout.linePoints\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textAlign: labelLayout.textAlign,\n                textVerticalAlign: labelLayout.verticalAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n    };\n\n    zrUtil.inherits(FunnelPiece, graphic.Group);\n\n\n    var Funnel = require('../../view/Chart').extend({\n\n        type: 'funnel',\n\n        render: function (seriesModel, ecModel, api) {\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var group = this.group;\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var funnelPiece = new FunnelPiece(data, idx);\n\n                    data.setItemGraphicEl(idx, funnelPiece);\n\n                    group.add(funnelPiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function () {\n            this.group.removeAll();\n            this._data = null;\n        },\n\n        dispose: function () {}\n    });\n\n    module.exports = Funnel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/funnel/FunnelView.js\n// module id = 121\n// module chunks = 0","\n\n    var layout = require('../../util/layout');\n    var number = require('../../util/number');\n\n    var parsePercent = number.parsePercent;\n\n    function getViewRect(seriesModel, api) {\n        return layout.getLayoutRect(\n            seriesModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }\n        );\n    }\n\n    function getSortedIndices(data, sort) {\n        var valueArr = data.mapArray('value', function (val) {\n            return val;\n        });\n        var indices = [];\n        var isAscending = sort === 'ascending';\n        for (var i = 0, len = data.count(); i < len; i++) {\n            indices[i] = i;\n        }\n        indices.sort(function (a, b) {\n            return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];\n        });\n        return indices;\n    }\n\n    function labelLayout (data) {\n        data.each(function (idx) {\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            var labelPosition = labelModel.get('position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n\n            var layout = data.getItemLayout(idx);\n            var points = layout.points;\n\n            var isLabelInside = labelPosition === 'inner'\n                || labelPosition === 'inside' || labelPosition === 'center';\n\n            var textAlign;\n            var textX;\n            var textY;\n            var linePoints;\n\n            if (isLabelInside) {\n                textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;\n                textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;\n                textAlign = 'center';\n                linePoints = [\n                    [textX, textY], [textX, textY]\n                ];\n            }\n            else {\n                var x1;\n                var y1;\n                var x2;\n                var labelLineLen = labelLineModel.get('length');\n                if (labelPosition === 'left') {\n                    // Left side\n                    x1 = (points[3][0] + points[0][0]) / 2;\n                    y1 = (points[3][1] + points[0][1]) / 2;\n                    x2 = x1 - labelLineLen;\n                    textX = x2 - 5;\n                    textAlign = 'right';\n                }\n                else {\n                    // Right side\n                    x1 = (points[1][0] + points[2][0]) / 2;\n                    y1 = (points[1][1] + points[2][1]) / 2;\n                    x2 = x1 + labelLineLen;\n                    textX = x2 + 5;\n                    textAlign = 'left';\n                }\n                var y2 = y1;\n\n                linePoints = [[x1, y1], [x2, y2]];\n                textY = y2;\n            }\n\n            layout.label = {\n                linePoints: linePoints,\n                x: textX,\n                y: textY,\n                verticalAlign: 'middle',\n                textAlign: textAlign,\n                inside: isLabelInside\n            };\n        });\n    }\n\n    module.exports = function (ecModel, api, payload) {\n        ecModel.eachSeriesByType('funnel', function (seriesModel) {\n            var data = seriesModel.getData();\n            var sort = seriesModel.get('sort');\n            var viewRect = getViewRect(seriesModel, api);\n            var indices = getSortedIndices(data, sort);\n\n            var sizeExtent = [\n                parsePercent(seriesModel.get('minSize'), viewRect.width),\n                parsePercent(seriesModel.get('maxSize'), viewRect.width)\n            ];\n            var dataExtent = data.getDataExtent('value');\n            var min = seriesModel.get('min');\n            var max = seriesModel.get('max');\n            if (min == null) {\n                min = Math.min(dataExtent[0], 0);\n            }\n            if (max == null) {\n                max = dataExtent[1];\n            }\n\n            var funnelAlign = seriesModel.get('funnelAlign');\n            var gap = seriesModel.get('gap');\n            var itemHeight = (viewRect.height - gap * (data.count() - 1)) / data.count();\n\n            var y = viewRect.y;\n\n            var getLinePoints = function (idx, offY) {\n                // End point index is data.count() and we assign it 0\n                var val = data.get('value', idx) || 0;\n                var itemWidth = number.linearMap(val, [min, max], sizeExtent, true);\n                var x0;\n                switch (funnelAlign) {\n                    case 'left':\n                        x0 = viewRect.x;\n                        break;\n                    case 'center':\n                        x0 = viewRect.x + (viewRect.width - itemWidth) / 2;\n                        break;\n                    case 'right':\n                        x0 = viewRect.x + viewRect.width - itemWidth;\n                        break;\n                }\n                return [\n                    [x0, offY],\n                    [x0 + itemWidth, offY]\n                ];\n            };\n\n            if (sort === 'ascending') {\n                // From bottom to top\n                itemHeight = -itemHeight;\n                gap = -gap;\n                y += viewRect.height;\n                indices = indices.reverse();\n            }\n\n            for (var i = 0; i < indices.length; i++) {\n                var idx = indices[i];\n                var nextIdx = indices[i + 1];\n                var start = getLinePoints(idx, y);\n                var end = getLinePoints(nextIdx, y + itemHeight);\n\n                y += itemHeight + gap;\n\n                data.setItemLayout(idx, {\n                    points: start.concat(end.slice().reverse())\n                });\n            }\n\n            labelLayout(data);\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/funnel/funnelLayout.js\n// module id = 122\n// module chunks = 0","// TODO Batch by color\n\n\n\n    var graphic = require('../../util/graphic');\n    var symbolUtil = require('../../util/symbol');\n\n    var LargeSymbolPath = graphic.extendShape({\n\n        shape: {\n            points: null,\n            sizes: null\n        },\n\n        symbolProxy: null,\n\n        buildPath: function (path, shape) {\n            var points = shape.points;\n            var sizes = shape.sizes;\n\n            var symbolProxy = this.symbolProxy;\n            var symbolProxyShape = symbolProxy.shape;\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                var size = sizes[i];\n                if (size[0] < 4) {\n                    // Optimize for small symbol\n                    path.rect(\n                        pt[0] - size[0] / 2, pt[1] - size[1] / 2,\n                        size[0], size[1]\n                    );\n                }\n                else {\n                    symbolProxyShape.x = pt[0] - size[0] / 2;\n                    symbolProxyShape.y = pt[1] - size[1] / 2;\n                    symbolProxyShape.width = size[0];\n                    symbolProxyShape.height = size[1];\n\n                    symbolProxy.buildPath(path, symbolProxyShape, true);\n                }\n            }\n        },\n\n        findDataIndex: function (x, y) {\n            var shape = this.shape;\n            var points = shape.points;\n            var sizes = shape.sizes;\n\n            // Not consider transform\n            // Treat each element as a rect\n            // top down traverse\n            for (var i = points.length - 1; i >= 0; i--) {\n                var pt = points[i];\n                var size = sizes[i];\n                var x0 = pt[0] - size[0] / 2;\n                var y0 = pt[1] - size[1] / 2;\n                if (x >= x0 && y >= y0 && x <= x0 + size[0] && y <= y0 + size[1]) {\n                    // i is dataIndex\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n    });\n\n    function LargeSymbolDraw() {\n        this.group = new graphic.Group();\n\n        this._symbolEl = new LargeSymbolPath({\n            // rectHover: true,\n            // cursor: 'default'\n        });\n    }\n\n    var largeSymbolProto = LargeSymbolDraw.prototype;\n\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     */\n    largeSymbolProto.updateData = function (data) {\n        this.group.removeAll();\n\n        var symbolEl = this._symbolEl;\n\n        var seriesModel = data.hostModel;\n\n        symbolEl.setShape({\n            points: data.mapArray(data.getItemLayout),\n            sizes: data.mapArray(\n                function (idx) {\n                    var size = data.getItemVisual(idx, 'symbolSize');\n                    if (!(size instanceof Array)) {\n                        size = [size, size];\n                    }\n                    return size;\n                }\n            )\n        });\n\n        // Create symbolProxy to build path for each data\n        symbolEl.symbolProxy = symbolUtil.createSymbol(\n            data.getVisual('symbol'), 0, 0, 0, 0\n        );\n        // Use symbolProxy setColor method\n        symbolEl.setColor = symbolEl.symbolProxy.setColor;\n\n        symbolEl.useStyle(\n            seriesModel.getModel('itemStyle.normal').getItemStyle(['color'])\n        );\n\n        var visualColor = data.getVisual('color');\n        if (visualColor) {\n            symbolEl.setColor(visualColor);\n        }\n\n        // Enable tooltip\n        // PENDING May have performance issue when path is extremely large\n        symbolEl.seriesIndex = seriesModel.seriesIndex;\n        symbolEl.on('mousemove', function (e) {\n            symbolEl.dataIndex = null;\n            var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n            if (dataIndex > 0) {\n                // Provide dataIndex for tooltip\n                symbolEl.dataIndex = dataIndex;\n            }\n        });\n\n        // Add back\n        this.group.add(symbolEl);\n    };\n\n    largeSymbolProto.updateLayout = function (seriesModel) {\n        var data = seriesModel.getData();\n        this._symbolEl.setShape({\n            points: data.mapArray(data.getItemLayout)\n        });\n    };\n\n    largeSymbolProto.remove = function () {\n        this.group.removeAll();\n    };\n\n    module.exports = LargeSymbolDraw;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/LargeSymbolDraw.js\n// module id = 123\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n    var PRIORITY = echarts.PRIORITY;\n\n    require('./line/LineSeries');\n    require('./line/LineView');\n\n    echarts.registerVisual(zrUtil.curry(\n        require('../visual/symbol'), 'line', 'circle', 'line'\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        require('../layout/points'), 'line'\n    ));\n\n    // Down sample after filter\n    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n        require('../processor/dataSample'), 'line'\n    ));\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/line.js\n// module id = 124\n// module chunks = 0","'use strict';\n\n\n    var createListFromArray = require('../helper/createListFromArray');\n    var SeriesModel = require('../../model/Series');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.line',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // stack: null\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // polarIndex: 0,\n\n            // If clip the overflow value\n            clipOverflow: true,\n\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // itemStyle: {\n            //     normal: {},\n            //     emphasis: {}\n            // },\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // areaStyle: {},\n            // false, 'start', 'end', 'middle'\n            step: false,\n\n            // Disabled if step is true\n            smooth: false,\n            smoothMonotone: null,\n            // \n            symbol: 'emptyCircle',\n            // \n            symbolSize: 4,\n            // \n            symbolRotate: null,\n\n            //  symbol,  tooltip hover \n            showSymbol: true,\n            // \n            showAllSymbol: false,\n\n            // \n            connectNulls: false,\n\n            // 'average', 'max', 'min', 'sum'\n            sampling: 'none',\n\n            animationEasing: 'linear',\n\n            // Disable progressive\n            progressive: 0,\n            hoverLayerThreshold: Infinity\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/line/LineSeries.js\n// module id = 125\n// module chunks = 0","'use strict';\n// FIXME step not support polar\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var SymbolDraw = require('../helper/SymbolDraw');\n    var Symbol = require('../helper/Symbol');\n    var lineAnimationDiff = require('./lineAnimationDiff');\n    var graphic = require('../../util/graphic');\n    var modelUtil = require('../../util/model');\n    var polyHelper = require('./poly');\n    var ChartView = require('../../view/Chart');\n\n    function isPointsSame(points1, points2) {\n        if (points1.length !== points2.length) {\n            return;\n        }\n        for (var i = 0; i < points1.length; i++) {\n            var p1 = points1[i];\n            var p2 = points2[i];\n            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n                return;\n            }\n        }\n        return true;\n    }\n\n    function getSmooth(smooth) {\n        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n    }\n\n    function getAxisExtentWithGap(axis) {\n        var extent = axis.getGlobalExtent();\n        if (axis.onBand) {\n            // Remove extra 1px to avoid line miter in clipped edge\n            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n            var dir = extent[1] > extent[0] ? 1 : -1;\n            extent[0] += dir * halfBandWidth;\n            extent[1] -= dir * halfBandWidth;\n        }\n        return extent;\n    }\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n    /**\n     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n     * @param {module:echarts/data/List} data\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    function getStackedOnPoints(coordSys, data) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        return data.mapArray([valueDim], function (val, idx) {\n            var stackedOnSameSign;\n            var stackedOn = data.stackedOn;\n            // Find first stacked value with same sign\n            while (stackedOn &&\n                sign(stackedOn.get(valueDim, idx)) === sign(val)\n            ) {\n                stackedOnSameSign = stackedOn;\n                break;\n            }\n            var stackedData = [];\n            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n            stackedData[1 - baseDataOffset] = stackedOnSameSign\n                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n            return coordSys.dataToPoint(stackedData);\n        }, true);\n    }\n\n    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\n        var x = Math.min(xExtent[0], xExtent[1]);\n        var y = Math.min(yExtent[0], yExtent[1]);\n        var width = Math.max(xExtent[0], xExtent[1]) - x;\n        var height = Math.max(yExtent[0], yExtent[1]) - y;\n        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n        // Expand clip shape to avoid clipping when line value exceeds axis\n        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n        if (isHorizontal) {\n            y -= expandSize;\n            height += expandSize * 2;\n        }\n        else {\n            x -= expandSize;\n            width += expandSize * 2;\n        }\n\n        var clipPath = new graphic.Rect({\n            shape: {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n            graphic.initProps(clipPath, {\n                shape: {\n                    width: width,\n                    height: height\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n        var angleAxis = polar.getAngleAxis();\n        var radiusAxis = polar.getRadiusAxis();\n\n        var radiusExtent = radiusAxis.getExtent();\n        var angleExtent = angleAxis.getExtent();\n\n        var RADIAN = Math.PI / 180;\n\n        var clipPath = new graphic.Sector({\n            shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r0: radiusExtent[0],\n                r: radiusExtent[1],\n                startAngle: -angleExtent[0] * RADIAN,\n                endAngle: -angleExtent[1] * RADIAN,\n                clockwise: angleAxis.inverse\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: -angleExtent[1] * RADIAN\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createClipShape(coordSys, hasAnimation, seriesModel) {\n        return coordSys.type === 'polar'\n            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n    }\n\n    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n        var baseAxis = coordSys.getBaseAxis();\n        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n        var stepPoints = [];\n        for (var i = 0; i < points.length - 1; i++) {\n            var nextPt = points[i + 1];\n            var pt = points[i];\n            stepPoints.push(pt);\n\n            var stepPt = [];\n            switch (stepTurnAt) {\n                case 'end':\n                    stepPt[baseIndex] = nextPt[baseIndex];\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n                    break;\n                case 'middle':\n                    // default is start\n                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n                    var stepPt2 = [];\n                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n                    stepPoints.push(stepPt);\n                    stepPoints.push(stepPt2);\n                    break;\n                default:\n                    stepPt[baseIndex] = pt[baseIndex];\n                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n            }\n        }\n        // Last points\n        points[i] && stepPoints.push(points[i]);\n        return stepPoints;\n    }\n\n    function getVisualGradient(data, coordSys) {\n        var visualMetaList = data.getVisual('visualMeta');\n        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n            // When data.count() is 0, gradient range can not be calculated.\n            return;\n        }\n\n        var visualMeta;\n        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n            // Can only be x or y\n            if (visualMetaList[i].dimension < 2) {\n                visualMeta = visualMetaList[i];\n                break;\n            }\n        }\n        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n            if (__DEV__) {\n                console.warn('Visual map on line style only support x or y dimension.');\n            }\n            return;\n        }\n\n        // If the area to be rendered is bigger than area defined by LinearGradient,\n        // the canvas spec prescribes that the color of the first stop and the last\n        // stop should be used. But if two stops are added at offset 0, in effect\n        // browsers use the color of the second stop to render area outside\n        // LinearGradient. So we can only infinitesimally extend area defined in\n        // LinearGradient to render `outerColors`.\n\n        var dimension = visualMeta.dimension;\n        var dimName = data.dimensions[dimension];\n        var axis = coordSys.getAxis(dimName);\n\n        // dataToCoor mapping may not be linear, but must be monotonic.\n        var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n            return {\n                coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n                color: stop.color\n            };\n        });\n        var stopLen = colorStops.length;\n        var outerColors = visualMeta.outerColors.slice();\n\n        if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n            colorStops.reverse();\n            outerColors.reverse();\n        }\n\n        var tinyExtent = 10; // Arbitrary value: 10px\n        var minCoord = colorStops[0].coord - tinyExtent;\n        var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n        var coordSpan = maxCoord - minCoord;\n\n        if (coordSpan < 1e-3) {\n            return 'transparent';\n        }\n\n        zrUtil.each(colorStops, function (stop) {\n            stop.offset = (stop.coord - minCoord) / coordSpan;\n        });\n        colorStops.push({\n            offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n            color: outerColors[1] || 'transparent'\n        });\n        colorStops.unshift({ // notice colorStops.length have been changed.\n            offset: stopLen ? colorStops[0].offset : 0.5,\n            color: outerColors[0] || 'transparent'\n        });\n\n        // zrUtil.each(colorStops, function (colorStop) {\n        //     // Make sure each offset has rounded px to avoid not sharp edge\n        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n        // });\n\n        var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n        gradient[dimName] = minCoord;\n        gradient[dimName + '2'] = maxCoord;\n\n        return gradient;\n    }\n\n    module.exports = ChartView.extend({\n\n        type: 'line',\n\n        init: function () {\n            var lineGroup = new graphic.Group();\n\n            var symbolDraw = new SymbolDraw();\n            this.group.add(symbolDraw.group);\n\n            this._symbolDraw = symbolDraw;\n            this._lineGroup = lineGroup;\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var group = this.group;\n            var data = seriesModel.getData();\n            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\n            var points = data.mapArray(data.getItemLayout, true);\n\n            var isCoordSysPolar = coordSys.type === 'polar';\n            var prevCoordSys = this._coordSys;\n\n            var symbolDraw = this._symbolDraw;\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n\n            var lineGroup = this._lineGroup;\n\n            var hasAnimation = seriesModel.get('animation');\n\n            var isAreaChart = !areaStyleModel.isEmpty();\n            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\n            var showSymbol = seriesModel.get('showSymbol');\n\n            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n                && this._getSymbolIgnoreFunc(data, coordSys);\n\n            // Remove temporary symbols\n            var oldData = this._data;\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            // Remove previous created symbols if showSymbol changed to false\n            if (!showSymbol) {\n                symbolDraw.remove();\n            }\n\n            group.add(lineGroup);\n\n            // FIXME step not support polar\n            var step = !isCoordSysPolar && seriesModel.get('step');\n            // Initialization animation or coordinate system changed\n            if (\n                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n            ) {\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                if (step) {\n                    // TODO If stacked series is not step\n                    points = turnPointsIntoStep(points, coordSys, step);\n                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                }\n\n                polyline = this._newPolyline(points, coordSys, hasAnimation);\n                if (isAreaChart) {\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n            }\n            else {\n                if (isAreaChart && !polygon) {\n                    // If areaStyle is added\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                else if (polygon && !isAreaChart) {\n                    // If areaStyle is removed\n                    lineGroup.remove(polygon);\n                    polygon = this._polygon = null;\n                }\n\n                // Update clipPath\n                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\n                // Always update, or it is wrong in the case turning on legend\n                // because points are not changed\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                // Stop symbol animation and sync with line points\n                // FIXME performance?\n                data.eachItemGraphicEl(function (el) {\n                    el.stopAnimation(true);\n                });\n\n                // In the case data zoom triggerred refreshing frequently\n                // Data may not change if line has a category axis. So it should animate nothing\n                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n                    || !isPointsSame(this._points, points)\n                ) {\n                    if (hasAnimation) {\n                        this._updateAnimation(\n                            data, stackedOnPoints, coordSys, api, step\n                        );\n                    }\n                    else {\n                        // Not do it in update with animation\n                        if (step) {\n                            // TODO If stacked series is not step\n                            points = turnPointsIntoStep(points, coordSys, step);\n                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                        }\n\n                        polyline.setShape({\n                            points: points\n                        });\n                        polygon && polygon.setShape({\n                            points: points,\n                            stackedOnPoints: stackedOnPoints\n                        });\n                    }\n                }\n            }\n\n            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\n            polyline.useStyle(zrUtil.defaults(\n                // Use color in lineStyle first\n                lineStyleModel.getLineStyle(),\n                {\n                    fill: 'none',\n                    stroke: visualColor,\n                    lineJoin: 'bevel'\n                }\n            ));\n\n            var smooth = seriesModel.get('smooth');\n            smooth = getSmooth(seriesModel.get('smooth'));\n            polyline.setShape({\n                smooth: smooth,\n                smoothMonotone: seriesModel.get('smoothMonotone'),\n                connectNulls: seriesModel.get('connectNulls')\n            });\n\n            if (polygon) {\n                var stackedOn = data.stackedOn;\n                var stackedOnSmooth = 0;\n\n                polygon.useStyle(zrUtil.defaults(\n                    areaStyleModel.getAreaStyle(),\n                    {\n                        fill: visualColor,\n                        opacity: 0.7,\n                        lineJoin: 'bevel'\n                    }\n                ));\n\n                if (stackedOn) {\n                    var stackedOnSeries = stackedOn.hostModel;\n                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n                }\n\n                polygon.setShape({\n                    smooth: smooth,\n                    stackedOnSmooth: stackedOnSmooth,\n                    smoothMonotone: seriesModel.get('smoothMonotone'),\n                    connectNulls: seriesModel.get('connectNulls')\n                });\n            }\n\n            this._data = data;\n            // Save the coordinate system for transition animation when data changed\n            this._coordSys = coordSys;\n            this._stackedOnPoints = stackedOnPoints;\n            this._points = points;\n            this._step = step;\n        },\n\n        dispose: function () {},\n\n        highlight: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (!symbol) {\n                    // Create a temporary symbol if it is not exists\n                    var pt = data.getItemLayout(dataIndex);\n                    if (!pt) {\n                        // Null data\n                        return;\n                    }\n                    symbol = new Symbol(data, dataIndex);\n                    symbol.position = pt;\n                    symbol.setZ(\n                        seriesModel.get('zlevel'),\n                        seriesModel.get('z')\n                    );\n                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n                    symbol.__temp = true;\n                    data.setItemGraphicEl(dataIndex, symbol);\n\n                    // Stop scale animation\n                    symbol.stopSymbolAnimation(true);\n\n                    this.group.add(symbol);\n                }\n                symbol.highlight();\n            }\n            else {\n                // Highlight whole series\n                ChartView.prototype.highlight.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        downplay: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n            if (dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (symbol) {\n                    if (symbol.__temp) {\n                        data.setItemGraphicEl(dataIndex, null);\n                        this.group.remove(symbol);\n                    }\n                    else {\n                        symbol.downplay();\n                    }\n                }\n            }\n            else {\n                // Downplay whole series\n                ChartView.prototype.downplay.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolyline: function (points) {\n            var polyline = this._polyline;\n            // Remove previous created polyline\n            if (polyline) {\n                this._lineGroup.remove(polyline);\n            }\n\n            polyline = new polyHelper.Polyline({\n                shape: {\n                    points: points\n                },\n                silent: true,\n                z2: 10\n            });\n\n            this._lineGroup.add(polyline);\n\n            this._polyline = polyline;\n\n            return polyline;\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} stackedOnPoints\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolygon: function (points, stackedOnPoints) {\n            var polygon = this._polygon;\n            // Remove previous created polygon\n            if (polygon) {\n                this._lineGroup.remove(polygon);\n            }\n\n            polygon = new polyHelper.Polygon({\n                shape: {\n                    points: points,\n                    stackedOnPoints: stackedOnPoints\n                },\n                silent: true\n            });\n\n            this._lineGroup.add(polygon);\n\n            this._polygon = polygon;\n            return polygon;\n        },\n        /**\n         * @private\n         */\n        _getSymbolIgnoreFunc: function (data, coordSys) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n            // `getLabelInterval` is provided by echarts/component/axis\n            if (categoryAxis && categoryAxis.isLabelIgnored) {\n                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n            }\n        },\n\n        /**\n         * @private\n         */\n        // FIXME Two value axis\n        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n            var seriesModel = data.hostModel;\n\n            var diff = lineAnimationDiff(\n                this._data, data,\n                this._stackedOnPoints, stackedOnPoints,\n                this._coordSys, coordSys\n            );\n\n            var current = diff.current;\n            var stackedOnCurrent = diff.stackedOnCurrent;\n            var next = diff.next;\n            var stackedOnNext = diff.stackedOnNext;\n            if (step) {\n                // TODO If stacked series is not step\n                current = turnPointsIntoStep(diff.current, coordSys, step);\n                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n                next = turnPointsIntoStep(diff.next, coordSys, step);\n                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n            }\n            // `diff.current` is subset of `current` (which should be ensured by\n            // turnPointsIntoStep), so points in `__points` can be updated when\n            // points in `current` are update during animation.\n            polyline.shape.__points = diff.current;\n            polyline.shape.points = current;\n\n            graphic.updateProps(polyline, {\n                shape: {\n                    points: next\n                }\n            }, seriesModel);\n\n            if (polygon) {\n                polygon.setShape({\n                    points: current,\n                    stackedOnPoints: stackedOnCurrent\n                });\n                graphic.updateProps(polygon, {\n                    shape: {\n                        points: next,\n                        stackedOnPoints: stackedOnNext\n                    }\n                }, seriesModel);\n            }\n\n            var updatedDataInfo = [];\n            var diffStatus = diff.status;\n\n            for (var i = 0; i < diffStatus.length; i++) {\n                var cmd = diffStatus[i].cmd;\n                if (cmd === '=') {\n                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n                    if (el) {\n                        updatedDataInfo.push({\n                            el: el,\n                            ptIdx: i    // Index of points\n                        });\n                    }\n                }\n            }\n\n            if (polyline.animators && polyline.animators.length) {\n                polyline.animators[0].during(function () {\n                    for (var i = 0; i < updatedDataInfo.length; i++) {\n                        var el = updatedDataInfo[i].el;\n                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n                    }\n                });\n            }\n        },\n\n        remove: function (ecModel) {\n            var group = this.group;\n            var oldData = this._data;\n            this._lineGroup.removeAll();\n            this._symbolDraw.remove(true);\n            // Remove temporary created elements when highlighting\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            this._polyline =\n            this._polygon =\n            this._coordSys =\n            this._points =\n            this._stackedOnPoints =\n            this._data = null;\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/line/LineView.js\n// module id = 126\n// module chunks = 0","\n\n    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n    // 'zrender/core/arrayDiff' has been used before, but it did\n    // not do well in performance when roam with fixed dataZoom window.\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n\n    function getStackedOnPoint(coordSys, data, idx) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        var stackedOnSameSign;\n        var stackedOn = data.stackedOn;\n        var val = data.get(valueDim, idx);\n        // Find first stacked value with same sign\n        while (stackedOn &&\n            sign(stackedOn.get(valueDim, idx)) === sign(val)\n        ) {\n            stackedOnSameSign = stackedOn;\n            break;\n        }\n        var stackedData = [];\n        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n        stackedData[1 - baseDataOffset] = stackedOnSameSign\n            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n        return coordSys.dataToPoint(stackedData);\n    }\n\n    // function convertToIntId(newIdList, oldIdList) {\n    //     // Generate int id instead of string id.\n    //     // Compare string maybe slow in score function of arrDiff\n\n    //     // Assume id in idList are all unique\n    //     var idIndicesMap = {};\n    //     var idx = 0;\n    //     for (var i = 0; i < newIdList.length; i++) {\n    //         idIndicesMap[newIdList[i]] = idx;\n    //         newIdList[i] = idx++;\n    //     }\n    //     for (var i = 0; i < oldIdList.length; i++) {\n    //         var oldId = oldIdList[i];\n    //         // Same with newIdList\n    //         if (idIndicesMap[oldId]) {\n    //             oldIdList[i] = idIndicesMap[oldId];\n    //         }\n    //         else {\n    //             oldIdList[i] = idx++;\n    //         }\n    //     }\n    // }\n\n    function diffData(oldData, newData) {\n        var diffResult = [];\n\n        newData.diff(oldData)\n            .add(function (idx) {\n                diffResult.push({cmd: '+', idx: idx});\n            })\n            .update(function (newIdx, oldIdx) {\n                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n            })\n            .remove(function (idx) {\n                diffResult.push({cmd: '-', idx: idx});\n            })\n            .execute();\n\n        return diffResult;\n    }\n\n    module.exports = function (\n        oldData, newData,\n        oldStackedOnPoints, newStackedOnPoints,\n        oldCoordSys, newCoordSys\n    ) {\n        var diff = diffData(oldData, newData);\n\n        // var newIdList = newData.mapArray(newData.getId);\n        // var oldIdList = oldData.mapArray(oldData.getId);\n\n        // convertToIntId(newIdList, oldIdList);\n\n        // // FIXME One data ?\n        // diff = arrayDiff(oldIdList, newIdList);\n\n        var currPoints = [];\n        var nextPoints = [];\n        // Points for stacking base line\n        var currStackedPoints = [];\n        var nextStackedPoints = [];\n\n        var status = [];\n        var sortedIndices = [];\n        var rawIndices = [];\n        var dims = newCoordSys.dimensions;\n        for (var i = 0; i < diff.length; i++) {\n            var diffItem = diff[i];\n            var pointAdded = true;\n\n            // FIXME, animation is not so perfect when dataZoom window moves fast\n            // Which is in case remvoing or add more than one data in the tail or head\n            switch (diffItem.cmd) {\n                case '=':\n                    var currentPt = oldData.getItemLayout(diffItem.idx);\n                    var nextPt = newData.getItemLayout(diffItem.idx1);\n                    // If previous data is NaN, use next point directly\n                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n                        currentPt = nextPt.slice();\n                    }\n                    currPoints.push(currentPt);\n                    nextPoints.push(nextPt);\n\n                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\n                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n                    break;\n                case '+':\n                    var idx = diffItem.idx;\n                    currPoints.push(\n                        oldCoordSys.dataToPoint([\n                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n                        ])\n                    );\n\n                    nextPoints.push(newData.getItemLayout(idx).slice());\n\n                    currStackedPoints.push(\n                        getStackedOnPoint(oldCoordSys, newData, idx)\n                    );\n                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\n                    rawIndices.push(newData.getRawIndex(idx));\n                    break;\n                case '-':\n                    var idx = diffItem.idx;\n                    var rawIndex = oldData.getRawIndex(idx);\n                    // Data is replaced. In the case of dynamic data queue\n                    // FIXME FIXME FIXME\n                    if (rawIndex !== idx) {\n                        currPoints.push(oldData.getItemLayout(idx));\n                        nextPoints.push(newCoordSys.dataToPoint([\n                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n                        ]));\n\n                        currStackedPoints.push(oldStackedOnPoints[idx]);\n                        nextStackedPoints.push(\n                            getStackedOnPoint(\n                                newCoordSys, oldData, idx\n                            )\n                        );\n\n                        rawIndices.push(rawIndex);\n                    }\n                    else {\n                        pointAdded = false;\n                    }\n            }\n\n            // Original indices\n            if (pointAdded) {\n                status.push(diffItem);\n                sortedIndices.push(sortedIndices.length);\n            }\n        }\n\n        // Diff result may be crossed if all items are changed\n        // Sort by data index\n        sortedIndices.sort(function (a, b) {\n            return rawIndices[a] - rawIndices[b];\n        });\n\n        var sortedCurrPoints = [];\n        var sortedNextPoints = [];\n\n        var sortedCurrStackedPoints = [];\n        var sortedNextStackedPoints = [];\n\n        var sortedStatus = [];\n        for (var i = 0; i < sortedIndices.length; i++) {\n            var idx = sortedIndices[i];\n            sortedCurrPoints[i] = currPoints[idx];\n            sortedNextPoints[i] = nextPoints[idx];\n\n            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\n            sortedStatus[i] = status[idx];\n        }\n\n        return {\n            current: sortedCurrPoints,\n            next: sortedNextPoints,\n\n            stackedOnCurrent: sortedCurrStackedPoints,\n            stackedOnNext: sortedNextStackedPoints,\n\n            status: sortedStatus\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/line/lineAnimationDiff.js\n// module id = 127\n// module chunks = 0","// Poly path support NaN point\n\n\n    var Path = require('zrender/lib/graphic/Path');\n    var vec2 = require('zrender/lib/core/vector');\n\n    var vec2Min = vec2.min;\n    var vec2Max = vec2.max;\n\n    var scaleAndAdd = vec2.scaleAndAdd;\n    var v2Copy = vec2.copy;\n\n    // Temporary variable\n    var v = [];\n    var cp0 = [];\n    var cp1 = [];\n\n    function isPointNull(p) {\n        return isNaN(p[0]) || isNaN(p[1]);\n    }\n\n    function drawSegment(\n        ctx, points, start, segLen, allLen,\n        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n    ) {\n        var prevIdx = 0;\n        var idx = start;\n        for (var k = 0; k < segLen; k++) {\n            var p = points[idx];\n            if (idx >= allLen || idx < 0) {\n                break;\n            }\n            if (isPointNull(p)) {\n                if (connectNulls) {\n                    idx += dir;\n                    continue;\n                }\n                break;\n            }\n\n            if (idx === start) {\n                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n                v2Copy(cp0, p);\n            }\n            else {\n                if (smooth > 0) {\n                    var nextIdx = idx + dir;\n                    var nextP = points[nextIdx];\n                    if (connectNulls) {\n                        // Find next point not null\n                        while (nextP && isPointNull(points[nextIdx])) {\n                            nextIdx += dir;\n                            nextP = points[nextIdx];\n                        }\n                    }\n\n                    var ratioNextSeg = 0.5;\n                    var prevP = points[prevIdx];\n                    var nextP = points[nextIdx];\n                    // Last point\n                    if (!nextP || isPointNull(nextP)) {\n                        v2Copy(cp1, p);\n                    }\n                    else {\n                        // If next data is null in not connect case\n                        if (isPointNull(nextP) && !connectNulls) {\n                            nextP = p;\n                        }\n\n                        vec2.sub(v, nextP, prevP);\n\n                        var lenPrevSeg;\n                        var lenNextSeg;\n                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n                            var dim = smoothMonotone === 'x' ? 0 : 1;\n                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n                        }\n                        else {\n                            lenPrevSeg = vec2.dist(p, prevP);\n                            lenNextSeg = vec2.dist(p, nextP);\n                        }\n\n                        // Use ratio of seg length\n                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\n                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n                    }\n                    // Smooth constraint\n                    vec2Min(cp0, cp0, smoothMax);\n                    vec2Max(cp0, cp0, smoothMin);\n                    vec2Min(cp1, cp1, smoothMax);\n                    vec2Max(cp1, cp1, smoothMin);\n\n                    ctx.bezierCurveTo(\n                        cp0[0], cp0[1],\n                        cp1[0], cp1[1],\n                        p[0], p[1]\n                    );\n                    // cp0 of next segment\n                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n                }\n                else {\n                    ctx.lineTo(p[0], p[1]);\n                }\n            }\n\n            prevIdx = idx;\n            idx += dir;\n        }\n\n        return k;\n    }\n\n    function getBoundingBox(points, smoothConstraint) {\n        var ptMin = [Infinity, Infinity];\n        var ptMax = [-Infinity, -Infinity];\n        if (smoothConstraint) {\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n            }\n        }\n        return {\n            min: smoothConstraint ? ptMin : ptMax,\n            max: smoothConstraint ? ptMax : ptMin\n        };\n    }\n\n    module.exports = {\n\n        Polyline: Path.extend({\n\n            type: 'ec-polyline',\n\n            shape: {\n                points: [],\n\n                smooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            style: {\n                fill: null,\n\n                stroke: '#000'\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n\n                var i = 0;\n                var len = points.length;\n\n                var result = getBoundingBox(points, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    i += drawSegment(\n                        ctx, points, i, len, len,\n                        1, result.min, result.max, shape.smooth,\n                        shape.smoothMonotone, shape.connectNulls\n                    ) + 1;\n                }\n            }\n        }),\n\n        Polygon: Path.extend({\n\n            type: 'ec-polygon',\n\n            shape: {\n                points: [],\n\n                // Offset between stacked base points and points\n                stackedOnPoints: [],\n\n                smooth: 0,\n\n                stackedOnSmooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n                var stackedOnPoints = shape.stackedOnPoints;\n\n                var i = 0;\n                var len = points.length;\n                var smoothMonotone = shape.smoothMonotone;\n                var bbox = getBoundingBox(points, shape.smoothConstraint);\n                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    var k = drawSegment(\n                        ctx, points, i, len, len,\n                        1, bbox.min, bbox.max, shape.smooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    drawSegment(\n                        ctx, stackedOnPoints, i + k - 1, k, len,\n                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    i += k + 1;\n\n                    ctx.closePath();\n                }\n            }\n        })\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/line/poly.js\n// module id = 128\n// module chunks = 0","'use strict';\n\n\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\n    var PieSeries = require('../../echarts').extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this.getData();\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            var sum = data.getSum('value');\n            // FIXME toFixed?\n            //\n            // Percent is 0 if sum is 0\n            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // \n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // \n            clockwise: true,\n            startAngle: 90,\n            // 0\n            minAngle: 0,\n            // \n            selectedOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // singlemultiple\n            // selectedMode: false,\n            // 'radius' | 'area'\n            // roseType: null,\n\n            // If still show when all data zero.\n            stillShowZeroSum: true,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: Tooltip.formatter\n                    // textStyle: null      // TEXTSTYLE\n                    // distance: positioninnerlabel()\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // \n                    length: 15,\n                    // \n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: ,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            // Animation type canbe expansion, scale\n            animationType: 'expansion',\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/PieSeries.js\n// module id = 129\n// module chunks = 0","\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n            )\n        };\n    }\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n\n            var animationType = seriesModel.getShallow('animationType');\n            if (animationType === 'scale') {\n                sector.shape.r = layout.r0;\n                graphic.initProps(sector, {\n                    shape: {\n                        r: layout.r\n                    }\n                }, seriesModel, idx);\n            }\n            // Expansion\n            else {\n                sector.shape.endAngle = layout.startAngle;\n                graphic.updateProps(sector, {\n                    shape: {\n                        endAngle: layout.endAngle\n                    }\n                }, seriesModel, idx);\n            }\n\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + 10\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n            var animationType = seriesModel.get('animationType');\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    // Default expansion animation\n                    if (isFirstRender && animationType !== 'scale') {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (\n                hasAnimation && isFirstRender && data.count() > 0\n                // Default expansion animation\n                && animationType !== 'scale'\n            ) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/PieView.js\n// module id = 130\n// module chunks = 0","'use strict';\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // \n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // \n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0                     // \n                : isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0;                    // \n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/labelLayout.js\n// module id = 131\n// module chunks = 0","// TODO minAngle\n\n\n\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n            var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                if (isNaN(value)) {\n                    data.setItemLayout(idx, {\n                        angle: NaN,\n                        startAngle: NaN,\n                        endAngle: NaN,\n                        clockwise: clockwise,\n                        cx: cx,\n                        cy: cy,\n                        r0: r0,\n                        r: roseType\n                            ? NaN\n                            : r\n                    });\n                    return;\n                }\n\n                // FIXME  2.0  roseType  area \n                if (roseType !== 'area') {\n                    angle = (sum === 0 && stillShowZeroSum)\n                        ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / (data.count() || 1);\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle\n                            ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += dir * angle;\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/pieLayout.js\n// module id = 132\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    // Must use radar component\n    require('../component/radar');\n\n    require('./radar/RadarSeries');\n    require('./radar/RadarView');\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'radar'));\n    echarts.registerVisual(zrUtil.curry(\n        require('../visual/symbol'), 'radar', 'circle', null\n    ));\n    echarts.registerLayout(require('./radar/radarLayout'));\n\n    echarts.registerProcessor(\n        zrUtil.curry(require('../processor/dataFilter'), 'radar')\n    );\n\n    echarts.registerPreprocessor(require('./radar/backwardCompat'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/radar.js\n// module id = 133\n// module chunks = 0","'use strict';\n\n\n    var SeriesModel = require('../../model/Series');\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var encodeHTML = require('../../util/format').encodeHTML;\n\n    var RadarSeries = SeriesModel.extend({\n\n        type: 'series.radar',\n\n        dependencies: ['radar'],\n\n\n        // Overwrite\n        init: function (option) {\n            RadarSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n        },\n\n        getInitialData: function (option, ecModel) {\n            var data = option.data || [];\n            var dimensions = completeDimensions(\n                [], data, [], 'indicator_'\n            );\n            var list = new List(dimensions, this);\n            list.initData(data);\n            return list;\n        },\n\n        formatTooltip: function (dataIndex) {\n            var value = this.getRawValue(dataIndex);\n            var coordSys = this.coordinateSystem;\n            var indicatorAxes = coordSys.getIndicatorAxes();\n            var name = this.getData().getName(dataIndex);\n            return encodeHTML(name === '' ? this.name : name) + '<br/>'\n                + zrUtil.map(indicatorAxes, function (axis, idx) {\n                    return encodeHTML(axis.name + ' : ' + value[idx]);\n                }).join('<br />');\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            coordinateSystem: 'radar',\n            legendHoverLink: true,\n            radarIndex: 0,\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // areaStyle: {\n            // },\n            // itemStyle: {}\n            symbol: 'emptyCircle',\n            symbolSize: 4\n            // symbolRotate: null\n        }\n    });\n\n    module.exports = RadarSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/radar/RadarSeries.js\n// module id = 134\n// module chunks = 0","\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolUtil = require('../../util/symbol');\n\n    function normalizeSymbolSize(symbolSize) {\n        if (!zrUtil.isArray(symbolSize)) {\n            symbolSize = [+symbolSize, +symbolSize];\n        }\n        return symbolSize;\n    }\n    module.exports = require('../../echarts').extendChartView({\n        type: 'radar',\n\n        render: function (seriesModel, ecModel, api) {\n            var polar = seriesModel.coordinateSystem;\n            var group = this.group;\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            function createSymbol(data, idx) {\n                var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n                var color = data.getItemVisual(idx, 'color');\n                if (symbolType === 'none') {\n                    return;\n                }\n                var symbolPath = symbolUtil.createSymbol(\n                    symbolType, -0.5, -0.5, 1, 1, color\n                );\n                symbolPath.attr({\n                    style: {\n                        strokeNoScale: true\n                    },\n                    z2: 100,\n                    scale: normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))\n                });\n                return symbolPath;\n            }\n\n            function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n                // Simply rerender all\n                symbolGroup.removeAll();\n                for (var i = 0; i < newPoints.length - 1; i++) {\n                    var symbolPath = createSymbol(data, idx);\n                    if (symbolPath) {\n                        symbolPath.__dimIdx = i;\n                        if (oldPoints[i]) {\n                            symbolPath.attr('position', oldPoints[i]);\n                            graphic[isInit ? 'initProps' : 'updateProps'](\n                                symbolPath, {\n                                    position: newPoints[i]\n                                }, seriesModel, idx\n                            );\n                        }\n                        else {\n                            symbolPath.attr('position', newPoints[i]);\n                        }\n                        symbolGroup.add(symbolPath);\n                    }\n                }\n            }\n\n            function getInitialPoints(points) {\n                return zrUtil.map(points, function (pt) {\n                    return [polar.cx, polar.cy];\n                });\n            }\n            data.diff(oldData)\n                .add(function (idx) {\n                    var points = data.getItemLayout(idx);\n                    if (!points) {\n                        return;\n                    }\n                    var polygon = new graphic.Polygon();\n                    var polyline = new graphic.Polyline();\n                    var target = {\n                        shape: {\n                            points: points\n                        }\n                    };\n                    polygon.shape.points = getInitialPoints(points);\n                    polyline.shape.points = getInitialPoints(points);\n                    graphic.initProps(polygon, target, seriesModel, idx);\n                    graphic.initProps(polyline, target, seriesModel, idx);\n\n                    var itemGroup = new graphic.Group();\n                    var symbolGroup = new graphic.Group();\n                    itemGroup.add(polyline);\n                    itemGroup.add(polygon);\n                    itemGroup.add(symbolGroup);\n\n                    updateSymbols(\n                        polyline.shape.points, points, symbolGroup, data, idx, true\n                    );\n\n                    data.setItemGraphicEl(idx, itemGroup);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var itemGroup = oldData.getItemGraphicEl(oldIdx);\n                    var polyline = itemGroup.childAt(0);\n                    var polygon = itemGroup.childAt(1);\n                    var symbolGroup = itemGroup.childAt(2);\n                    var target = {\n                        shape: {\n                            points: data.getItemLayout(newIdx)\n                        }\n                    };\n                    if (!target.shape.points) {\n                        return;\n                    }\n                    updateSymbols(\n                        polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false\n                    );\n\n                    graphic.updateProps(polyline, target, seriesModel);\n                    graphic.updateProps(polygon, target, seriesModel);\n\n                    data.setItemGraphicEl(newIdx, itemGroup);\n                })\n                .remove(function (idx) {\n                    group.remove(oldData.getItemGraphicEl(idx));\n                })\n                .execute();\n\n            data.eachItemGraphicEl(function (itemGroup, idx) {\n                var itemModel = data.getItemModel(idx);\n                var polyline = itemGroup.childAt(0);\n                var polygon = itemGroup.childAt(1);\n                var symbolGroup = itemGroup.childAt(2);\n                var color = data.getItemVisual(idx, 'color');\n\n                group.add(itemGroup);\n\n                polyline.useStyle(\n                    zrUtil.defaults(\n                        itemModel.getModel('lineStyle.normal').getLineStyle(),\n                        {\n                            fill: 'none',\n                            stroke: color\n                        }\n                    )\n                );\n                polyline.hoverStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n                var areaStyleModel = itemModel.getModel('areaStyle.normal');\n                var hoverAreaStyleModel = itemModel.getModel('areaStyle.emphasis');\n                var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n                var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();\n\n                hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;\n                polygon.ignore = polygonIgnore;\n\n                polygon.useStyle(\n                    zrUtil.defaults(\n                        areaStyleModel.getAreaStyle(),\n                        {\n                            fill: color,\n                            opacity: 0.7\n                        }\n                    )\n                );\n                polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();\n\n                var itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);\n                var itemHoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();\n                var labelModel = itemModel.getModel('label.normal');\n                var labelHoverModel = itemModel.getModel('label.emphasis');\n                symbolGroup.eachChild(function (symbolPath) {\n                    symbolPath.setStyle(itemStyle);\n                    symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);\n\n                    var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);\n                    graphic.setText(symbolPath.style, labelModel, color);\n                    symbolPath.setStyle({\n                        text: labelModel.get('show') ? zrUtil.retrieve(\n                            seriesModel.getFormattedLabel(\n                                idx, 'normal', null, symbolPath.__dimIdx\n                            ),\n                            defaultText\n                        ) : ''\n                    });\n\n                    graphic.setText(symbolPath.hoverStyle, labelHoverModel, color);\n                    symbolPath.hoverStyle.text = labelHoverModel.get('show') ? zrUtil.retrieve(\n                        seriesModel.getFormattedLabel(\n                            idx, 'emphasis', null, symbolPath.__dimIdx\n                        ),\n                        defaultText\n                    ) : '';\n                });\n\n                function onEmphasis() {\n                    polygon.attr('ignore', hoverPolygonIgnore);\n                }\n\n                function onNormal() {\n                    polygon.attr('ignore', polygonIgnore);\n                }\n\n                itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');\n                itemGroup.on('emphasis', onEmphasis)\n                    .on('mouseover', onEmphasis)\n                    .on('normal', onNormal)\n                    .on('mouseout', onNormal);\n\n                graphic.setHoverStyle(itemGroup);\n            });\n\n            this._data = data;\n        },\n\n        remove: function () {\n            this.group.removeAll();\n            this._data = null;\n        },\n\n        dispose: function () {}\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/radar/RadarView.js\n// module id = 135\n// module chunks = 0","// Backward compat for radar chart in 2\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (option) {\n        var polarOptArr = option.polar;\n        if (polarOptArr) {\n            if (!zrUtil.isArray(polarOptArr)) {\n                polarOptArr = [polarOptArr];\n            }\n            var polarNotRadar = [];\n            zrUtil.each(polarOptArr, function (polarOpt, idx) {\n                if (polarOpt.indicator) {\n                    if (polarOpt.type && !polarOpt.shape) {\n                        polarOpt.shape = polarOpt.type;\n                    }\n                    option.radar = option.radar || [];\n                    if (!zrUtil.isArray(option.radar)) {\n                        option.radar = [option.radar];\n                    }\n                    option.radar.push(polarOpt);\n                }\n                else {\n                    polarNotRadar.push(polarOpt);\n                }\n            });\n            option.polar = polarNotRadar;\n        }\n        zrUtil.each(option.series, function (seriesOpt) {\n            if (seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n                seriesOpt.radarIndex = seriesOpt.polarIndex;\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/radar/backwardCompat.js\n// module id = 136\n// module chunks = 0","\n\n    module.exports = function (ecModel) {\n        ecModel.eachSeriesByType('radar', function (seriesModel) {\n            var data = seriesModel.getData();\n            var points = [];\n            var coordSys = seriesModel.coordinateSystem;\n            if (!coordSys) {\n                return;\n            }\n\n            function pointsConverter(val, idx) {\n                points[idx] = points[idx] || [];\n                points[idx][i] = coordSys.dataToPoint(val, i);\n            }\n            for (var i = 0; i < coordSys.getIndicatorAxes().length; i++) {\n                var dim = data.dimensions[i];\n                data.each(dim, pointsConverter);\n            }\n\n            data.each(function (idx) {\n                // Close polygon\n                points[idx][0] && points[idx].push(points[idx][0].slice());\n                data.setItemLayout(idx, points[idx]);\n            });\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/radar/radarLayout.js\n// module id = 137\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./scatter/ScatterSeries');\n    require('./scatter/ScatterView');\n\n    echarts.registerVisual(zrUtil.curry(\n        require('../visual/symbol'), 'scatter', 'circle', null\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        require('../layout/points'), 'scatter'\n    ));\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/scatter.js\n// module id = 138\n// module chunks = 0","'use strict';\n\n\n    var createListFromArray = require('../helper/createListFromArray');\n    var SeriesModel = require('../../model/Series');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.scatter',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            var list = createListFromArray(option.data, this, ecModel);\n            return list;\n        },\n\n        brushSelector: 'point',\n\n        defaultOption: {\n            coordinateSystem: 'cartesian2d',\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // Polar coordinate system\n            // polarIndex: 0,\n\n            // Geo coordinate system\n            // geoIndex: 0,\n\n            // symbol: null,        // \n            symbolSize: 10,          // symbolSize * 2\n            // symbolRotate: null,  // \n\n            large: false,\n            // Available when large is true\n            largeThreshold: 2000,\n\n            // label: {\n                // normal: {\n                    // show: false\n                    // distance: 5,\n                    // formatter: Tooltip.formatter\n                    // position: 'top''right'\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // TEXTSTYLE\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    opacity: 0.8\n                    // color: \n                }\n            }\n        }\n\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/scatter/ScatterSeries.js\n// module id = 139\n// module chunks = 0","\n\n    var SymbolDraw = require('../helper/SymbolDraw');\n    var LargeSymbolDraw = require('../helper/LargeSymbolDraw');\n\n    require('../../echarts').extendChartView({\n\n        type: 'scatter',\n\n        init: function () {\n            this._normalSymbolDraw = new SymbolDraw();\n            this._largeSymbolDraw = new LargeSymbolDraw();\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var data = seriesModel.getData();\n            var largeSymbolDraw = this._largeSymbolDraw;\n            var normalSymbolDraw = this._normalSymbolDraw;\n            var group = this.group;\n\n            var symbolDraw = seriesModel.get('large') && data.count() > seriesModel.get('largeThreshold')\n                ? largeSymbolDraw : normalSymbolDraw;\n\n            this._symbolDraw = symbolDraw;\n            symbolDraw.updateData(data);\n            group.add(symbolDraw.group);\n\n            group.remove(\n                symbolDraw === largeSymbolDraw\n                ? normalSymbolDraw.group : largeSymbolDraw.group\n            );\n        },\n\n        updateLayout: function (seriesModel) {\n            this._symbolDraw.updateLayout(seriesModel);\n        },\n\n        remove: function (ecModel, api) {\n            this._symbolDraw && this._symbolDraw.remove(api, true);\n        },\n\n        dispose: function () {}\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/scatter/ScatterView.js\n// module id = 140\n// module chunks = 0","'use strict';\n// TODO boundaryGap\n\n\n    require('../coord/cartesian/AxisModel');\n\n    require('./axis/AxisView');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis.js\n// module id = 141\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var AxisView = require('../../echarts').extendComponentView({\n\n        type: 'axis',\n\n        render: function (axisModel, ecModel) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.getCoordSysModel();\n\n            var layout = layoutAxis(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.isBlank()) {\n                return;\n            }\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.isBlank()) {\n                return;\n            }\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    AxisView.extend({\n        type: 'xAxis'\n    });\n    AxisView.extend({\n        type: 'yAxis'\n    });\n\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisView.js\n// module id = 142\n// module chunks = 0","\n    // List layout\n    var layout = require('../../util/layout');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n\n    function positionGroup(group, model, api) {\n        layout.positionElement(\n            group, model.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            model.get('padding')\n        );\n    }\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, componentModel.get('padding'));\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            positionGroup(group, componentModel, api);\n        },\n\n        addBackground: function (group, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var boundingRect = group.getBoundingRect();\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: boundingRect.x - padding[3],\n                    y: boundingRect.y - padding[0],\n                    width: boundingRect.width + padding[1] + padding[3],\n                    height: boundingRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/helper/listComponent.js\n// module id = 143\n// module chunks = 0","/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        /**\n         * @param {string} name\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/helper/selectableMixin.js\n// module id = 144\n// module chunks = 0","/**\n * Legend component entry file8\n */\n\n\n    require('./legend/LegendModel');\n    require('./legend/legendAction');\n    require('./legend/LegendView');\n\n    var echarts = require('../echarts');\n    // Series Filter\n    echarts.registerProcessor(require('./legend/legendFilter'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend.js\n// module id = 145\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Model = require('../../model/Model');\n\n    var LegendModel = require('../../echarts').extendComponentModel({\n\n        type: 'legend',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 4,\n            show: true,\n\n            // \n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 'top',\n            // bottom: 'top',\n\n            // \n            // 'auto' | 'left' | 'right'\n            //  'auto',  x \n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // \n            borderColor: '#ccc',\n            // px0\n            borderWidth: 0,\n            // px5\n            // css\n            padding: 5,\n            // itempx10\n            // \n            itemGap: 10,\n            // \n            itemWidth: 25,\n            // \n            itemHeight: 14,\n\n            // \n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // \n                color: '#333'\n            },\n            // formatter: '',\n            // \n            selectedMode: true,\n            // LEGEND.SELECTED\n            // selected: null,\n            // legend.dataitem\n            // data: [],\n\n            // Tooltip \n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/LegendModel.js\n// module id = 146\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolCreator = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var listComponentHelper = require('../helper/listComponent');\n\n    var curry = zrUtil.curry;\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'legend',\n\n        init: function () {\n            this._symbolTypeStore = {};\n        },\n\n        render: function (legendModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!legendModel.get('show')) {\n                return;\n            }\n\n            var selectMode = legendModel.get('selectedMode');\n            var itemAlign = legendModel.get('align');\n\n            if (itemAlign === 'auto') {\n                itemAlign = (legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical')\n                    ? 'right' : 'left';\n            }\n\n            var legendDrawedMap = {};\n\n            zrUtil.each(legendModel.getData(), function (itemModel) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (name === '' || name === '\\n') {\n                    group.add(new graphic.Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawedMap[name]) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawedMap[name] = true;\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawedMap[name]) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawedMap[name] = true;\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawedMap[name]) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n\n            listComponentHelper.layout(group, legendModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, legendModel);\n        },\n\n        _createItem: function (\n            name, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new graphic.Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            // Text\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name != null ? name : '');\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            var text = new graphic.Text({\n                style: {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textFont: textStyleModel.getFont(),\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                }\n            });\n            itemGroup.add(text);\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n\n\n            this.group.add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            return itemGroup;\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/LegendView.js\n// module id = 147\n// module chunks = 0","/**\n * @file Legend action\n */\n\n\n    var echarts = require('../../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (name in selectedMap) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/legendAction.js\n// module id = 148\n// module chunks = 0","\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/legendFilter.js\n// module id = 149\n// module chunks = 0","\n\n    require('../coord/radar/Radar');\n    require('../coord/radar/RadarModel');\n\n    require('./radar/RadarView');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/radar.js\n// module id = 150\n// module chunks = 0","\n\n    var AxisBuilder = require('../axis/AxisBuilder');\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'radar',\n\n        render: function (radarModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            this._buildAxes(radarModel);\n            this._buildSplitLineAndArea(radarModel);\n        },\n\n        _buildAxes: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {\n                var axisBuilder = new AxisBuilder(indicatorAxis.model, {\n                    position: [radar.cx, radar.cy],\n                    rotation: indicatorAxis.angle,\n                    labelDirection: -1,\n                    tickDirection: -1,\n                    nameDirection: 1\n                });\n                return axisBuilder;\n            });\n\n            zrUtil.each(axisBuilders, function (axisBuilder) {\n                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n                this.group.add(axisBuilder.getGroup());\n            }, this);\n        },\n\n        _buildSplitLineAndArea: function (radarModel) {\n            var radar = radarModel.coordinateSystem;\n            var indicatorAxes = radar.getIndicatorAxes();\n            if (!indicatorAxes.length) {\n                return;\n            }\n            var shape = radarModel.get('shape');\n            var splitLineModel = radarModel.getModel('splitLine');\n            var splitAreaModel = radarModel.getModel('splitArea');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\n            var showSplitLine = splitLineModel.get('show');\n            var showSplitArea = splitAreaModel.get('show');\n            var splitLineColors = lineStyleModel.get('color');\n            var splitAreaColors = areaStyleModel.get('color');\n\n            splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n            splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n\n            var splitLines = [];\n            var splitAreas = [];\n\n            function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n                var colorIndex = idx % areaOrLineColorList.length;\n                areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n                return colorIndex;\n            }\n\n            if (shape === 'circle') {\n                var ticksRadius = indicatorAxes[0].getTicksCoords();\n                var cx = radar.cx;\n                var cy = radar.cy;\n                for (var i = 0; i < ticksRadius.length; i++) {\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Circle({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r: ticksRadius[i]\n                            }\n                        }));\n                    }\n                    if (showSplitArea && i < ticksRadius.length - 1) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);\n                        splitAreas[colorIndex].push(new graphic.Ring({\n                            shape: {\n                                cx: cx,\n                                cy: cy,\n                                r0: ticksRadius[i],\n                                r: ticksRadius[i + 1]\n                            }\n                        }));\n                    }\n                }\n            }\n            // Polyyon\n            else {\n                var realSplitNumber = -1;\n                var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {\n                    var ticksCoords = indicatorAxis.getTicksCoords();\n                    realSplitNumber = Math.max(ticksCoords.length - 1, realSplitNumber);\n                    return zrUtil.map(ticksCoords, function (tickCoord) {\n                        return radar.coordToPoint(tickCoord, idx);\n                    });\n                });\n\n                var prevPoints = [];\n                for (var i = 0; i <= realSplitNumber; i++) {\n                    var points = [];\n                    for (var j = 0; j < indicatorAxes.length; j++) {\n                        points.push(axesTicksPoints[j][i]);\n                    }\n                    // Close\n                    if (points[0]) {\n                        points.push(points[0].slice());\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.error('Can\\'t draw value axis ' + i);\n                        }\n                    }\n                    if (showSplitLine) {\n                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                        splitLines[colorIndex].push(new graphic.Polyline({\n                            shape: {\n                                points: points\n                            }\n                        }));\n                    }\n                    if (showSplitArea && prevPoints) {\n                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);\n                        splitAreas[colorIndex].push(new graphic.Polygon({\n                            shape: {\n                                points: points.concat(prevPoints)\n                            }\n                        }));\n                    }\n                    prevPoints = points.slice().reverse();\n                }\n            }\n\n            var lineStyle = lineStyleModel.getLineStyle();\n            var areaStyle = areaStyleModel.getAreaStyle();\n            // Add splitArea before splitLine\n            zrUtil.each(splitAreas, function (splitAreas, idx) {\n                this.group.add(graphic.mergePath(\n                    splitAreas, {\n                        style: zrUtil.defaults({\n                            stroke: 'none',\n                            fill: splitAreaColors[idx % splitAreaColors.length]\n                        }, areaStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n            zrUtil.each(splitLines, function (splitLines, idx) {\n                this.group.add(graphic.mergePath(\n                    splitLines, {\n                        style: zrUtil.defaults({\n                            fill: 'none',\n                            stroke: splitLineColors[idx % splitLineColors.length]\n                        }, lineStyle),\n                        silent: true\n                    }\n                ));\n            }, this);\n\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/radar/RadarView.js\n// module id = 151\n// module chunks = 0","'use strict';\n\n\n    var echarts = require('../echarts');\n    var graphic = require('../util/graphic');\n    var layout = require('../util/layout');\n\n    // Model\n    echarts.extendComponentModel({\n\n        type: 'title',\n\n        layoutMode: {type: 'box', ignoreSize: true},\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 6,\n            show: true,\n\n            text: '',\n            // \n            // link: null,\n            // self | blank\n            target: 'blank',\n            subtext: '',\n\n            // \n            // sublink: null,\n            // self | blank\n            subtarget: 'blank',\n\n            // 'center'  'left'  'right'\n            //  {number}xpx\n            left: 0,\n            // 'top'  'bottom'  'center'\n            //  {number}ypx\n            top: 0,\n\n            // \n            // 'auto' | 'left' | 'right' | 'center'\n            //  left \n            // textAlign: null\n            //\n            // \n            // 'auto' | 'top' | 'bottom' | 'middle'\n            //  top \n            // textBaseline: null\n\n            backgroundColor: 'rgba(0,0,0,0)',\n\n            // \n            borderColor: '#ccc',\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // px10\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: {\n                color: '#aaa'\n            }\n        }\n    });\n\n    // View\n    echarts.extendComponentView({\n\n        type: 'title',\n\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n\n            if (!titleModel.get('show')) {\n                return;\n            }\n\n            var group = this.group;\n\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n\n            var textEl = new graphic.Text({\n                style: {\n                    text: titleModel.get('text'),\n                    textFont: textStyleModel.getFont(),\n                    fill: textStyleModel.getTextColor()\n                },\n                z2: 10\n            });\n\n            var textRect = textEl.getBoundingRect();\n\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                style: {\n                    text: subText,\n                    textFont: subtextStyleModel.getFont(),\n                    fill: subtextStyleModel.getTextColor(),\n                    y: textRect.height + titleModel.get('itemGap'),\n                    textBaseline: 'top'\n                },\n                z2: 10\n            });\n\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(\n                layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding')\n            );\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                }\n                else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                }\n                else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n\n                textBaseline = textBaseline || 'top';\n            }\n\n            group.attr('position', [layoutRect.x, layoutRect.y]);\n            var alignStyle = {\n                textAlign: textAlign,\n                textVerticalAlign: textBaseline\n            };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle(['color', 'opacity']);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: groupRect.x - padding[3],\n                    y: groupRect.y - padding[0],\n                    width: groupRect.width + padding[1] + padding[3],\n                    height: groupRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/title.js\n// module id = 152\n// module chunks = 0","// FIXME Better way to pack data in graphic element\n\n\n    require('./tooltip/TooltipModel');\n\n    require('./tooltip/TooltipView');\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    require('../echarts').registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    require('../echarts').registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip.js\n// module id = 153\n// module chunks = 0","/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var zrColor = require('zrender/lib/tool/color');\n    var eventUtil = require('zrender/lib/core/event');\n    var formatUtil = require('../../util/format');\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = require('zrender/lib/core/env');\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        tooltipModel = tooltipModel;\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self.enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self.enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self.enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            var el = this.el;\n            el.innerHTML = content;\n            el.style.display = content ? 'block' : 'none';\n        },\n\n        moveTo: function (x, y) {\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        // showLater: function ()\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this.enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipContent.js\n// module id = 154\n// module chunks = 0","\n\n    require('../../echarts').extendComponentModel({\n\n        type: 'tooltip',\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip\n            showContent: true,\n\n            // 'item'  'axis'\n            trigger: 'item',\n\n            //  'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove',\n\n            //  content\n            alwaysShowContent: false,\n\n            //  {Array} | {Function}\n            // position: null\n\n            //  content  viewRect  false \n            confine: false,\n\n            // {string}Template  {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // ms\n            hideDelay: 100,\n\n            // s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 0.7\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // \n            borderColor: '#333',\n\n            // px4\n            borderRadius: 4,\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // \n            axisPointer: {\n                // \n                // 'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type  line  tooltip line \n                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n                //  'auto' cateogry  x \n                //  angle \n                axis: 'auto',\n\n                animation: true,\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                // \n                lineStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'solid'\n                },\n\n                crossStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                },\n\n                // \n                shadowStyle: {\n                    color: 'rgba(150,150,150,0.3)'\n                }\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipModel.js\n// module id = 155\n// module chunks = 0","\n\n    var TooltipContent = require('./TooltipContent');\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var numberUtil = require('../../util/number');\n    var modelUtil = require('../../util/model');\n    var parsePercent = numberUtil.parsePercent;\n    var env = require('zrender/lib/core/env');\n    var Model = require('../../model/Model');\n\n    function dataEqual(a, b) {\n        if (!a || !b) {\n            return false;\n        }\n        var round = numberUtil.round;\n        return round(a[0]) === round(b[0])\n            && round(a[1]) === round(b[1]);\n    }\n    /**\n     * @inner\n     */\n    function makeLineShape(x1, y1, x2, y2) {\n        return {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeRectShape(x, y, width, height) {\n        return {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n        var gap = 20;\n\n        if (x + width + gap > viewWidth) {\n            x -= width + gap;\n        }\n        else {\n            x += gap;\n        }\n        if (y + height + gap > viewHeight) {\n            y -= height + gap;\n        }\n        else {\n            y += gap;\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, dom) {\n        var domWidth = dom.clientWidth;\n        var domHeight = dom.clientHeight;\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    /**\n     * @param  {string|Function|Array.<number>} positionExpr\n     * @param  {number} x Mouse x\n     * @param  {number} y Mouse y\n     * @param  {boolean} confine Whether confine tooltip content in view rect.\n     * @param  {module:echarts/component/tooltip/TooltipContent} content\n     * @param  {Object|<Array.<Object>} params\n     * @param  {module:zrender/Element} el target element\n     * @param  {module:echarts/ExtensionAPI} api\n     * @return {Array.<number>}\n     */\n    function updatePosition(positionExpr, x, y, confine, content, params, el, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n\n        var rect = el && el.getBoundingRect().clone();\n        el && rect.applyTransform(el.transform);\n        if (typeof positionExpr === 'function') {\n            // Callback of position can be an array or a string specify the position\n            positionExpr = positionExpr([x, y], params, content.el, rect);\n        }\n\n        if (zrUtil.isArray(positionExpr)) {\n            x = parsePercent(positionExpr[0], viewWidth);\n            y = parsePercent(positionExpr[1], viewHeight);\n        }\n        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n        else if (typeof positionExpr === 'string' && el) {\n            var pos = calcTooltipPosition(\n                positionExpr, rect, content.el\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n        else {\n            var pos = refixTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        if (confine) {\n            var pos = confineTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        content.moveTo(x, y);\n    }\n\n    function ifSeriesSupportAxisTrigger(seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var trigger = seriesModel.get('tooltip.trigger', true);\n        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n        return !(!coordSys\n            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n            || trigger === 'item');\n    }\n\n    require('../../echarts').extendComponentView({\n\n        type: 'tooltip',\n\n        _axisPointers: {},\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._axisPointers = {};\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._lastHover = {\n                // data\n                // payloadBatch\n            };\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.enterable = tooltipModel.get('enterable');\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            /**\n             * @type {Object.<string, Array>}\n             */\n            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n                tooltipModel, ecModel\n            );\n\n            var crossText = this._crossText;\n            if (crossText) {\n                this.group.add(crossText);\n            }\n\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && triggerOn !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n\n            var zr = this._api.getZr();\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n\n            if (triggerOn === 'click') {\n                zr.on('click', this._tryShow, this);\n            }\n            else if (triggerOn === 'mousemove') {\n                zr.on('mousemove', this._mousemove, this);\n                zr.on('mouseout', this._hide, this);\n                zr.on('globalout', this._hide, this);\n            }\n            // else triggerOn is 'none', which enable user\n            // to control tooltip totally using API.\n        },\n\n        _mousemove: function (e) {\n            var showDelay = this._tooltipModel.get('showDelay');\n            var self = this;\n            clearTimeout(this._showTimeout);\n            if (showDelay > 0) {\n                this._showTimeout = setTimeout(function () {\n                    self._tryShow(e);\n                }, showDelay);\n            }\n            else {\n                this._tryShow(e);\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            // From self\n            if (payload.from === this.uid) {\n                return;\n            }\n\n            var ecModel = this._ecModel;\n            var seriesIndex = payload.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            var api = this._api;\n\n            var isTriggerAxis = this._tooltipModel.get('trigger') === 'axis';\n            function seriesHaveDataOnIndex(_series) {\n                var data = _series.getData();\n                var dataIndex = modelUtil.queryDataIndex(data, payload);\n                // Have single dataIndex\n                if (dataIndex != null && !zrUtil.isArray(dataIndex)\n                    && data.hasValue(dataIndex)\n                ) {\n                    return true;\n                }\n            }\n\n            if (payload.x == null || payload.y == null) {\n                if (isTriggerAxis) {\n                    // Find another series.\n                    if (seriesModel && !seriesHaveDataOnIndex(seriesModel)) {\n                        seriesModel = null;\n                    }\n                    if (!seriesModel) {\n                        // Find the first series can use axis trigger And data is not null\n                        ecModel.eachSeries(function (_series) {\n                            if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n                                if (seriesHaveDataOnIndex(_series)) {\n                                    seriesModel = _series;\n                                }\n                            }\n                        });\n                    }\n                }\n                else {\n                    // Use the first series by default.\n                    seriesModel = seriesModel || ecModel.getSeriesByIndex(0);\n                }\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n                        return;\n                    }\n\n                    var el = data.getItemGraphicEl(dataIndex);\n                    var cx;\n                    var cy;\n                    // Try to get the point in coordinate system\n                    var coordSys = seriesModel.coordinateSystem;\n                    if (seriesModel.getTooltipPosition) {\n                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n                        cx = point[0];\n                        cy = point[1];\n                    }\n                    else if (coordSys && coordSys.dataToPoint) {\n                        var point = coordSys.dataToPoint(\n                            data.getValues(\n                                zrUtil.map(coordSys.dimensions, function (dim) {\n                                    return seriesModel.coordDimToDataDim(dim)[0];\n                                }), dataIndex, true\n                            )\n                        );\n                        cx = point && point[0];\n                        cy = point && point[1];\n                    }\n                    else if (el) {\n                        // Use graphic bounding rect\n                        var rect = el.getBoundingRect().clone();\n                        rect.applyTransform(el.transform);\n                        cx = rect.x + rect.width / 2;\n                        cy = rect.y + rect.height / 2;\n                    }\n\n                    if (cx != null && cy != null) {\n                        this._tryShow({\n                            offsetX: cx,\n                            offsetY: cy,\n                            position: payload.position,\n                            target: el,\n                            event: {}\n                        });\n                    }\n                }\n            }\n            else {\n                var el = api.getZr().handler.findHover(payload.x, payload.y);\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: el,\n                    event: {}\n                });\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid) {\n                return;\n            }\n\n            this._hide();\n        },\n\n        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n            // Prepare data for axis trigger\n            var seriesGroupByAxis = {};\n            ecModel.eachSeries(function (seriesModel) {\n                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n                    var coordSys = seriesModel.coordinateSystem;\n                    var baseAxis;\n                    var key;\n\n                    // Only cartesian2d, polar and single support axis trigger\n                    if (coordSys.type === 'cartesian2d') {\n                        // FIXME `axisPointer.axis` is not baseAxis\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + baseAxis.index;\n                    }\n                    else if (coordSys.type === 'singleAxis') {\n                        baseAxis = coordSys.getAxis();\n                        key = baseAxis.dim + baseAxis.type;\n                    }\n                    else {\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + coordSys.name;\n                    }\n\n                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n                        coordSys: [],\n                        series: []\n                    };\n                    seriesGroupByAxis[key].coordSys.push(coordSys);\n                    seriesGroupByAxis[key].series.push(seriesModel);\n                }\n            }, this);\n\n            return seriesGroupByAxis;\n        },\n\n        /**\n         * mousemove handler\n         * @param {Object} e\n         * @private\n         */\n        _tryShow: function (e) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n            var globalTrigger = tooltipModel.get('trigger');\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            // Always show item tooltip if mouse is on the element with dataIndex\n            if (el && el.dataIndex != null) {\n                // Use dataModel in element if possible\n                // Used when mouseover on a element like markPoint or edge\n                // In which case, the data is not main data in series.\n                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                var dataIndex = el.dataIndex;\n                var data = dataModel.getData();\n                var itemModel = data.getItemModel(dataIndex);\n                // Series or single data may use item trigger when global is axis trigger\n                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n                else {\n                    // Reset ticket\n                    this._ticket = '';\n                    // If either single data or series use item trigger\n                    this._hideAxisPointer();\n                    // Reset last hover and dispatch downplay action\n                    this._resetLastHover();\n\n                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n                }\n\n                api.dispatchAction({\n                    type: 'showTip',\n                    from: this.uid,\n                    dataIndexInside: dataIndex,\n                    dataIndex: data.getRawIndex(dataIndex), // expose to user.\n                    seriesIndex: el.seriesIndex\n                });\n            }\n            // Tooltip provided directly. Like legend\n            else if (el && el.tooltip) {\n                var tooltipOpt = el.tooltip;\n                if (typeof tooltipOpt === 'string') {\n                    var content = tooltipOpt;\n                    tooltipOpt = {\n                        content: content,\n                        // Fixed formatter\n                        formatter: content\n                    };\n                }\n                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n                var defaultHtml = subTooltipModel.get('content');\n                var asyncTicket = Math.random();\n                this._showTooltipContent(\n                    // TODO params\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n                );\n            }\n            else {\n                if (globalTrigger === 'item') {\n                    this._hide();\n                }\n                else {\n                    // Try show axis tooltip\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n\n                // Action of cross pointer\n                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n                if (tooltipModel.get('axisPointer.type') === 'cross') {\n                    api.dispatchAction({\n                        type: 'showTip',\n                        from: this.uid,\n                        x: e.offsetX,\n                        y: e.offsetY\n                    });\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on axis\n         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} e\n         * @private\n         */\n        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n            var axisPointerModel = tooltipModel.getModel('axisPointer');\n            var axisPointerType = axisPointerModel.get('type');\n\n            if (axisPointerType === 'cross') {\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n                    var dataIndex = el.dataIndex;\n                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n                }\n            }\n\n            this._showAxisPointer();\n            var allNotShow = true;\n            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n                // Try show the axis pointer\n                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n                var coordSys = allCoordSys[0];\n\n                // If mouse position is not in the grid or polar\n                var point = [e.offsetX, e.offsetY];\n\n                if (!coordSys.containPoint(point)) {\n                    // Hide axis pointer\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                allNotShow = false;\n                // Make sure point is discrete on cateogry axis\n                var dimensions = coordSys.dimensions;\n                var value = coordSys.pointToData(point, true);\n                point = coordSys.dataToPoint(value);\n\n                var baseAxis = coordSys.getBaseAxis();\n                var axisType = axisPointerModel.get('axis');\n                if (axisType === 'auto') {\n                    axisType = baseAxis.dim;\n                }\n\n                if (baseAxis.isBlank() || zrUtil.eqNaN(point[0]) || zrUtil.eqNaN(point[1])) {\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                var contentNotChange = false;\n                var lastHover = this._lastHover;\n                if (axisPointerType === 'cross') {\n                    // If hover data not changed\n                    // Possible when two axes are all category\n                    if (dataEqual(lastHover.data, value)) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value;\n                }\n                else {\n                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\n                    // If hover data not changed on the axis dimension\n                    if (lastHover.data === value[valIndex]) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value[valIndex];\n                }\n\n                var enableAnimation = tooltipModel.get('animation');\n\n                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n                    this._showCartesianPointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n                else if (coordSys.type === 'polar' && !contentNotChange) {\n                    this._showPolarPointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n                    this._showSinglePointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n\n                if (axisPointerType !== 'cross') {\n                    this._dispatchAndShowSeriesTooltipContent(\n                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n                    );\n                }\n            }, this);\n\n            if (!this._tooltipModel.get('show')) {\n                this._hideAxisPointer();\n            }\n\n            if (allNotShow) {\n                this._hide();\n            }\n        },\n\n        /**\n         * Show tooltip on axis of cartesian coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         * @private\n         */\n        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point, enableAnimation) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n            var baseAxis = cartesian.getBaseAxis();\n            var moveAnimation = enableAnimation\n                && axisPointerType !== 'cross'\n                && baseAxis.type === 'category'\n                && baseAxis.getBandWidth() > 20;\n\n            if (axisPointerType === 'cross') {\n                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\n                this._updateCrossText(cartesian, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n                var otherExtent = otherAxis.getGlobalExtent();\n\n                if (cartesian.type === 'cartesian2d') {\n                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n                        axisType, point, otherExtent\n                    );\n                }\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridLine(axisType, point, otherExtent) {\n                var targetShape = axisType === 'x'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                graphic.subPixelOptimizeLine({\n                    shape: targetShape,\n                    style: pointerEl.style\n                });\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridShadow(axisType, point, otherExtent) {\n                var axis = cartesian.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n                var span = otherExtent[1] - otherExtent[0];\n                var targetShape = axisType === 'x'\n                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _showSinglePointer: function (axisPointerModel, single, axisType, point, enableAnimation) {\n            var self = this;\n            var axisPointerType = axisPointerModel.get('type');\n            var moveAnimation =\n                enableAnimation\n                && axisPointerType !== 'cross'\n                && single.getBaseAxis().type === 'category';\n            var rect = single.getRect();\n            var otherExtent = [rect.y, rect.y + rect.height];\n\n            moveSingleLine(axisType, point, otherExtent);\n\n            /**\n             * @inner\n             */\n            function moveSingleLine(axisType, point, otherExtent) {\n                var axis = single.getAxis();\n                var orient = axis.orient;\n\n                var targetShape = orient === 'horizontal'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    single, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n        },\n\n        /**\n         * Show tooltip on axis of polar coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         */\n        _showPolarPointer: function (axisPointerModel, polar, axisType, point, enableAnimation) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n\n            var angleAxis = polar.getAngleAxis();\n            var radiusAxis = polar.getRadiusAxis();\n\n            var moveAnimation = enableAnimation\n                && axisPointerType !== 'cross'\n                && polar.getBaseAxis().type === 'category';\n\n            if (axisPointerType === 'cross') {\n                movePolarLine('angle', point, radiusAxis.getExtent());\n                movePolarLine('radius', point, angleAxis.getExtent());\n\n                this._updateCrossText(polar, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n                var otherExtent = otherAxis.getExtent();\n\n                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n                    axisType, point, otherExtent\n                );\n            }\n            /**\n             * @inner\n             */\n            function movePolarLine(axisType, point, otherExtent) {\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                if (axisType === 'angle') {\n                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n                }\n                else {\n                    targetShape = {\n                        cx: polar.cx,\n                        cy: polar.cy,\n                        r: mouseCoord[0]\n                    };\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function movePolarShadow(axisType, point, otherExtent) {\n                var axis = polar.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                var radian = Math.PI / 180;\n\n                if (axisType === 'angle') {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        otherExtent[0], otherExtent[1],\n                        // In ECharts y is negative if angle is positive\n                        (-mouseCoord[1] - bandWidth / 2) * radian,\n                        (-mouseCoord[1] + bandWidth / 2) * radian\n                    );\n                }\n                else {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        mouseCoord[0] - bandWidth / 2,\n                        mouseCoord[0] + bandWidth / 2,\n                        0, Math.PI * 2\n                    );\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _updateCrossText: function (coordSys, point, axisPointerModel) {\n            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n            var textStyleModel = crossStyleModel.getModel('textStyle');\n\n            var tooltipModel = this._tooltipModel;\n\n            var text = this._crossText;\n            if (!text) {\n                text = this._crossText = new graphic.Text({\n                    style: {\n                        textAlign: 'left',\n                        textVerticalAlign: 'bottom'\n                    }\n                });\n                this.group.add(text);\n            }\n\n            var value = coordSys.pointToData(point);\n\n            var dims = coordSys.dimensions;\n            value = zrUtil.map(value, function (val, idx) {\n                var axis = coordSys.getAxis(dims[idx]);\n                if (axis.type === 'category' || axis.type === 'time') {\n                    val = axis.scale.getLabel(val);\n                }\n                else {\n                    val = formatUtil.addCommas(\n                        val.toFixed(axis.getPixelPrecision())\n                    );\n                }\n                return val;\n            });\n\n            text.setStyle({\n                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n                textFont: textStyleModel.getFont(),\n                text: value.join(', '),\n                x: point[0] + 5,\n                y: point[1] - 5\n            });\n            text.z = tooltipModel.get('z');\n            text.zlevel = tooltipModel.get('zlevel');\n        },\n\n        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n            var tooltipModel = this._tooltipModel;\n            var z = tooltipModel.get('z');\n            var zlevel = tooltipModel.get('zlevel');\n            var axisPointers = this._axisPointers;\n            var coordSysName = coordSys.name;\n            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n            if (axisPointers[coordSysName][axisType]) {\n                return axisPointers[coordSysName][axisType];\n            }\n\n            // Create if not exists\n            var pointerType = pointerModel.get('type');\n            var styleModel = pointerModel.getModel(pointerType + 'Style');\n            var isShadow = pointerType === 'shadow';\n            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\n            var elementType = coordSys.type === 'polar'\n                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n                : (isShadow ? 'Rect' : 'Line');\n\n            isShadow ? (style.stroke = null) : (style.fill = null);\n\n            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n                style: style,\n                z: z,\n                zlevel: zlevel,\n                silent: true,\n                shape: initShape\n            });\n\n            this.group.add(el);\n            return el;\n        },\n\n        /**\n         * Dispatch actions and show tooltip on series\n         * @param {Array.<module:echarts/model/Series>} seriesList\n         * @param {Array.<number>} point\n         * @param {Array.<number>} value\n         * @param {boolean} contentNotChange\n         * @param {Array.<number>|string|Function} [positionExpr]\n         */\n        _dispatchAndShowSeriesTooltipContent: function (\n            coordSys, seriesList, point, value, contentNotChange, positionExpr\n        ) {\n\n            var rootTooltipModel = this._tooltipModel;\n\n            var baseAxis = coordSys.getBaseAxis();\n            var baseDimIndex = ({x: 1, radius: 1, single: 1})[baseAxis.dim] ? 0 : 1;\n\n            if (!seriesList.length) {\n                return;\n            }\n\n            var payloadBatch = zrUtil.map(seriesList, function (series) {\n                return {\n                    seriesIndex: series.seriesIndex,\n                    dataIndexInside: series.getAxisTooltipDataIndex\n                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n                        : series.getData().indexOfNearest(\n                            series.coordDimToDataDim(baseAxis.dim)[0],\n                            value[baseDimIndex],\n                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n                            false, baseAxis.type === 'category' ? 0.5 : null\n                        )\n                };\n            });\n            var sampleSeriesIndex;\n            zrUtil.each(payloadBatch, function (payload, idx) {\n                if (seriesList[idx].getData().hasValue(payload.dataIndexInside)) {\n                    sampleSeriesIndex = idx;\n                }\n            });\n            // Fallback to 0.\n            sampleSeriesIndex = sampleSeriesIndex || 0;\n\n            var lastHover = this._lastHover;\n            var api = this._api;\n            // Dispatch downplay action\n            if (lastHover.payloadBatch && !contentNotChange) {\n                api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Dispatch highlight action\n            if (!contentNotChange) {\n                api.dispatchAction({\n                    type: 'highlight',\n                    batch: payloadBatch\n                });\n                lastHover.payloadBatch = payloadBatch;\n            }\n            // Dispatch showTip action\n            var dataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n            api.dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                // expose to user.\n                dataIndex: seriesList[sampleSeriesIndex].getData().getRawIndex(dataIndex),\n                seriesIndex: payloadBatch[sampleSeriesIndex].seriesIndex,\n                from: this.uid\n            });\n\n            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n                var paramsList = zrUtil.map(seriesList, function (series, index) {\n                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n                });\n\n                if (!contentNotChange) {\n                    // Update html content\n                    var firstDataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = baseAxis.type === 'time'\n                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n                        : seriesList[sampleSeriesIndex].getData().getName(firstDataIndex);\n                    var defaultHtml = (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + zrUtil.map(seriesList, function (series, index) {\n                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n                        }).join('<br />');\n\n                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\n                    this._showTooltipContent(\n                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n                        point[0], point[1], positionExpr, null, api\n                    );\n                }\n                else {\n                    updatePosition(\n                        positionExpr || rootTooltipModel.get('position'),\n                        point[0], point[1],\n                        rootTooltipModel.get('confine'),\n                        this._tooltipContent, paramsList, null, api\n                    );\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on item\n         * @param {module:echarts/model/Series} seriesModel\n         * @param {number} dataIndex\n         * @param {string} dataType\n         * @param {Object} e\n         */\n        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n            // FIXME Graph data\n            var api = this._api;\n            var data = seriesModel.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var tooltipOpt = itemModel.get('tooltip', true);\n            if (typeof tooltipOpt === 'string') {\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                var tooltipContent = tooltipOpt;\n                tooltipOpt = {\n                    formatter: tooltipContent\n                };\n            }\n            var rootTooltipModel = this._tooltipModel;\n            var seriesTooltipModel = seriesModel.getModel(\n                'tooltip', rootTooltipModel\n            );\n            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\n            var params = seriesModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\n            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\n            this._showTooltipContent(\n                tooltipModel, defaultHtml, params, asyncTicket,\n                e.offsetX, e.offsetY, e.position, e.target, api\n            );\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n                var tooltipContent = this._tooltipContent;\n                var confine = tooltipModel.get('confine');\n\n                var formatter = tooltipModel.get('formatter');\n                positionExpr = positionExpr || tooltipModel.get('position');\n                var html = defaultHtml;\n\n                if (formatter) {\n                    if (typeof formatter === 'string') {\n                        html = formatUtil.formatTpl(formatter, params, true);\n                    }\n                    else if (typeof formatter === 'function') {\n                        var self = this;\n                        var ticket = asyncTicket;\n                        var callback = function (cbTicket, html) {\n                            if (cbTicket === self._ticket) {\n                                tooltipContent.setContent(html);\n\n                                updatePosition(\n                                    positionExpr, x, y, confine,\n                                    tooltipContent, params, target, api\n                                );\n                            }\n                        };\n                        self._ticket = ticket;\n                        html = formatter(params, ticket, callback);\n                    }\n                }\n\n                tooltipContent.show(tooltipModel);\n                tooltipContent.setContent(html);\n\n                updatePosition(\n                    positionExpr, x, y, confine,\n                    tooltipContent, params, target, api\n                );\n            }\n        },\n\n        /**\n         * Show axis pointer\n         * @param {string} [coordSysName]\n         */\n        _showAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.show();\n                });\n            }\n            else {\n                this.group.eachChild(function (child) {\n                    child.show();\n                });\n                this.group.show();\n            }\n        },\n\n        _resetLastHover: function () {\n            var lastHover = this._lastHover;\n            if (lastHover.payloadBatch) {\n                this._api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Reset lastHover\n            this._lastHover = {};\n        },\n        /**\n         * Hide axis pointer\n         * @param {string} [coordSysName]\n         */\n        _hideAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.hide();\n                });\n            }\n            else {\n                if (this.group.children().length) {\n                    this.group.hide();\n                }\n            }\n        },\n\n        _hide: function () {\n            clearTimeout(this._showTimeout);\n\n            this._hideAxisPointer();\n            this._resetLastHover();\n            if (!this._alwaysShowContent) {\n                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._api.dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n\n            this._lastX = this._lastY = null;\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var zr = api.getZr();\n            this._tooltipContent.hide();\n\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipView.js\n// module id = 156\n// module chunks = 0","\n\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/lib/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCreator.js\n// module id = 157\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Axis = require('../Axis');\n    var axisLabelInterval = require('./axisLabelInterval');\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n\n        /**\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Axis2D.js\n// module id = 158\n// module chunks = 0","'use strict';\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian.js\n// module id = 159\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian = require('./Cartesian');\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian2D.js\n// module id = 160\n// module chunks = 0","'use strict';\n// Grid \n//  Cartesian2D \n\n\n    require('./AxisModel');\n    var ComponentModel = require('../../model/Component');\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/GridModel.js\n// module id = 161\n// module chunks = 0","'use strict';\n/**\n * Helper function for axisLabelInterval calculation\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('../axisHelper');\n\n    module.exports = function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n\n        return axisHelper.getAxisLabelInterval(\n            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n            axisModel.getFormattedLabels(),\n            labelModel.getModel('textStyle').getFont(),\n            axis.isHorizontal()\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/axisLabelInterval.js\n// module id = 162\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Axis = require('../Axis');\n\n    function IndicatorAxis(dim, scale, radiusExtent) {\n        Axis.call(this, dim, scale, radiusExtent);\n\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = 'value';\n\n        this.angle = 0;\n\n        /**\n         * Indicator name\n         * @type {string}\n         */\n        this.name = '';\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.model;\n    }\n\n    zrUtil.inherits(IndicatorAxis, Axis);\n\n    module.exports = IndicatorAxis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/radar/IndicatorAxis.js\n// module id = 163\n// module chunks = 0","// TODO clockwise\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var IndicatorAxis = require('./IndicatorAxis');\n    var IntervalScale = require('../../scale/Interval');\n    var numberUtil = require('../../util/number');\n    var axisHelper = require('../axisHelper');\n\n    function Radar(radarModel, ecModel, api) {\n\n        this._model = radarModel;\n        /**\n         * Radar dimensions\n         * @type {Array.<string>}\n         */\n        this.dimensions = [];\n\n        this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n            var dim = 'indicator_' + idx;\n            var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n            indicatorAxis.name = indicatorModel.get('name');\n            // Inject model and axis\n            indicatorAxis.model = indicatorModel;\n            indicatorModel.axis = indicatorAxis;\n            this.dimensions.push(dim);\n            return indicatorAxis;\n        }, this);\n\n        this.resize(radarModel, api);\n\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cx;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.cy;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.r;\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.startAngle;\n    }\n\n    Radar.prototype.getIndicatorAxes = function () {\n        return this._indicatorAxes;\n    };\n\n    Radar.prototype.dataToPoint = function (value, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n\n        return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n    };\n\n    Radar.prototype.coordToPoint = function (coord, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n        var angle = indicatorAxis.angle;\n        var x = this.cx + coord * Math.cos(angle);\n        var y = this.cy - coord * Math.sin(angle);\n        return [x, y];\n    };\n\n    Radar.prototype.pointToData = function (pt) {\n        var dx = pt[0] - this.cx;\n        var dy = pt[1] - this.cy;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        dx /= radius;\n        dy /= radius;\n\n        var radian = Math.atan2(-dy, dx);\n\n        // Find the closest angle\n        // FIXME index can calculated directly\n        var minRadianDiff = Infinity;\n        var closestAxis;\n        var closestAxisIdx = -1;\n        for (var i = 0; i < this._indicatorAxes.length; i++) {\n            var indicatorAxis = this._indicatorAxes[i];\n            var diff = Math.abs(radian - indicatorAxis.angle);\n            if (diff < minRadianDiff) {\n                closestAxis = indicatorAxis;\n                closestAxisIdx = i;\n                minRadianDiff = diff;\n            }\n        }\n\n        return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];\n    };\n\n    Radar.prototype.resize = function (radarModel, api) {\n        var center = radarModel.get('center');\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        var viewSize = Math.min(viewWidth, viewHeight) / 2;\n        this.cx = numberUtil.parsePercent(center[0], viewWidth);\n        this.cy = numberUtil.parsePercent(center[1], viewHeight);\n\n        this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n\n        this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);\n\n        zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {\n            indicatorAxis.setExtent(0, this.r);\n            var angle = (this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length);\n            // Normalize to [-PI, PI]\n            angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n            indicatorAxis.angle = angle;\n        }, this);\n    };\n\n    Radar.prototype.update = function (ecModel, api) {\n        var indicatorAxes = this._indicatorAxes;\n        var radarModel = this._model;\n        zrUtil.each(indicatorAxes, function (indicatorAxis) {\n            indicatorAxis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n            if (radarSeries.get('coordinateSystem') !== 'radar'\n                || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel\n            ) {\n                return;\n            }\n            var data = radarSeries.getData();\n            zrUtil.each(indicatorAxes, function (indicatorAxis) {\n                indicatorAxis.scale.unionExtentFromData(data, indicatorAxis.dim);\n            });\n        }, this);\n\n        var splitNumber = radarModel.get('splitNumber');\n\n        function increaseInterval(interval) {\n            var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));\n            // Increase interval\n            var f = interval / exp10;\n            if (f === 2) {\n                f = 5;\n            }\n            else { // f is 2 or 5\n                f *= 2;\n            }\n            return f * exp10;\n        }\n        // Force all the axis fixing the maxSplitNumber.\n        zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {\n            var rawExtent = axisHelper.getScaleExtent(indicatorAxis, indicatorAxis.model);\n            axisHelper.niceScaleExtent(indicatorAxis, indicatorAxis.model);\n\n            var axisModel = indicatorAxis.model;\n            var scale = indicatorAxis.scale;\n            var fixedMin = axisModel.getMin();\n            var fixedMax = axisModel.getMax();\n            var interval = scale.getInterval();\n\n            if (fixedMin != null && fixedMax != null) {\n                // User set min, max, divide to get new interval\n                // FIXME precision\n                scale.setInterval(\n                    (fixedMax - fixedMin) / splitNumber\n                );\n            }\n            else if (fixedMin != null) {\n                var max;\n                // User set min, expand extent on the other side\n                do {\n                    max = fixedMin + interval * splitNumber;\n                    scale.setExtent(+fixedMin, max);\n                    // Interval must been set after extent\n                    // FIXME\n                    scale.setInterval(interval);\n\n                    interval = increaseInterval(interval);\n                } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n            }\n            else if (fixedMax != null) {\n                var min;\n                // User set min, expand extent on the other side\n                do {\n                    min = fixedMax - interval * splitNumber;\n                    scale.setExtent(min, +fixedMax);\n                    scale.setInterval(interval);\n                    interval = increaseInterval(interval);\n                } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n            }\n            else {\n                var nicedSplitNumber = scale.getTicks().length - 1;\n                if (nicedSplitNumber > splitNumber) {\n                    interval = increaseInterval(interval);\n                }\n                // PENDING\n                var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;\n                var halfSplitNumber = Math.round(splitNumber / 2);\n                scale.setExtent(\n                    numberUtil.round(center - halfSplitNumber * interval),\n                    numberUtil.round(center + (splitNumber - halfSplitNumber) * interval)\n                );\n                scale.setInterval(interval);\n            }\n        });\n    };\n\n    /**\n     * Radar dimensions is based on the data\n     * @type {Array}\n     */\n    Radar.dimensions = [];\n\n    Radar.create = function (ecModel, api) {\n        var radarList = [];\n        ecModel.eachComponent('radar', function (radarModel) {\n            var radar = new Radar(radarModel, ecModel, api);\n            radarList.push(radar);\n            radarModel.coordinateSystem = radar;\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries) {\n            if (radarSeries.get('coordinateSystem') === 'radar') {\n                // Inject coordinate system\n                radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n            }\n        });\n        return radarList;\n    };\n\n    require('../../CoordinateSystem').register('radar', Radar);\n    module.exports = Radar;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/radar/Radar.js\n// module id = 164\n// module chunks = 0","\n\n\n    var axisDefault = require('../axisDefault');\n    var valueAxisDefault = axisDefault.valueAxis;\n    var Model = require('../../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var axisModelCommonMixin = require('../axisModelCommonMixin');\n\n    function defaultsShow(opt, show) {\n        return zrUtil.defaults({\n            show: show\n        }, opt);\n    }\n\n    var RadarModel = require('../../echarts').extendComponentModel({\n\n        type: 'radar',\n\n        optionUpdated: function () {\n            var boundaryGap = this.get('boundaryGap');\n            var splitNumber = this.get('splitNumber');\n            var scale = this.get('scale');\n            var axisLine = this.get('axisLine');\n            var axisTick = this.get('axisTick');\n            var axisLabel = this.get('axisLabel');\n            var nameTextStyle = this.get('name.textStyle');\n            var showName = this.get('name.show');\n            var nameFormatter = this.get('name.formatter');\n            var nameGap = this.get('nameGap');\n            var triggerEvent = this.get('triggerEvent');\n\n            var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {\n                // PENDING\n                if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n                    indicatorOpt.min = 0;\n                }\n                else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n                    indicatorOpt.max = 0;\n                }\n                // Use same configuration\n                indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {\n                    boundaryGap: boundaryGap,\n                    splitNumber: splitNumber,\n                    scale: scale,\n                    axisLine: axisLine,\n                    axisTick: axisTick,\n                    axisLabel: axisLabel,\n                    // Competitable with 2 and use text\n                    name: indicatorOpt.text,\n                    nameLocation: 'end',\n                    nameGap: nameGap,\n                    // min: 0,\n                    nameTextStyle: nameTextStyle,\n                    triggerEvent: triggerEvent\n                }, false);\n                if (!showName) {\n                    indicatorOpt.name = '';\n                }\n                if (typeof nameFormatter === 'string') {\n                    var indName = indicatorOpt.name;\n                    indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n                }\n                else if (typeof nameFormatter === 'function') {\n                    indicatorOpt.name = nameFormatter(\n                        indicatorOpt.name, indicatorOpt\n                    );\n                }\n                var model = zrUtil.extend(\n                    new Model(indicatorOpt, null, this.ecModel),\n                    axisModelCommonMixin\n                );\n\n                // For triggerEvent.\n                model.mainType = 'radar';\n                model.componentIndex = this.componentIndex;\n\n                return model;\n            }, this);\n\n            this.getIndicatorModels = function () {\n                return indicatorModels;\n            };\n        },\n\n        defaultOption: {\n\n            zlevel: 0,\n\n            z: 0,\n\n            center: ['50%', '50%'],\n\n            radius: '75%',\n\n            startAngle: 90,\n\n            name: {\n                show: true\n                // formatter: null\n                // textStyle: {}\n            },\n\n            boundaryGap: [0, 0],\n\n            splitNumber: 5,\n\n            nameGap: 15,\n\n            scale: false,\n\n            // Polygon or circle\n            shape: 'polygon',\n\n            axisLine: zrUtil.merge(\n                {\n                    lineStyle: {\n                        color: '#bbb'\n                    }\n                },\n                valueAxisDefault.axisLine\n            ),\n            axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n            axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n            splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n            splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n\n            // {text, min, max}\n            indicator: []\n        }\n    });\n\n    module.exports = RadarModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/radar/RadarModel.js\n// module id = 165\n// module chunks = 0","'use strict';\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/DataDiffer.js\n// module id = 166\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var parsePercent = numberUtil.parsePercent;\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\n            var stackId = getSeriesStackId(seriesModel);\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n\n            // Caution: In a single coordinate system, these barGrid attributes\n            // will be shared by series. Consider that they have default values,\n            // only the attributes set on the last series will work.\n            // Do not change this fact unless there will be a break change.\n\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (!column.width && maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                if (isNaN(value)) {\n                    return;\n                }\n\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    module.exports = barLayoutGrid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/layout/barGrid.js\n// module id = 167\n// module chunks = 0","\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/loading/default.js\n// module id = 168\n// module chunks = 0","/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = require('./Component');\n\n    var globalDefault = require('./globalDefault');\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption();\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap[mainType], newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap[mainType] = [];\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap[mainType][index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap[mainType];\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap[mainType];\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts;\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap[mainType];\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                each(componentsMap, function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap[mainType], cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.series[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.series.slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.series, cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.series, cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\n            var componentTypes = [];\n            each(componentsMap, function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\n    module.exports = GlobalModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Global.js\n// module id = 169\n// module chunks = 0","/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/OptionManager.js\n// module id = 170\n// module chunks = 0","\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/globalDefault.js\n// module id = 171\n// module chunks = 0","\n    module.exports = {\n        getAreaStyle: require('./makeStyleMapper')(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/areaStyle.js\n// module id = 172\n// module chunks = 0","\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/boxLayout.js\n// module id = 173\n// module chunks = 0","\n    var getItemStyle = require('./makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/itemStyle.js\n// module id = 174\n// module chunks = 0","\n    var getLineStyle = require('./makeStyleMapper')(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/lineStyle.js\n// module id = 175\n// module chunks = 0","\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                // FIXME in node-canvas fontWeight is before fontStyle\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/textStyle.js\n// module id = 176\n// module chunks = 0","// Compatitable with 2.0\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var compatStyle = require('./helper/compatStyle');\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/backwardCompat.js\n// module id = 177\n// module chunks = 0","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/helper/compatStyle.js\n// module id = 178\n// module chunks = 0","\n    var samplers = {\n        average: function (frame) {\n            var sum = 0;\n            var count = 0;\n            for (var i = 0; i < frame.length; i++) {\n                if (!isNaN(frame[i])) {\n                    sum += frame[i];\n                    count++;\n                }\n            }\n            // Return NaN if count is 0\n            return count === 0 ? NaN : sum / count;\n        },\n        sum: function (frame) {\n            var sum = 0;\n            for (var i = 0; i < frame.length; i++) {\n                // Ignore NaN\n                sum += frame[i] || 0;\n            }\n            return sum;\n        },\n        max: function (frame) {\n            var max = -Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] > max && (max = frame[i]);\n            }\n            return max;\n        },\n        min: function (frame) {\n            var min = Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] < min && (min = frame[i]);\n            }\n            return min;\n        },\n        // TODO\n        // Median\n        nearest: function (frame) {\n            return frame[0];\n        }\n    };\n\n    var indexSampler = function (frame, value) {\n        return Math.round(frame.length / 2);\n    };\n    module.exports = function (seriesType, ecModel, api) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var sampling = seriesModel.get('sampling');\n            var coordSys = seriesModel.coordinateSystem;\n            // Only cartesian2d support down sampling\n            if (coordSys.type === 'cartesian2d' && sampling) {\n                var baseAxis = coordSys.getBaseAxis();\n                var valueAxis = coordSys.getOtherAxis(baseAxis);\n                var extent = baseAxis.getExtent();\n                // Coordinste system has been resized\n                var size = extent[1] - extent[0];\n                var rate = Math.round(data.count() / size);\n                if (rate > 1) {\n                    var sampler;\n                    if (typeof sampling === 'string') {\n                        sampler = samplers[sampling];\n                    }\n                    else if (typeof sampling === 'function') {\n                        sampler = sampling;\n                    }\n                    if (sampler) {\n                        data = data.downSample(\n                            valueAxis.dim, 1 / rate, sampler, indexSampler\n                        );\n                        seriesModel.setData(data);\n                    }\n                }\n            }\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/processor/dataSample.js\n// module id = 179\n// module chunks = 0","/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [approxTickNum = 10] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = fixMin;\n            originalScale.__fixMax = fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Log.js\n// module id = 180\n// module chunks = 0","/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Ordinal.js\n// module id = 181\n// module chunks = 0","/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n\n    var IntervalScale = require('./Interval');\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        // Overwrite\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date);\n        },\n\n        // Overwrite\n        niceExtent: function (approxTickNum, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(approxTickNum);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        // Overwrite\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                mathCeil(extent[0] / interval) * interval,\n                mathFloor(extent[1] / interval) * interval\n            ];\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n\n    module.exports = TimeScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Time.js\n// module id = 182\n// module chunks = 0","\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            diff = currCall - (debounce ? lastCall : lastExec) - delay;\n\n            clearTimeout(timer);\n\n            if (debounce) {\n                timer = setTimeout(exec, delay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/throttle.js\n// module id = 183\n// module chunks = 0","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Component.js\n// module id = 184\n// module chunks = 0","\n    var Gradient = require('zrender/lib/graphic/Gradient');\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/seriesColor.js\n// module id = 185\n// module chunks = 0","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 191\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 192\n// module chunks = 0","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\tvar fixedCss = css.replace(/url *\\( *(.+?) *\\)/g, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/fixUrls.js\n// module id = 193\n// module chunks = 0","/**\n  * vue-router v2.2.1\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if (!condition) {\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n  }\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (h, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h()\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // inject instance registration hooks\n    var hooks = data.hook || (data.hook = {});\n    hooks.init = function (vnode) {\n      matched.instances[name] = vnode.child;\n    };\n    hooks.prepatch = function (oldVnode, vnode) {\n      matched.instances[name] = vnode.child;\n    };\n    hooks.destroy = function (vnode) {\n      if (matched.instances[name] === vnode.child) {\n        matched.instances[name] = undefined;\n      }\n    };\n\n    // resolve props\n    data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    return h(component, data, children)\n  }\n};\n\nfunction resolveProps (route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return\n    case 'object':\n      return config\n    case 'function':\n      return config(route)\n    case 'boolean':\n      return config ? route.params : undefined\n    default:\n      warn(false, (\"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", expecting an object, function or boolean.\"));\n  }\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more comformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function (str) { return encodeURIComponent(str)\n  .replace(encodeReserveRE, encodeReserveReplacer)\n  .replace(commaRE, ','); };\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery (\n  query,\n  extraQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  if (query) {\n    var parsedQuery;\n    try {\n      parsedQuery = parseQuery(query);\n    } catch (e) {\n      process.env.NODE_ENV !== 'production' && warn(false, e.message);\n      parsedQuery = {};\n    }\n    for (var key in extraQuery) {\n      parsedQuery[key] = extraQuery[key];\n    }\n    return parsedQuery\n  } else {\n    return extraQuery\n  }\n}\n\nfunction parseQuery (query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0\n      ? decode(parts.join('='))\n      : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return ''\n    }\n\n    if (val === null) {\n      return encode(key)\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.slice().forEach(function (val2) {\n        if (val2 === undefined) {\n          return\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&')\n    }\n\n    return encode(key) + '=' + encode(val)\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom\n) {\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: location.query || {},\n    params: location.params || {},\n    fullPath: getFullPath(location),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom);\n  }\n  return Object.freeze(route)\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch (record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res\n}\n\nfunction getFullPath (ref) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  return (path || '/') + stringifyQuery(query) + hash\n}\n\nfunction isSameRoute (a, b) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return (\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query)\n    )\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params)\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.replace(trailingSlashRE, '/').indexOf(\n      target.path.replace(trailingSlashRE, '/')\n    ) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n    var classes = {};\n    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';\n    var compareTarget = location.path ? createRoute(null, location) : route;\n    classes[activeClass] = this.exact\n      ? isSameRoute(current, compareTarget)\n      : isIncludedRoute(current, compareTarget);\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) { on[e] = handler; });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n};\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  if (e.target && e.target.getAttribute) {\n    var target = e.target.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) { return }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install (Vue) {\n  if (install.installed) { return }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this.$root._router }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get () { return this.$root._route }\n  });\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (this.$options.router) {\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      }\n    }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  if (relative.charAt(0) === '/') {\n    return relative\n  }\n\n  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '.') {\n      continue\n    } else if (segment === '..') {\n      stack.pop();\n    } else {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/\\//g, '/')\n}\n\n/*  */\n\nfunction createRouteMap (\n  routes,\n  oldPathMap,\n  oldNameMap\n) {\n  var pathMap = oldPathMap || Object.create(null);\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathMap, nameMap, route);\n  });\n\n  return {\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (process.env.NODE_ENV !== 'production') {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(\n      typeof route.component !== 'string',\n      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n      \"string id. Use an actual component instead.\"\n    );\n  }\n\n  var record = {\n    path: normalizePath(path, parent),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (process.env.NODE_ENV !== 'production') {\n      if (route.name && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n        warn(\n          false,\n          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n          \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\n          \"the default child route will not be rendered. Remove the name from \" +\n          \"this route and use the name of the default child route for named \" +\n          \"links instead.\"\n        );\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs\n        ? cleanPath((matchAs + \"/\" + (child.path)))\n        : undefined;\n      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    if (Array.isArray(route.alias)) {\n      route.alias.forEach(function (alias) {\n        var aliasRoute = {\n          path: alias,\n          children: route.children\n        };\n        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n      });\n    } else {\n      var aliasRoute = {\n        path: route.alias,\n        children: route.children\n      };\n      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n    }\n  }\n\n  if (!pathMap[record.path]) {\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {\n      warn(\n        false,\n        \"Duplicate named routes definition: \" +\n        \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n      );\n    }\n  }\n}\n\nfunction normalizePath (path, parent) {\n  path = path.replace(/\\/$/, '');\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\nvar index$1 = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\nvar isarray = index$1;\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\nvar regexpCache = Object.create(null);\n\nfunction getRouteRegex (path) {\n  var hit = regexpCache[path];\n  var keys, regexp;\n\n  if (hit) {\n    keys = hit.keys;\n    regexp = hit.regexp;\n  } else {\n    keys = [];\n    regexp = index(path, keys);\n    regexpCache[path] = { keys: keys, regexp: regexp };\n  }\n\n  return { keys: keys, regexp: regexp }\n}\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = index.compile(path));\n    return filler(params || {}, { pretty: true })\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)));\n    }\n    return ''\n  }\n}\n\n/*  */\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next);\n    next._normalized = true;\n    var params = assign(assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = (current && current.path) || '/';\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : (current && current.path) || '/';\n  var query = resolveQuery(parsedPath.query, next.query);\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction assign (a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a\n}\n\n/*  */\n\nfunction createMatcher (routes) {\n  var ref = createRouteMap(routes);\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes (routes) {\n    createRouteMap(routes, pathMap, nameMap);\n  }\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n      }\n      var paramNames = getRouteRegex(record.path).keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n        return _createRoute(record, location, redirectedFrom)\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var path in pathMap) {\n        if (matchRoute(path, location.params, location.path)) {\n          return _createRoute(pathMap[path], location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function'\n        ? originalRedirect(createRoute(record, location))\n        : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      process.env.NODE_ENV !== 'production' && warn(\n        false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n      );\n      return _createRoute(null, location)\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom)\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  }\n}\n\nfunction matchRoute (\n  path,\n  params,\n  pathname\n) {\n  var ref = getRouteRegex(path);\n  var regexp = ref.regexp;\n  var keys = ref.keys;\n  var m = pathname.match(regexp);\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) { params[key.name] = val; }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll () {\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll (\n  router,\n  to,\n  from,\n  isPop\n) {\n  if (!router.app) {\n    return\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n    if (!shouldScroll) {\n      return\n    }\n    var isObject = typeof shouldScroll === 'object';\n    if (isObject && typeof shouldScroll.selector === 'string') {\n      var el = document.querySelector(shouldScroll.selector);\n      if (el) {\n        position = getElementPosition(el);\n      } else if (isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n    } else if (isObject && isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n\n    if (position) {\n      window.scrollTo(position.x, position.y);\n    }\n  });\n}\n\nfunction saveScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key]\n  }\n}\n\nfunction getElementPosition (el) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left,\n    y: elRect.top - docRect.top\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && (function () {\n  var ua = window.navigator.userAgent;\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now\n  ? window.performance\n  : Date;\n\nvar _key = genKey();\n\nfunction genKey () {\n  return Time.now().toFixed(3)\n}\n\nfunction getStateKey () {\n  return _key\n}\n\nfunction setStateKey (key) {\n  _key = key;\n}\n\nfunction pushState (url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\n\nvar History = function History (router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady (cb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n  }\n};\n\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) {\n        cb(route);\n      });\n    }\n  }, onAbort);\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current;\n  var abort = function () { onAbort && onAbort(); };\n  if (\n    isSameRoute(route, current) &&\n    // in the case the route map has been dynamically appended to\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL();\n    return abort()\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // in-component update hooks\n    extractUpdateHooks(updated),\n    // in-config enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  );\n\n  this.pending = route;\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort()\n    }\n    hook(route, current, function (to) {\n      if (to === false) {\n        // next(false) -> abort navigation, ensure current URL\n        this$1.ensureURL(true);\n        abort();\n      } else if (typeof to === 'string' || typeof to === 'object') {\n        // next('/') or next({ path: '/' }) -> redirect\n        (typeof to === 'object' && to.replace) ? this$1.replace(to) : this$1.push(to);\n        abort();\n      } else {\n        // confirm transition and pass on the value\n        next(to);\n      }\n    });\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function () { return this$1.current === route; };\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    runQueue(enterGuards, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort()\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) { return cb(); });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse\n) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n        : bind(guard, instance, match, key)\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n\nfunction extractUpdateHooks (updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n\nfunction bindGuard (guard, instance) {\n  return function boundRouteGuard () {\n    return guard.apply(instance, arguments)\n  }\n}\n\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    })\n  }\n}\n\nfunction poll (\n  cb, // somehow flow cannot infer this is a function\n  instances,\n  key,\n  isValid\n) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\nfunction resolveAsyncComponents (matched) {\n  return flatMapComponents(matched, function (def, _, match, key) {\n    // if it's a function and doesn't have Vue options attached,\n    // assume it's an async component resolve function.\n    // we are not using Vue's default async resolving mechanism because\n    // we want to halt the navigation until the incoming component has been\n    // resolved.\n    if (typeof def === 'function' && !def.options) {\n      return function (to, from, next) {\n        var resolve = once(function (resolvedDef) {\n          match.components[key] = resolvedDef;\n          next();\n        });\n\n        var reject = once(function (reason) {\n          warn(false, (\"Failed to resolve async component \" + key + \": \" + reason));\n          next(false);\n        });\n\n        var res = def(resolve, reject);\n        if (res && typeof res.then === 'function') {\n          res.then(resolve, reject);\n        }\n      }\n    }\n  })\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (called) { return }\n    called = true;\n    return fn.apply(this, arguments)\n  }\n}\n\n/*  */\n\n\nvar HTML5History = (function (History$$1) {\n  function HTML5History (router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener('popstate', function (e) {\n      this$1.transitionTo(getLocation(this$1.base), function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, this$1.current, true);\n        }\n      });\n    });\n  }\n\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, this$1.current, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, this$1.current, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getLocation(this.base)\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\n/*  */\n\n\nvar HashHistory = (function (History$$1) {\n  function HashHistory (router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    ensureSlash();\n  }\n\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    window.addEventListener('hashchange', function () {\n      if (!ensureSlash()) {\n        return\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        replaceHash(route.fullPath);\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getHash()\n  };\n\n  return HashHistory;\n}(History));\n\nfunction checkFallback (base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(\n      cleanPath(base + '/#' + location)\n    );\n    return true\n  }\n}\n\nfunction ensureSlash () {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path);\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path;\n}\n\nfunction replaceHash (path) {\n  var i = window.location.href.indexOf('#');\n  window.location.replace(\n    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n  );\n}\n\n/*  */\n\n\nvar AbstractHistory = (function (History$$1) {\n  function AbstractHistory (router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/'\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || []);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        assert(false, (\"invalid mode: \" + mode));\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: {} };\n\nVueRouter.prototype.match = function match (\n  raw,\n  current,\n  redirectedFrom\n) {\n  return this.matcher.match(raw, current, redirectedFrom)\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n  process.env.NODE_ENV !== 'production' && assert(\n    install.installed,\n    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n    \"before creating root instance.\"\n  );\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      history.setupListeners();\n    };\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    );\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  this.beforeHooks.push(fn);\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  this.afterHooks.push(fn);\n};\n\nVueRouter.prototype.onReady = function onReady (cb) {\n  this.history.onReady(cb);\n};\n\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? this.resolve(to).route\n    : this.currentRoute;\n  if (!route) {\n    return []\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key]\n    })\n  }))\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  var location = normalizeLocation(to, current || this.history.current, append);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  }\n};\n\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = install;\nVueRouter.version = '2.2.1';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\nexport default VueRouter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-router/dist/vue-router.esm.js\n// module id = 221\n// module chunks = 0","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetEl \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 222\n// module chunks = 0","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 223\n// module chunks = 0","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.isBuildin) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        this.pathToImage = this._createPathToImage();\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuildinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuildinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.isBuildin) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n\n            layersMap[zlevel] = layer;\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (! layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [0, 0, 0];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                id: id,\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        },\n\n        _createPathToImage: function () {\n            var me = this;\n\n            return function (id, e, width, height) {\n                return me._pathToImage(\n                    id, e, width, height, me.dpr\n                );\n            };\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 224\n// module chunks = 0","'use strict';\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // idmap\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [elId] Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // elId\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 225\n// module chunks = 0","'use strict';\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 226\n// module chunks = 0","/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (globalTime - this._startTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 227\n// module chunks = 0","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 228\n// module chunks = 0","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 229\n// module chunks = 0","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 230\n// module chunks = 0","\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 231\n// module chunks = 0","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 232\n// module chunks = 0","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 233\n// module chunks = 0","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 234\n// module chunks = 0","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 235\n// module chunks = 0","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function() {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function(val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function(entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function(entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function() {\n        return this._len;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function(val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function(maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function(key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function(key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function() {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 236\n// module chunks = 0","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 237\n// module chunks = 0","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 238\n// module chunks = 0","// CompoundPath to improve performance\n\n\n    var Path = require('./Path');\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/CompoundPath.js\n// module id = 239\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 240\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 241\n// module chunks = 0","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 242\n// module chunks = 0","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 243\n// module chunks = 0","/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 244\n// module chunks = 0","/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 245\n// module chunks = 0","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 246\n// module chunks = 0","/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 247\n// module chunks = 0","'use strict';\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 248\n// module chunks = 0","'use strict';\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 249\n// module chunks = 0","/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 250\n// module chunks = 0","/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 251\n// module chunks = 0","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 252\n// module chunks = 0","/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 253\n// module chunks = 0","/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 254\n// module chunks = 0","/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = require('../../core/env');\n    var Path = require('../Path');\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 255\n// module chunks = 0","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 256\n// module chunks = 0","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 257\n// module chunks = 0","'use strict';\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 258\n// module chunks = 0","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 259\n// module chunks = 0","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 260\n// module chunks = 0","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.3.0';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromMap, \n        // FIXME ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 261\n// module chunks = 0"],"sourceRoot":""}